import { ChainId, ConnectorNames, CounterFactualInfo, GetAvailableBrokerRequest, GetCounterFactualInfoRequest, RESULT_INFO, TX_HASH_API } from "../defs";
import { Request } from "./request";
import Web3 from "web3";
import { AxiosResponse } from "axios";
export declare const KEY_MESSAGE: string;
export declare class BaseAPI {
    static KEY_MESSAGE: string;
    protected baseUrl: string;
    protected chainId: ChainId;
    genErr(err: Error | (AxiosResponse & Error)): RESULT_INFO;
    protected returnTxHash<T extends TX_HASH_API>(raw_data: T): (Omit<T, "resultInfo"> & {
        raw_data: Omit<T, "resultInfo">;
    }) | RESULT_INFO;
    private timeout;
    private baseUrlMap;
    constructor(param: InitParam, timeout?: number, baseUrlMap?: {
        1: string;
        5: string;
    });
    getAvailableBroker(request: GetAvailableBrokerRequest): Promise<{
        broker: string;
    }>;
    getCounterFactualInfo<T extends any>(request: GetCounterFactualInfoRequest): Promise<{
        raw_data: T;
        counterFactualInfo: CounterFactualInfo | undefined;
        error?: RESULT_INFO;
    }>;
    setChainId(chainId: ChainId): void;
    setBaseUrl(baseUrl: string): void;
    protected makeReq(): Request;
}
export declare function ecRecover(web3: Web3, account: string, msg: string, sig: any): Promise<unknown>;
export declare function contractWalletValidate32(web3: any, account: string, msg: string, sig: any): Promise<unknown>;
export declare function mykeyWalletValid(web3: any, account: string, msg: string, sig: any): Promise<unknown>;
export declare function ecRecover2(account: string, message: string, signature: any): Promise<unknown>;
/**
 * @default chainId 1
 * @default keySeed `Sign this message to access Loopring exchange: ${exchangeAddress} with key nonce: ${nonce}`
 */
export interface InitParam {
    chainId?: ChainId;
    baseUrl?: string;
}
export declare function formatSig(rpcSig: string): string;
export declare function recoverSignType(web3: any, account: string, msg: string, sig: string): "" | "03";
export declare function personalSign(web3: any, account: string | undefined, pwd: string, msg: string, walletType: ConnectorNames, chainId: ChainId, accountId?: number, counterFactualInfo?: CounterFactualInfo, isMobile?: boolean): Promise<unknown>;
export declare function fcWalletValid(web3: any, account: string, msg: string, result: any, accountId: number, chainId: ChainId, counterFactualInfo?: CounterFactualInfo): Promise<{
    counterFactualInfo?: CounterFactualInfo;
    error?: any;
    result?: boolean;
}>;
