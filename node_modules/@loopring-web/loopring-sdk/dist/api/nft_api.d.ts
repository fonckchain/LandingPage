import { BaseAPI } from "./base_api";
import { CollectionMeta, RESULT_INFO } from "../defs";
import { NftData, NFTTokenInfo } from "../defs";
import { ApproveParam, CallRefreshNFT, ContractNFTMetaParam, DepositNFTParam, IsApproveParam, UserNFTBalanceParam } from "../defs/nft_defs";
import * as loopring_defs from "../defs/loopring_defs";
export declare enum NFTType {
    ERC1155 = 0,
    ERC721 = 1
}
export declare enum NFT_TYPE_STRING {
    ERC1155 = "ERC1155",
    ERC721 = "ERC721"
}
export declare enum NFTMethod {
    setApprovalForAll = "setApprovalForAll",
    isApprovedForAll = "isApprovedForAll",
    uri = "uri",
    tokenURI = "tokenURI",
    depositNFT = "depositNFT",
    balanceOf = "balanceOf",
    ownerOf = "ownerOf"
}
export declare class NFTAPI extends BaseAPI {
    private callContractMethod;
    private _genContractData;
    private _genERC1155Data;
    private _genERC721Data;
    private _genContract;
    /**
     * getNFTBalance
     * @param web3
     * @param tokenAddress
     * @param account
     * @param nftId
     * @param nftType
     */
    getNFTBalance({ web3, tokenAddress, account, nftId, nftType, }: UserNFTBalanceParam): Promise<{
        count?: string;
    }>;
    /**
     * getInfoForNFTTokens
     * @param nftDatas NftData[]
     */
    getInfoForNFTTokens({ nftDatas, }: {
        nftDatas: NftData[];
    }): Promise<{
        [key: string]: NFTTokenInfo;
    } | undefined>;
    callRefreshNFT(request: CallRefreshNFT): Promise<{
        status: string;
        createdAt: number;
        updatedAt: number;
    } | undefined>;
    /**
     * getContractNFTMeta
     * @param web3
     * @param tokenAddress
     * @param _id
     * @param nftType
     */
    getContractNFTMeta({ web3, tokenAddress, nftId, nftType, }: ContractNFTMetaParam, _IPFS_META_URL?: string): Promise<any>;
    /**
     * approveNFT
     * @param web3
     * @param from  The address that deposits the funds to the exchange
     * @param to  The address deposits to
     * @param nftId the nftId
     * @param chainId
     * @param nftType The type of NFTAction contract address (ERC721/ERC1155/...)
     * @param nonce
     * @param gasPrice
     * @param gasLimit
     * @param sendByMetaMask
     */
    approveNFT({ web3, from, depositAddress, tokenAddress, nftId, nftType, gasPrice, gasLimit, chainId, nonce, approved, sendByMetaMask, }: ApproveParam): Promise<any>;
    ipfsCid0ToNftID(cidV0Str: string): string;
    /**
     *
     * @param nftId  16
     */
    ipfsNftIDToCid(nftId: string): any;
    /**
     * isApprovedForAll
     * @param web3
     * @param from The address that deposits the funds to the exchange
     * @param exchangeAddress loopring exchange address
     * @param nftType  NFTType
     * @param tokenAddress  The address of NFT token
     */
    isApprovedForAll({ web3, from, exchangeAddress, nftType, tokenAddress, }: IsApproveParam): Promise<any>;
    /**
     * @DepositParam  an NFTAction to the specified account.
     * @param web3
     * @param from The address that deposits the funds to the exchange
     * @param to The account owner's address receiving the funds
     * @param nftType The type of NFTAction contract address (ERC721/ERC1155/...)
     * @param tokenAddress The address of NFTAction token
     * @param nftId The token type 'id`.
     * @param amount The amount of tokens to deposit.
     * @param nonce: number,
     * @param gasPrice: number,
     * @param gasLimit: number,
     * @param extraData Optional extra data used by the deposit contract.
     * @param chainId  0|5
     * @param sendByMetaMask boolean
     */
    depositNFT({ web3, from, exchangeAddress, nftType, tokenAddress, nftId, amount, gasPrice, gasLimit, chainId, nonce, extraData, sendByMetaMask, }: DepositNFTParam): Promise<any>;
    /**
     *
     * @function computeNFTAddress
     * @param owner {string} nftOwner address
     * @param nftFactory {string} Hash address
     * @return tokenAddress
     * @throws Error
     */
    computeNFTAddress({ nftOwner, nftFactory, nftBaseUri, }: {
        nftOwner: string;
        nftFactory?: string;
        nftBaseUri?: string;
    }): {
        tokenAddress: string;
    };
    getPublicCollectionById<R extends CollectionMeta>(request: {
        id: string;
    }): Promise<({
        raw_data: R;
    } & CollectionMeta) | RESULT_INFO>;
    getCollectionWholeNFTs<R>(request: loopring_defs.GetCollectionWholeNFTsRequest): Promise<any>;
}
