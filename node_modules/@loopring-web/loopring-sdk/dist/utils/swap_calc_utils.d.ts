import { AmmPoolSnapshot, CalDualResult, CEX_MARKET, CexResult, DefiMarketInfo, DepthData, DualBalance, DualIndex, DualProductAndPrice, DualRulesCoinsInfo, ExitAmmPoolRequest, JoinAmmPoolRequest, LoopringMap, MarketInfo, OffchainFeeInfo, TokenInfo, TokenVolumeV3, XOR } from "../defs";
import BigNumber from "bignumber.js";
export declare const getToken: (tokens: any, token: any) => any;
export declare const getTokenInfoByToken: (ammBalance: any, tokens: any, token: any) => {
    tokenInfo: any;
    tokenVol: any;
    reserve: BigNumber;
};
export declare function fromWEI(tokens: any, symbol: any, valueInWEI: any, precision?: any, ceil?: any): string | undefined;
export declare function toWEI(tokens: any, symbol: any, value: any, rm?: any): string;
export declare function isEmpty(input: any): boolean;
export declare function getReserveInfo(sell: string, buy: string, marketArr: string[], tokenMap: LoopringMap<TokenInfo>, marketMap: LoopringMap<MarketInfo>, ammPoolSnapshot?: AmmPoolSnapshot | undefined): {
    reserveIn: string;
    reserveOut: string;
    sellToken: TokenInfo | undefined;
    buyToken: TokenInfo | undefined;
    coinA: TokenVolumeV3 | undefined;
    coinB: TokenVolumeV3 | undefined;
    isReverse: boolean;
    marketInfo: MarketInfo;
} | undefined;
export declare function getCurPrice(reserveIn: string, reserveOut: string): string;
export declare function getToPrice(amountS: string, amountB: string): string;
export declare function getPriceImpact(reserveIn: string, reserveOut: string, amountS: string, feeBips: string, takerFee: string): string;
export declare function updatePriceImpact_new(reverseIn: string, reverseOut: string, amountS: string, sellDecimal: number, amountBOut: string, buyDecimal: number, feeBips: string, takerFee: string, isAtoB: boolean, isReversed: boolean, exceedDepth: boolean, depth: DepthData): string;
export declare function getMinReceived(amountBOut: string, minimumDecimal: number, slipBips: string): {
    minReceived: string;
    minReceivedVal: string;
    minimumDecimal: number;
};
export declare function getOutputAmount({ input, sell, buy, isAtoB, marketArr, tokenMap, marketMap, depth, ammPoolSnapshot, feeBips, takerRate, slipBips, }: {
    input: string;
    sell: string;
    buy: string;
    isAtoB: boolean;
    marketArr: string[];
    tokenMap: LoopringMap<TokenInfo>;
    marketMap: LoopringMap<MarketInfo>;
    depth: DepthData;
    ammPoolSnapshot: AmmPoolSnapshot | undefined;
    feeBips: string;
    takerRate: string;
    slipBips: string;
}): {
    exceedDepth: boolean;
    isReverse: boolean;
    isAtoB: boolean;
    slipBips: string;
    takerRate: string;
    feeBips: string;
    output: any;
    sellAmt: string;
    buyAmt: string;
    amountS: string;
    amountBOut: string;
    amountBOutWithoutFee: string;
    amountBOutSlip: {
        minReceived: string;
        minReceivedVal: string;
        minimumDecimal: number;
    };
    priceImpact: string;
} | undefined;
export declare function ammPoolCalc(rawVal: string, isAtoB: boolean, coinA: TokenVolumeV3, coinB: TokenVolumeV3): {
    output: string;
    ratio: BigNumber;
};
/**
 *
 * @param rawVal
 * @param isAtoB
 * @param slippageTolerance
 * @param owner
 * @param fees
 * @param ammPoolSnapshot
 * @param tokenMap
 * @param idIdx
 * @param coinAOffchainId
 * @param coinBOffchainId
 * @param rawValMatchForRawVal first time add to pool
 */
export declare function makeJoinAmmPoolRequest(rawVal: string, isAtoB: boolean, slippageTolerance: string, owner: string, fees: LoopringMap<OffchainFeeInfo>, ammPoolSnapshot: AmmPoolSnapshot, tokenMap: LoopringMap<TokenInfo>, idIdx: LoopringMap<string>, coinAOffchainId?: number, coinBOffchainId?: number, rawValMatchForRawVal?: string): {
    request: JoinAmmPoolRequest;
};
export declare function makeExitAmmPoolMini(rawVal: string, ammPoolSnapshot: AmmPoolSnapshot, tokenMap: LoopringMap<TokenInfo>, idIdx: LoopringMap<string>, RatioDecimal?: number): {
    miniLpVol: string;
    miniLpVal: string;
};
export declare function makeExitAmmCoverFeeLP(fees: LoopringMap<OffchainFeeInfo>, ammPoolSnapshot: AmmPoolSnapshot, tokenMap: LoopringMap<TokenInfo>, idIdx: LoopringMap<string>, slippageTolerance?: string): {
    feeLp: string;
    feeLpWithSlippage: string;
    miniFeeLpWithSlippageVal: string;
    feeLpVal: string;
};
export declare function makeExitAmmPoolRequest2(rawVal: string, slippageTolerance: string, owner: string, fees: LoopringMap<OffchainFeeInfo>, ammPoolSnapshot: AmmPoolSnapshot, tokenMap: LoopringMap<TokenInfo>, idIdx: LoopringMap<string>, offchainId?: number, minDecimal?: number): {
    ratio: string;
    volA: string;
    volB: string;
    volA_show: string;
    volB_show: string;
    request: ExitAmmPoolRequest;
};
/**
 * calcDefi
 * @param isJoin {boolean} true is join, false is exit
 * @param isInputSell {boolean} user input sell of buy
 * @param XOR<sellAmount,buyAmount> user input sell amount number (without decimals)
 * @param feeVol fee Volume from server-side (decimals)
 * @param marketInfo {DefiMarketInfo} DefiMarketInfo from sever-side
 * @param tokenSell {TokenInfo} token Config information
 * @param tokenBuy {TokenInfo} token Config information
 * @param buyTokenBalanceVol   buy Token Balance server-side (decimals)
 * @return {sellVol} sell Volume (decimals);
 * @return {buyVol} buy Volume (decimals);
 * @return {maxSellVol} max Sell Volume (decimals); please use ceil for view
 * @return {miniSellVol} min Sell Volume (decimals); please use round for view
 * @return {maxFeeBips} number maxFeeBips;
 * @return {isJoin} boolean;
 * @return {isInputSell} boolean;
 */
export declare function calcDefi({ isJoin, isInputSell, sellAmount, buyAmount, feeVol, marketInfo, tokenSell, tokenBuy, buyTokenBalanceVol, }: {
    isJoin: boolean;
    isInputSell: boolean;
    feeVol: string;
    marketInfo: DefiMarketInfo;
    tokenSell: TokenInfo;
    tokenBuy: TokenInfo;
    buyTokenBalanceVol: string;
} & XOR<{
    sellAmount: string;
}, {
    buyAmount: string;
}>): {
    sellVol: string;
    buyVol: string;
    maxSellVol: string;
    maxFeeBips: number;
    miniSellVol: string;
    isJoin: boolean;
    isInputSell: boolean;
};
/**
 *
 * @param info
 * @param index
 * @param rule
 * @param balance
 * @param feeVol
 * @param sellToken
 * @param buyToken
 * @param sellAmount
 * @param currentPrice
 */
export declare function calcDual({ info, index, rule, balance, feeVol, sellToken, buyToken, sellAmount, dualMarket, }: {
    sellAmount: string | undefined;
    info: DualProductAndPrice;
    index: DualIndex;
    rule: DualRulesCoinsInfo;
    balance: {
        [key: string]: DualBalance;
    };
    sellToken: TokenInfo;
    buyToken: TokenInfo;
    feeVol?: string | undefined;
    dualMarket: DefiMarketInfo;
}): CalDualResult;
/**
 *
 * @param info  CEX_MARKET
 * @param index
 * @param rule
 * @param balance
 * @param feeVol
 * @param sellToken
 * @param buyToken
 * @param sellAmount
 * @param currentPrice
 */
export declare function calcDex({ info, input, sell, buy, isAtoB, marketArr, tokenMap, marketMap, depth, feeBips, }: {
    info: CEX_MARKET;
    input: string;
    sell: string;
    buy: string;
    isAtoB: boolean;
    marketArr: string[];
    tokenMap: LoopringMap<TokenInfo>;
    marketMap: LoopringMap<MarketInfo>;
    depth: DepthData;
    feeBips: string;
}): CexResult | undefined;
