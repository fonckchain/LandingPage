'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ethUtil = require('ethereumjs-util');
var BN = _interopDefault(require('bn.js'));
var BigNumber = _interopDefault(require('bignumber.js'));
var axios = _interopDefault(require('axios'));
var sha256 = _interopDefault(require('crypto-js/sha256'));
var abi = require('ethereumjs-abi');
var sigUtil = require('eth-sig-util');
var ethers = require('ethers');
var jsbn = require('jsbn');
var jsSha512 = require('js-sha512');
var webEncoding = require('web-encoding');
var tx = require('@ethereumjs/tx');

/* eslint-disable no-console  */
var dumpError400 = function dumpError400(reason, src) {
  if (src === void 0) {
    src = "";
  }

  if (src) {
    console.debug("src:", src);
  }

  if (reason != null && reason.response) {
    console.error(reason.response.data);
  } else {
    console.error(reason.message);
  }
};
function sleep(milliseconds) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, milliseconds);
  });
}

var specialSymbols = ["ETH2x-FIL"];
function getBaseQuote(symbol) {
  if (!symbol) {
    return {
      base: undefined,
      quote: undefined
    };
  }

  if (symbol.startsWith("AMM-")) {
    symbol = symbol.substr(4);
  }

  if (specialSymbols.length > 0) {
    for (var i = 0; i < specialSymbols.length; i++) {
      var ind = symbol.indexOf(specialSymbols[i]);

      if (ind >= 0) {
        if (ind === 0) {
          return {
            base: specialSymbols[i],
            quote: symbol.substr(symbol.lastIndexOf("-") + 1)
          };
        } else {
          return {
            base: symbol.substr(0, symbol.indexOf("-")),
            quote: specialSymbols[i]
          };
        }
      }
    }
  }

  var base = symbol.substr(0, symbol.indexOf("-"));
  var quote = symbol.substr(symbol.indexOf("-") + 1);
  return {
    base: base,
    quote: quote
  };
}
var getTokenInfoBySymbol = function getTokenInfoBySymbol(tokenSymbolMap, symbol) {
  if (!tokenSymbolMap) {
    return undefined;
  }

  try {
    return tokenSymbolMap[symbol];
  } catch (err) {
    return undefined;
  }

  return undefined;
};
var getTokenInfoById = function getTokenInfoById(tokenIdMap, id) {
  if (!tokenIdMap) {
    return undefined;
  }

  try {
    return tokenIdMap[id];
  } catch (err) {
    return undefined;
  }

  return undefined;
};
var hasMarket = function hasMarket(marketArr, market) {
  if (!marketArr) {
    return false;
  }

  if (marketArr.includes(market)) {
    return true;
  }

  return false;
};
var getExistedMarket = function getExistedMarket(marketArr, base, quote) {
  var market = undefined;
  var baseShow = undefined;
  var quoteShow = undefined;

  if (base && quote) {
    market = base + "-" + quote;
    baseShow = base;
    quoteShow = quote;

    if (!hasMarket(marketArr, market)) {
      market = quote + "-" + base;

      if (hasMarket(marketArr, market)) {
        baseShow = quote;
        quoteShow = base;
      } else {
        market = undefined;
        baseShow = undefined;
        quoteShow = undefined;
      }
    }
  }

  var amm = market ? "AMM-" + market : undefined;
  return {
    market: market,
    amm: amm,
    baseShow: baseShow,
    quoteShow: quoteShow
  };
};
var getPair = function getPair(marketArr, market) {
  var _getBaseQuote = getBaseQuote(market),
      base = _getBaseQuote.base,
      quote = _getBaseQuote.quote;

  return getExistedMarket(marketArr, base, quote);
};

var _NFTFactory, _NFTFactory_Collectio;

(function (ChainId) {
  ChainId[ChainId["MAINNET"] = 1] = "MAINNET";
  ChainId[ChainId["GOERLI"] = 5] = "GOERLI";
})(exports.ChainId || (exports.ChainId = {}));

var NetworkContextName = "NETWORK";

(function (ConnectorNames) {
  ConnectorNames["Unknown"] = "Unknown";
  ConnectorNames["MetaMask"] = "MetaMask";
  ConnectorNames["Network"] = "Network";
  ConnectorNames["WalletConnect"] = "WalletConnect";
  ConnectorNames["Gamestop"] = "Gamestop";
  ConnectorNames["OtherExtension"] = "OtherExtension";
  ConnectorNames["Coinbase"] = "Coinbase";
  ConnectorNames["Ledger"] = "Ledger";
  ConnectorNames["Trezor"] = "Trezor";
  ConnectorNames["Authereum"] = "Authereum";
})(exports.ConnectorNames || (exports.ConnectorNames = {}));

(function (SigSuffix) {
  SigSuffix["Suffix02"] = "02";
  SigSuffix["Suffix03"] = "03";
})(exports.SigSuffix || (exports.SigSuffix = {}));

var NFTFactory = (_NFTFactory = {}, _NFTFactory[exports.ChainId.MAINNET] = "0xc852aC7aAe4b0f0a0Deb9e8A391ebA2047d80026", _NFTFactory[exports.ChainId.GOERLI] = "0x0ad87482a1bfd0B3036Bb4b13708C88ACAe1b8bA", _NFTFactory);
var NFTFactory_Collection = (_NFTFactory_Collectio = {}, _NFTFactory_Collectio[exports.ChainId.MAINNET] = "0x97BE94250AEF1Df307749aFAeD27f9bc8aB911db", _NFTFactory_Collectio[exports.ChainId.GOERLI] = "0x0ad87482a1bfd0B3036Bb4b13708C88ACAe1b8bA", _NFTFactory_Collectio);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["topic"],
    _excluded2 = ["topic"];

(function (WsOps) {
  WsOps["Sub"] = "sub";
  WsOps["Unsub"] = "unSub";
})(exports.WsOps || (exports.WsOps = {}));

(function (WsTopicType) {
  WsTopicType["account"] = "account";
  WsTopicType["order"] = "order";
  WsTopicType["trade"] = "trade";
  WsTopicType["mixtrade"] = "mixtrade";
  WsTopicType["ticker"] = "ticker";
  WsTopicType["candlestick"] = "candlestick";
  WsTopicType["ammpool"] = "ammpool";
  WsTopicType["orderbook"] = "orderbook";
  WsTopicType["mixorder"] = "mixorder";
  WsTopicType["cefiOrderBook"] = "cefiOrderBook";
})(exports.WsTopicType || (exports.WsTopicType = {}));

var getAccountArg = function getAccountArg() {
  return {
    topic: exports.WsTopicType.account
  };
};
var getOrderArg = function getOrderArg(market) {
  return {
    topic: exports.WsTopicType.order,
    market: market
  };
};
var getOrderBookArg = function getOrderBookArg(_ref) {
  var _ref$topic = _ref.topic,
      topic = _ref$topic === void 0 ? exports.WsTopicType.orderbook : _ref$topic,
      market = _ref.market,
      level = _ref.level,
      count = _ref.count,
      snapshot = _ref.snapshot,
      showOverlap = _ref.showOverlap;
  var obj = {
    topic: topic,
    market: market,
    level: level,
    count: count,
    snapshot: snapshot,
    showOverlap: showOverlap
  };
  Object.keys(obj).forEach(function (key) {
    return obj[key] === undefined ? delete obj[key] : {};
  });
  return obj;
};
var getMixOrderArg = function getMixOrderArg(_ref2) {
  var _ref2$topic = _ref2.topic,
      topic = _ref2$topic === void 0 ? exports.WsTopicType.mixorder : _ref2$topic,
      orderWsRequest = _objectWithoutPropertiesLoose(_ref2, _excluded);

  return getOrderBookArg(_extends({
    topic: topic
  }, orderWsRequest));
};
var getCefiOrderBook = function getCefiOrderBook(_ref3) {
  var _ref3$topic = _ref3.topic,
      topic = _ref3$topic === void 0 ? exports.WsTopicType.cefiOrderBook : _ref3$topic,
      orderWsRequest = _objectWithoutPropertiesLoose(_ref3, _excluded2);

  return getOrderBookArg(_extends({
    topic: topic
  }, orderWsRequest));
};
var getTradeArg = function getTradeArg(market) {
  return {
    topic: exports.WsTopicType.trade,
    market: market
  };
};
var getMixTradeArg = function getMixTradeArg(market) {
  return {
    topic: exports.WsTopicType.mixtrade,
    market: market
  };
};
var getTickerArg = function getTickerArg(market) {
  return {
    topic: exports.WsTopicType.ticker,
    market: market
  };
};
var getCandlestickArg = function getCandlestickArg(market) {
  return {
    topic: exports.WsTopicType.candlestick,
    market: market
  };
};
var getAmmpoolArg = function getAmmpoolArg(poolAddress) {
  return {
    topic: exports.WsTopicType.ammpool,
    snapshot: true,
    poolAddress: poolAddress
  };
};

(function (LOOPRING_URLs) {
  LOOPRING_URLs["GET_AVAILABLE_BROKER"] = "/api/v3/getAvailableBroker";
  LOOPRING_URLs["GET_RELAYER_CURRENT_TIME"] = "/api/v3/timestamp";
  LOOPRING_URLs["API_KEY_ACTION"] = "/api/v3/apiKey";
  LOOPRING_URLs["GET_NEXT_STORAGE_ID"] = "/api/v3/storageId";
  LOOPRING_URLs["ORDER_ACTION"] = "/api/v3/order";
  LOOPRING_URLs["ORDER_CANCEL_HASH_LIST"] = "/api/v3/orders/byHash";
  LOOPRING_URLs["ORDER_CANCEL_CLIENT_ORDER_ID_LIST"] = "/api/v3/orders/byClientOrderId";
  LOOPRING_URLs["GET_MULTI_ORDERS"] = "/api/v3/orders";
  LOOPRING_URLs["GET_MARKETS"] = "/api/v3/exchange/markets";
  LOOPRING_URLs["GET_TOKENS"] = "/api/v3/exchange/tokens";
  LOOPRING_URLs["GET_EXCHANGE_INFO"] = "/api/v3/exchange/info";
  LOOPRING_URLs["GET_WITHDRAWAL_AGENTS"] = "/api/v3/exchange/withdrawalAgents";
  LOOPRING_URLs["GET_EXCHANGE_FEEINFO"] = "/api/v3/exchange/feeInfo";
  LOOPRING_URLs["GET_IGNORE_WITHDRAW"] = "/api/v3/exchange/notWithdrawContractTokens";
  LOOPRING_URLs["GET_MIX_MARKETS"] = "/api/v3/mix/markets";
  LOOPRING_URLs["GET_DEPTH"] = "/api/v3/depth";
  LOOPRING_URLs["GET_MIX_DEPTH"] = "/api/v3/mix/depth";
  LOOPRING_URLs["GET_TICKER"] = "/api/v3/ticker";
  LOOPRING_URLs["GET_MIX_TICKER"] = "/api/v3/mix/ticker";
  LOOPRING_URLs["GET_CANDLESTICK"] = "/api/v3/candlestick";
  LOOPRING_URLs["GET_MIX_CANDLESTICK"] = "/api/v3/mix/candlestick";
  LOOPRING_URLs["GET_FIAT_PRICE"] = "/api/v3/price";
  LOOPRING_URLs["GET_TRADES"] = "/api/v3/trade";
  LOOPRING_URLs["POST_INTERNAL_TRANSFER"] = "/api/v3/transfer";
  LOOPRING_URLs["ACCOUNT_ACTION"] = "/api/v3/account";
  LOOPRING_URLs["COUNTER_FACTUAL_INFO"] = "/api/v3/counterFactualInfo";
  LOOPRING_URLs["GET_USER_REG_TXS"] = "/api/v3/user/createInfo";
  LOOPRING_URLs["GET_PWD_RESET_TXS"] = "/api/v3/user/updateInfo";
  LOOPRING_URLs["GET_USER_EXCHANGE_BALANCES"] = "/api/v3/user/balances";
  LOOPRING_URLs["GET_USER_DEPOSITS_HISTORY"] = "/api/v3/user/deposits";
  LOOPRING_URLs["WITHDRAWALS_ACTION"] = "/api/v3/user/withdrawals";
  LOOPRING_URLs["POST_FORCE_WITHDRAWALS"] = "/api/v3/user/forceWithdrawals";
  LOOPRING_URLs["GET_USER_TRANSFERS_LIST"] = "/api/v3/user/transfers";
  LOOPRING_URLs["GET_USER_TRADE_HISTORY"] = "/api/v3/user/trades";
  LOOPRING_URLs["GET_USER_TXS"] = "/api/v3/user/transactions";
  LOOPRING_URLs["GET_USER_FEE_RATE"] = "/api/v3/user/feeRates";
  LOOPRING_URLs["GET_USER_ORDER_FEE_RATE"] = "/api/v3/user/orderFee";
  LOOPRING_URLs["GET_MINIMAL_ORDER_AMT"] = "/api/v3/user/orderAmount";
  LOOPRING_URLs["GET_MINIMUM_TOKEN_AMT"] = "/api/v3/user/orderUserRateAmount";
  LOOPRING_URLs["GET_OFFCHAIN_FEE_AMT"] = "/api/v3/user/offchainFee";
  LOOPRING_URLs["GET_USER_BILLS"] = "/api/v3/user/bills";
  LOOPRING_URLs["GET_ALLOWANCES"] = "/api/v3/eth/allowances";
  LOOPRING_URLs["GET_ETH_NONCE"] = "/api/v3/eth/nonce";
  LOOPRING_URLs["GET_ETH_BALANCES"] = "/api/v3/eth/balances";
  LOOPRING_URLs["GET_TOKEN_BALANCES"] = "/api/v3/eth/tokenBalances";
  LOOPRING_URLs["GET_AKK_TOKEN_BALANCES"] = "/api/v3/eth/tokenBalances/all";
  LOOPRING_URLs["GET_GAS_PRICE"] = "/api/v3/eth/recommendedGasPrice";
  LOOPRING_URLs["GET_GAS_PRICE_RANGE"] = "/api/v3/eth/recommendedGasPriceRange";
  LOOPRING_URLs["GET_RECOMENDED_MARKETS"] = "/api/v3/exchange/recommended";
  LOOPRING_URLs["GET_AMM_POOLS_CONF"] = "/api/v3/amm/pools";
  LOOPRING_URLs["GET_AMM_POOLS_SNAPSHOT"] = "/api/v3/amm/balance";
  LOOPRING_URLs["GET_AMM_POOLS_BALANCES"] = "/api/v3/amm/balances";
  LOOPRING_URLs["GET_AMM_POOL_STATS"] = "/api/v3/amm/poolsStats";
  LOOPRING_URLs["POST_JOIN_AMM_POOL"] = "/api/v3/amm/join";
  LOOPRING_URLs["POST_EXIT_AMM_POOL"] = "/api/v3/amm/exit";
  LOOPRING_URLs["GET_AMM_POOL_TXS"] = "/api/v3/amm/transactions";
  LOOPRING_URLs["GET_USER_AMM_POOL_TXS"] = "/api/v3/amm/user/transactions";
  LOOPRING_URLs["GET_AMM_POOL_TRADE_TXS"] = "/api/v3/amm/trades";
  LOOPRING_URLs["GET_AMM_ACTIVITY_RULES"] = "/api/v3/sidecar/activityRules";
  LOOPRING_URLs["GET_AMMPOOL_USER_REWARDS"] = "/api/v3/amm/user/rewards";
  LOOPRING_URLs["GET_AMMPOOL_REWARDS"] = "/api/v3/amm/rewards";
  LOOPRING_URLs["GET_AMMPOOL_GAME_RANK"] = "/api/v3/game/rank";
  LOOPRING_URLs["GET_AMMPOOL_GAME_USER_RANK"] = "/api/v3/game/user/rank";
  LOOPRING_URLs["GET_LIQUIDITY_MINING"] = "/api/v3/sidecar/liquidityMining";
  LOOPRING_URLs["GET_DELEGATE_GET_CODE"] = "/api/v3/delegator/getCode";
  LOOPRING_URLs["GET_DELEGATE_GET_IPFS"] = "/api/v3/delegator/ipfs";
  LOOPRING_URLs["GET_LIQUIDITY_MINING_USER_HISTORY"] = "/api/v3/sidecar/liquidityMiningUserHistory";
  LOOPRING_URLs["GET_PROTOCOL_PORTRAIT"] = "/api/v3/sidecar/ProtocolPortrait";
  LOOPRING_URLs["GET_AMM_ASSET_HISTORY"] = "/api/v3/amm/assets";
  LOOPRING_URLs["GET_ASSET_LOCK_RECORDS"] = "api/v3/user/lockRecords";
  LOOPRING_URLs["GET_DEFI_TOKENS"] = "/api/v3/defi/tokens";
  LOOPRING_URLs["GET_DEFI_MARKETS"] = "/api/v3/defi/markets";
  LOOPRING_URLs["POST_DEFI_ORDER"] = "/api/v3/defi/order";
  LOOPRING_URLs["GET_DEFI_REWARDS"] = "/api/v3/defi/rewards";
  LOOPRING_URLs["GET_DEFI_TRANSACTIONS"] = "/api/v3/defi/transactions";
  LOOPRING_URLs["SET_REFERRER"] = "/api/v3/refer";
  LOOPRING_URLs["GET_WS_KEY"] = "/v3/ws/key";
  LOOPRING_URLs["GET_LATEST_TOKEN_PRICES"] = "/api/v3/datacenter/getLatestTokenPrices";
  LOOPRING_URLs["GET_USER_TRADE_AMOUNT"] = "/api/v3/datacenter/getUserTradeAmount";
  LOOPRING_URLs["GET_USER_ASSETS"] = "/api/wallet/v3/userAssets";
  LOOPRING_URLs["GET_TOKEN_PRICES"] = "/api/wallet/v3/tokenPrices";
  LOOPRING_URLs["GET_GUARDIAN_APPROVE_LIST"] = "/api/wallet/v3/getGuardianApproveList";
  LOOPRING_URLs["GET_PROTECTORS"] = "/api/wallet/v3/getProtects";
  LOOPRING_URLs["GET_OPERATION_LOGS"] = "/api/wallet/v3/operationLogs";
  LOOPRING_URLs["GET_HEBAO_CONFIG"] = "/api/wallet/v3/getAppConfigs";
  LOOPRING_URLs["GET_WALLET_TYPE"] = "/api/wallet/v3/wallet/type";
  LOOPRING_URLs["GET_WALLET_MODULES"] = "/api/wallet/v3/walletModules";
  LOOPRING_URLs["GET_WALLET_CONTRACTVERSION"] = "/api/wallet/v3/contractVersion";
  LOOPRING_URLs["RESOLVE_ENS"] = "/api/wallet/v3/resolveEns";
  LOOPRING_URLs["RESOLVE_NAME"] = "/api/wallet/v3/resolveName"; //

  LOOPRING_URLs["SUBMIT_APPROVE_SIGNATURE"] = "/api/wallet/v3/submitApproveSignature";
  LOOPRING_URLs["REJECT_APPROVE_SIGNATURE"] = "/api/wallet/v3/rejectApproveSignature"; // OFFICIAL_LOCK_OR_UNLOCK = "/api/wallet/v3/officialLockOrUnlock",

  LOOPRING_URLs["SEND_META_TX"] = "/api/wallet/v3/sendMetaTx";
  LOOPRING_URLs["GET_ACCOUNT_SERVICES"] = "/api/v3/spi/getAccountServices"; // VIP

  LOOPRING_URLs["GET_USER_VIP_INFO"] = "/api/v3/user/vipInfo";
  LOOPRING_URLs["GET_USER_VIP_ASSETS"] = "/api/v3/datacenter/getUserAssets";
  LOOPRING_URLs["GET_USER_NFT_BALANCES"] = "/api/v3/user/nft/balances";
  LOOPRING_URLs["GET_USER_NFT_BALANCES_BY_COLLECTION"] = "/api/v3/user/nft/collection/balances";
  LOOPRING_URLs["GET_NFT_OFFCHAIN_FEE_AMT"] = "/api/v3/user/nft/offchainFee";
  LOOPRING_URLs["POST_NFT_INTERNAL_TRANSFER"] = "/api/v3/nft/transfer";
  LOOPRING_URLs["POST_NFT_WITHDRAWALS"] = "/api/v3/nft/withdrawal";
  LOOPRING_URLs["POST_NFT_MINT"] = "/api/v3/nft/mint";
  LOOPRING_URLs["POST_NFT_TRADE"] = "/api/v3/nft/trade";
  LOOPRING_URLs["POST_NFT_VALIDATE_ORDER"] = "/api/v3/nft/validateOrder";
  LOOPRING_URLs["POST_NFT_EDIT_COLLECTION"] = "/api/v3/nft/collection/edit";
  LOOPRING_URLs["POST_NFT_CREATE_LEGACY_COLLECTION"] = "/api/v3/nft/collection/legacy/tokenAddress";
  LOOPRING_URLs["POST_NFT_VALIDATE_REFRESH_NFT"] = "/api/v3/nft/image/refresh";
  LOOPRING_URLs["POST_DEPLOY_COLLECTION"] = "/api/v3/collection/deployTokenAddress";
  LOOPRING_URLs["POST_NFT_LEGACY_UPDATE_COLLECTION"] = "/api/v3/nft/collection/legacy/updateNftCollection";
  LOOPRING_URLs["POST_NFT_UPDATE_NFT_GROUP"] = "/api/v3/user/nft/updateNftPreference";
  LOOPRING_URLs["GET_NFT_COLLECTION"] = "/api/v3/nft/collection";
  LOOPRING_URLs["POST_NFT_CREATE_COLLECTION"] = "/api/v3/nft/collection";
  LOOPRING_URLs["DELETE_NFT_CREATE_COLLECTION"] = "/api/v3/nft/collection";
  LOOPRING_URLs["GET_COLLECTION_WHOLE_NFTS"] = "/api/v3/nft/public/collection/items";
  LOOPRING_URLs["GET_NFT_COLLECTION_PUBLISH"] = "/api/v3/nft/public/collection";
  LOOPRING_URLs["GET_NFT_COLLECTION_HASNFT"] = "/api/v3/user/collection/details";
  LOOPRING_URLs["GET_NFT_LEGACY_COLLECTION"] = "/api/v3/nft/collection/legacy";
  LOOPRING_URLs["GET_NFT_LEGACY_TOKENADDRESS"] = "/api/v3/nft/collection/legacy/tokenAddress";
  LOOPRING_URLs["GET_NFT_LEGACY_BALANCE"] = "/api/v3/nft/collection/legacy/balance";
  LOOPRING_URLs["GET_NFTs_INFO"] = "/api/v3/nft/info/nfts";
  LOOPRING_URLs["GET_USER_NFT_TRANSFER_HISTORY"] = "/api/v3/user/nft/transfers";
  LOOPRING_URLs["GET_USER_NFT_DEPOSIT_HISTORY"] = "/api/v3/user/nft/deposits";
  LOOPRING_URLs["GET_USER_NFT_WITHDRAW_HISTORY"] = "/api/v3/user/nft/withdrawals";
  LOOPRING_URLs["GET_USER_NFT_TRANSACTION_HISTORY"] = "/api/v3/user/nft/transactions";
  LOOPRING_URLs["GET_USER_NFT_TRADE_HISTORY_OLD"] = "/api/v3/user/nft/trades";
  LOOPRING_URLs["GET_USER_NFT_TRADE_HISTORY"] = "/api/v3/new/user/nft/trades";
  LOOPRING_URLs["GET_USER_NFT_MINT_HISTORY"] = "/api/v3/user/nft/mints";
  LOOPRING_URLs["GET_DEPLOY_TOKEN_ADDRESS"] = "/api/v3/nft/deployTokenAddress";
  LOOPRING_URLs["IPFS_META_URL"] = "https://ipfs.loopring.io/ipfs/";
  LOOPRING_URLs["GET_DUAL_INDEX"] = "/api/v3/dual/index";
  LOOPRING_URLs["GET_DUAL_PRICES"] = "/api/v3/dual/prices";
  LOOPRING_URLs["GET_DUAL_INFOS"] = "/api/v3/dual/infos";
  LOOPRING_URLs["GET_DUAL_TRANSACTIONS"] = "/api/v3/dual/transactions";
  LOOPRING_URLs["GET_DUAL_BALANCE"] = "/api/v3/dual/balance";
  LOOPRING_URLs["GET_DUAL_RULE"] = "/api/v3/dual/rules";
  LOOPRING_URLs["POST_DUAL_ORDER"] = "/api/v3/dual/order";
  LOOPRING_URLs["GET_DUAL_USER_LOCKED"] = "/api/v3/dual/lockRecordAmount";
  LOOPRING_URLs["GET_LUCK_TOKEN_AGENTS"] = "/api/v3/luckyToken/agents";
  LOOPRING_URLs["GET_LUCK_TOKEN_AUTHORIZEDSIGNERS"] = "/api/v3/luckyToken/authorizedSigners";
  LOOPRING_URLs["GET_LUCK_TOKEN_CLAIMHISTORY"] = "/api/v3/luckyToken/user/claimHistory";
  LOOPRING_URLs["GET_LUCK_TOKEN_LUCKYTOKENS"] = "/api/v3/luckyToken/user/luckyTokens";
  LOOPRING_URLs["GET_LUCK_TOKEN_LUCKYTOKENDETAIL"] = "/api/v3/luckyToken/user/luckyTokenDetail";
  LOOPRING_URLs["GET_LUCK_TOKEN_BLINDBOXDETAIL"] = "/api/v3/luckyToken/user/blindBoxDetail";
  LOOPRING_URLs["GET_LUCK_TOKEN_WITHDRAWALS"] = "/api/v3/luckyToken/user/withdraws ";
  LOOPRING_URLs["GET_LUCK_TOKEN_BALANCES"] = "/api/v3/luckyToken/user/balances";
  LOOPRING_URLs["GET_LUCK_TOKEN_CLAIMEDLUCKYTOKENS"] = "/api/v3/luckyToken/user/claimedLuckyTokens";
  LOOPRING_URLs["GET_LUCK_TOKEN_CLAIMEDBLINDBOX"] = "/api/v3/luckyToken/user/claimBlindBoxHistory";
  LOOPRING_URLs["GET_LUCK_TOKEN_SUMMARY"] = "/api/v3/luckyToken/user/summary";
  LOOPRING_URLs["POST_LUCK_TOKEN_SENDLUCKYTOKEN"] = "/api/v3/luckyToken/sendLuckyToken";
  LOOPRING_URLs["POST_LUCK_TOKEN_CLAIMLUCKYTOKEN"] = "/api/v3/luckyToken/claimLuckyToken";
  LOOPRING_URLs["POST_LUCK_TOKEN_CLAIMBLINDBOX"] = "/api/v3/luckyToken/claimBlindBox";
  LOOPRING_URLs["POST_LUCK_TOKEN_WITHDRAWALS"] = "/api/v3/luckyToken/user/withdrawals";
  LOOPRING_URLs["GET_BANXA_API_KEY"] = "/api/v3/hmacAuthentication";
  LOOPRING_URLs["GET_STAKE_PRODUCTS"] = "/api/v3/stake/products";
  LOOPRING_URLs["POST_STAKE_CLAIM"] = "/api/v3/stake/claim";
  LOOPRING_URLs["POST_STAKE"] = "/api/v3/stake/stake";
  LOOPRING_URLs["POST_STAKE_REDEEM"] = "/api/v3/stake/redeem";
  LOOPRING_URLs["GET_STAKE_SUMMARY"] = "/api/v3/stake/user/summary";
  LOOPRING_URLs["GET_STAKE_TRANSACTIONS"] = "/api/v3/stake/user/transactions"; // Contacts

  LOOPRING_URLs["GET_CONTACTS"] = "/api/v3/user/contact";
  LOOPRING_URLs["CREATE_CONTACT"] = "/api/v3/user/contact/add";
  LOOPRING_URLs["UPDATE_CONTACT"] = "/api/v3/user/contact/update";
  LOOPRING_URLs["DELETE_CONTACT"] = "/api/v3/user/contact"; // CEFI_MARKETS

  LOOPRING_URLs["GET_CEFI_MARKETS"] = "api/v3/cefi/markets";
  LOOPRING_URLs["GET_CEFI_DEPTH"] = "api/v3/cefi/depth";
  LOOPRING_URLs["GET_CEFI_ORDERS"] = "api/v3/cefi/orders";
  LOOPRING_URLs["POST_CEFI_ORDER"] = "api/v3/cefi/order";
})(exports.LOOPRING_URLs || (exports.LOOPRING_URLs = {}));

(function (HEBAO_LOCK_STATUS) {
  HEBAO_LOCK_STATUS["LOCK_FAILED"] = "LOCK_FAILED";
  HEBAO_LOCK_STATUS["CREATED"] = "CREATED";
  HEBAO_LOCK_STATUS["LOCK_WAITING"] = "LOCK_WAITING";
  HEBAO_LOCK_STATUS["UNLOCK_FAILED"] = "UNLOCK_FAILED";
  HEBAO_LOCK_STATUS["LOCKED"] = "LOCKED";
  HEBAO_LOCK_STATUS["UNLOCK_WAITING"] = "UNLOCK_WAITING";
})(exports.HEBAO_LOCK_STATUS || (exports.HEBAO_LOCK_STATUS = {}));

(function (HEBAO_META_TYPE) {
  HEBAO_META_TYPE[HEBAO_META_TYPE["recovery"] = 16] = "recovery";
  HEBAO_META_TYPE[HEBAO_META_TYPE["transfer"] = 18] = "transfer";
  HEBAO_META_TYPE[HEBAO_META_TYPE["add_guardian"] = 34] = "add_guardian";
  HEBAO_META_TYPE[HEBAO_META_TYPE["remove_guardian"] = 35] = "remove_guardian";
  HEBAO_META_TYPE[HEBAO_META_TYPE["unlock_wallet"] = 37] = "unlock_wallet";
  HEBAO_META_TYPE[HEBAO_META_TYPE["deposit_wallet"] = 202] = "deposit_wallet";
})(exports.HEBAO_META_TYPE || (exports.HEBAO_META_TYPE = {}));

var SoursURL = "https://static.loopring.io/assets/";

(function (ReqMethod) {
  ReqMethod["GET"] = "GET";
  ReqMethod["POST"] = "POST";
  ReqMethod["DELETE"] = "DELETE";
})(exports.ReqMethod || (exports.ReqMethod = {}));

(function (SigPatchField) {
  SigPatchField["EddsaSignature"] = "eddsaSignature";
})(exports.SigPatchField || (exports.SigPatchField = {}));

(function (MarketStatus) {
  MarketStatus[MarketStatus["AMM"] = 1] = "AMM";
  MarketStatus[MarketStatus["ORDER_BOOK"] = 2] = "ORDER_BOOK";
  MarketStatus[MarketStatus["ALL"] = 3] = "ALL";
})(exports.MarketStatus || (exports.MarketStatus = {}));

(function (VipCatergory) {
  VipCatergory["ORDERBOOK_TRADING_FEES_STABLECOIN"] = "ORDERBOOK_TRADING_FEES_STABLECOIN";
  VipCatergory["ORDERBOOK_TRADING_FEES"] = "ORDERBOOK_TRADING_FEES";
  VipCatergory["AMM_TRADING_FEES"] = "AMM_TRADING_FEES";
  VipCatergory["OTHER_FEES"] = "OTHER_FEES";
})(exports.VipCatergory || (exports.VipCatergory = {}));

(function (TradeChannel) {
  TradeChannel["BLANK"] = "";
  TradeChannel["ORDER_BOOK"] = "ORDER_BOOK";
  TradeChannel["AMM_POOL"] = "AMM_POOL";
  TradeChannel["MIXED"] = "MIXED";
})(exports.TradeChannel || (exports.TradeChannel = {}));

(function (OrderType) {
  OrderType["LimitOrder"] = "LIMIT_ORDER";
  OrderType["TakerOnly"] = "TAKER_ONLY";
  OrderType["MakerOnly"] = "MAKER_ONLY";
  OrderType["ClassAmm"] = "AMM";
})(exports.OrderType || (exports.OrderType = {}));

(function (OrderTypeResp) {
  OrderTypeResp["LimitOrder"] = "LIMIT_ORDER";
  OrderTypeResp["TakerOnly"] = "TAKER_ONLY";
  OrderTypeResp["MakerOnly"] = "MAKER_ONLY";
  OrderTypeResp["ClassAmm"] = "CLASS_AMM";
})(exports.OrderTypeResp || (exports.OrderTypeResp = {}));

(function (Currency) {
  Currency["usd"] = "usd";
  Currency["cny"] = "cny";
})(exports.Currency || (exports.Currency = {}));

(function (OffchainFeeReqType) {
  OffchainFeeReqType[OffchainFeeReqType["ORDER"] = 0] = "ORDER";
  OffchainFeeReqType[OffchainFeeReqType["OFFCHAIN_WITHDRAWAL"] = 1] = "OFFCHAIN_WITHDRAWAL";
  OffchainFeeReqType[OffchainFeeReqType["UPDATE_ACCOUNT"] = 2] = "UPDATE_ACCOUNT";
  OffchainFeeReqType[OffchainFeeReqType["TRANSFER"] = 3] = "TRANSFER";
  OffchainFeeReqType[OffchainFeeReqType["FAST_OFFCHAIN_WITHDRAWAL"] = 4] = "FAST_OFFCHAIN_WITHDRAWAL";
  OffchainFeeReqType[OffchainFeeReqType["OPEN_ACCOUNT"] = 5] = "OPEN_ACCOUNT";
  OffchainFeeReqType[OffchainFeeReqType["AMM_EXIT"] = 6] = "AMM_EXIT";
  OffchainFeeReqType[OffchainFeeReqType["DEPOSIT"] = 7] = "DEPOSIT";
  OffchainFeeReqType[OffchainFeeReqType["AMM_JOIN"] = 8] = "AMM_JOIN";
  OffchainFeeReqType[OffchainFeeReqType["TRANSFER_AND_UPDATE_ACCOUNT"] = 15] = "TRANSFER_AND_UPDATE_ACCOUNT";
  OffchainFeeReqType[OffchainFeeReqType["DEFI_JOIN"] = 21] = "DEFI_JOIN";
  OffchainFeeReqType[OffchainFeeReqType["DEFI_EXIT"] = 22] = "DEFI_EXIT";
  OffchainFeeReqType[OffchainFeeReqType["FORCE_WITHDRAWAL"] = 23] = "FORCE_WITHDRAWAL";
})(exports.OffchainFeeReqType || (exports.OffchainFeeReqType = {}));

(function (OffchainNFTFeeReqType) {
  OffchainNFTFeeReqType[OffchainNFTFeeReqType["NFT_MINT"] = 9] = "NFT_MINT";
  OffchainNFTFeeReqType[OffchainNFTFeeReqType["NFT_WITHDRAWAL"] = 10] = "NFT_WITHDRAWAL";
  OffchainNFTFeeReqType[OffchainNFTFeeReqType["NFT_TRANSFER"] = 11] = "NFT_TRANSFER";
  OffchainNFTFeeReqType[OffchainNFTFeeReqType["NFT_DEPLOY"] = 13] = "NFT_DEPLOY";
  OffchainNFTFeeReqType[OffchainNFTFeeReqType["NFT_TRANSFER_AND_UPDATE_ACCOUNT"] = 19] = "NFT_TRANSFER_AND_UPDATE_ACCOUNT";
})(exports.OffchainNFTFeeReqType || (exports.OffchainNFTFeeReqType = {}));

(function (TradingInterval) {
  TradingInterval["min1"] = "1min";
  TradingInterval["min5"] = "5min";
  TradingInterval["min15"] = "15min";
  TradingInterval["min30"] = "30min";
  TradingInterval["hr1"] = "1hr";
  TradingInterval["hr2"] = "2hr";
  TradingInterval["hr4"] = "4hr";
  TradingInterval["hr12"] = "12hr";
  TradingInterval["d1"] = "1d";
  TradingInterval["w1"] = "1w";
})(exports.TradingInterval || (exports.TradingInterval = {}));

(function (TxStatus) {
  TxStatus["processing"] = "processing";
  TxStatus["processed"] = "processed";
  TxStatus["received"] = "received";
  TxStatus["failed"] = "failed";
})(exports.TxStatus || (exports.TxStatus = {}));

(function (OrderStatus) {
  OrderStatus["processing"] = "processing";
  OrderStatus["processed"] = "processed";
  OrderStatus["failed"] = "failed";
  OrderStatus["cancelled"] = "cancelled";
  OrderStatus["cancelling"] = "cancelling";
  OrderStatus["expired"] = "expired";
})(exports.OrderStatus || (exports.OrderStatus = {}));

(function (Side) {
  Side["Buy"] = "BUY";
  Side["Sell"] = "SELL";
})(exports.Side || (exports.Side = {}));

(function (WithdrawalTypes) {
  WithdrawalTypes["OFFCHAIN_WITHDRAWAL"] = "OFFCHAIN_WITHDRAWAL";
  WithdrawalTypes["ONCHAIN_WITHDRAWAL"] = "ONCHAIN_WITHDRAWAL";
  WithdrawalTypes["FORCE_WITHDRAWAL"] = "FORCE_WITHDRAWAL";
})(exports.WithdrawalTypes || (exports.WithdrawalTypes = {}));

(function (UserTxTypes) {
  UserTxTypes["DEPOSIT"] = "deposit";
  UserTxTypes["TRANSFER"] = "transfer";
  UserTxTypes["OFFCHAIN_WITHDRAWAL"] = "offchain_withdrawal";
  UserTxTypes["FORCE_WITHDRAWAL"] = "force_withdrawal";
  UserTxTypes["DELEGATED_FORCE_WITHDRAW"] = "delegated_force_withdraw";
  UserTxTypes["SEND_LUCKY_TOKEN"] = "send_lucky_token";
  UserTxTypes["WITHDRAW_LUCKY_TOKEN"] = "withdraw_lucky_token";
  UserTxTypes["WITHDRAW"] = "onchain_withdrawal";
  UserTxTypes["SEND_BACK_LUCKY_TOKEN"] = "send_back_lucky_token";
  UserTxTypes["DUAL_INVESTMENT"] = "dual_investment";
  UserTxTypes["L2_STAKING"] = "l2_staking";
})(exports.UserTxTypes || (exports.UserTxTypes = {}));

(function (UserBillTypes) {
  UserBillTypes[UserBillTypes["DEPOSIT"] = 0] = "DEPOSIT";
  UserBillTypes[UserBillTypes["ONCHAIN_WITHDRAWAL"] = 1] = "ONCHAIN_WITHDRAWAL";
  UserBillTypes[UserBillTypes["TRANSFER"] = 2] = "TRANSFER";
})(exports.UserBillTypes || (exports.UserBillTypes = {}));

(function (UserNFTTxTypes) {
  UserNFTTxTypes["DEPOSIT"] = "deposit";
  UserNFTTxTypes["TRANSFER"] = "transfer";
  UserNFTTxTypes["WITHDRAW"] = "onchain_withdrawal";
  UserNFTTxTypes["MINT"] = "mint";
})(exports.UserNFTTxTypes || (exports.UserNFTTxTypes = {}));

(function (TransferType) {
  TransferType["transfer"] = "transfer";
  TransferType["transfer_red"] = "transfer_red";
})(exports.TransferType || (exports.TransferType = {}));

(function (BillType) {
  BillType["ORDER"] = "order";
  BillType["DEPOSIT"] = "deposit";
  BillType["ONCHAIN_WITHDRAWAL"] = "onchain_withdrawal";
  BillType["OFFCHAIN_WITHDRAWAL"] = "offchain_withdrawal";
  BillType["TRANSFER"] = "transfer";
  BillType["TRANSFER_RED"] = "transfer_red";
})(exports.BillType || (exports.BillType = {}));

(function (FilledType) {
  FilledType["dex"] = "dex";
  FilledType["amm"] = "amm";
})(exports.FilledType || (exports.FilledType = {}));

(function (TxType) {
  TxType["TRANSFER"] = "TRANSFER";
  TxType["DEPOSIT"] = "DEPOSIT";
  TxType["OFFCHAIN_WITHDRAWAL"] = "OFFCHAIN_WITHDRAWAL";
})(exports.TxType || (exports.TxType = {}));

(function (TxNFTType) {
  TxNFTType["TRANSFER"] = "TRANSFER";
  TxNFTType["DEPOSIT"] = "DEPOSIT";
  TxNFTType["WITHDRAW"] = "WITHDRAW";
  TxNFTType["ALL"] = "ALL";
  TxNFTType["MINT"] = "MINT";
})(exports.TxNFTType || (exports.TxNFTType = {}));

(function (AmmTxType) {
  AmmTxType["JOIN"] = "AMM_JOIN";
  AmmTxType["EXIT"] = "AMM_EXIT";
})(exports.AmmTxType || (exports.AmmTxType = {}));

(function (SortOrder) {
  SortOrder[SortOrder["ASC"] = 0] = "ASC";
  SortOrder[SortOrder["DESC"] = 1] = "DESC";
})(exports.SortOrder || (exports.SortOrder = {}));

(function (RuleType) {
  RuleType["AMM_MINING"] = "AMM_MINING";
  RuleType["SWAP_VOLUME_RANKING"] = "SWAP_VOLUME_RANKING";
  RuleType["ORDERBOOK_MINING"] = "ORDERBOOK_MINING";
})(exports.RuleType || (exports.RuleType = {}));

(function (AmmPoolActivityStatus) {
  AmmPoolActivityStatus["NotStarted"] = "NotStarted";
  AmmPoolActivityStatus["InProgress"] = "InProgress";
  AmmPoolActivityStatus["EndOfGame"] = "EndOfGame";
})(exports.AmmPoolActivityStatus || (exports.AmmPoolActivityStatus = {}));

(function (SIG_FLAG) {
  SIG_FLAG[SIG_FLAG["NO_SIG"] = 0] = "NO_SIG";
  SIG_FLAG[SIG_FLAG["EDDSA_SIG"] = 1] = "EDDSA_SIG";
  SIG_FLAG[SIG_FLAG["EDDSA_SIG_POSEIDON"] = 2] = "EDDSA_SIG_POSEIDON";
})(exports.SIG_FLAG || (exports.SIG_FLAG = {}));

(function (AssetType) {
  AssetType[AssetType["LEVEL_ONE"] = 0] = "LEVEL_ONE";
  AssetType[AssetType["DEX"] = 1] = "DEX";
})(exports.AssetType || (exports.AssetType = {}));

(function (IntervalType) {
  IntervalType[IntervalType["HOUR"] = 0] = "HOUR";
  IntervalType[IntervalType["DAY"] = 1] = "DAY";
})(exports.IntervalType || (exports.IntervalType = {}));

(function (NetworkWallet) {
  NetworkWallet["ETHEREUM"] = "ETHEREUM";
  NetworkWallet["ARBITRUM"] = "ARBITRUM";
  NetworkWallet["GOERLI"] = "GOERLI";
  NetworkWallet["TAIKO"] = "TAIKO";
})(exports.NetworkWallet || (exports.NetworkWallet = {}));

(function (DefiMarketStatus) {
  DefiMarketStatus[DefiMarketStatus["hide"] = 0] = "hide";
  DefiMarketStatus[DefiMarketStatus["show"] = 1] = "show";
  DefiMarketStatus[DefiMarketStatus["depositOnly"] = 3] = "depositOnly";
  DefiMarketStatus[DefiMarketStatus["depositAll"] = 7] = "depositAll";
  DefiMarketStatus[DefiMarketStatus["withdrawOnly"] = 9] = "withdrawOnly";
  DefiMarketStatus[DefiMarketStatus["depositAllAndWithdraw"] = 15] = "depositAllAndWithdraw";
  DefiMarketStatus[DefiMarketStatus["withdrawAll"] = 25] = "withdrawAll";
  DefiMarketStatus[DefiMarketStatus["WithdrawAllAndDeposit"] = 27] = "WithdrawAllAndDeposit";
  DefiMarketStatus[DefiMarketStatus["depositAndWithdraw"] = 11] = "depositAndWithdraw";
  DefiMarketStatus[DefiMarketStatus["all"] = 31] = "all";
})(exports.DefiMarketStatus || (exports.DefiMarketStatus = {}));

(function (AMMtxTypes) {
  AMMtxTypes[AMMtxTypes["JOIN"] = 0] = "JOIN";
  AMMtxTypes[AMMtxTypes["EXIT"] = 1] = "EXIT";
})(exports.AMMtxTypes || (exports.AMMtxTypes = {}));

(function (OrderMakerType) {
  OrderMakerType["taker"] = "taker";
  OrderMakerType["maker"] = "maker";
})(exports.OrderMakerType || (exports.OrderMakerType = {}));

(function (TradesFillTypes) {
  TradesFillTypes["dex"] = "dex";
  TradesFillTypes["amm"] = "amm";
})(exports.TradesFillTypes || (exports.TradesFillTypes = {}));

(function (LegacyNFT) {
  LegacyNFT["inside"] = "inside";
  LegacyNFT["outside"] = "outside";
  LegacyNFT["undecided"] = "undecided";
})(exports.LegacyNFT || (exports.LegacyNFT = {}));

(function (DEPLOYMENT_STATUS) {
  DEPLOYMENT_STATUS["NOT_DEPLOYED"] = "NOT_DEPLOYED";
  DEPLOYMENT_STATUS["DEPLOY_FAILED"] = "DEPLOY_FAILED";
  DEPLOYMENT_STATUS["DEPLOYING"] = "DEPLOYING";
  DEPLOYMENT_STATUS["DEPLOYED"] = "DEPLOYED";
})(exports.DEPLOYMENT_STATUS || (exports.DEPLOYMENT_STATUS = {}));

(function (NFT_IMAGE_SIZES) {
  NFT_IMAGE_SIZES["small"] = "240-240";
  NFT_IMAGE_SIZES["large"] = "332-332";
  NFT_IMAGE_SIZES["original"] = "original";
})(exports.NFT_IMAGE_SIZES || (exports.NFT_IMAGE_SIZES = {}));

var SEP = ",";

(function (DefiAction) {
  DefiAction["Deposit"] = "deposit";
  DefiAction["Withdraw"] = "withdraw";
})(exports.DefiAction || (exports.DefiAction = {}));

(function (NFT_PREFERENCE_TYPE) {
  NFT_PREFERENCE_TYPE["fav"] = "fav";
  NFT_PREFERENCE_TYPE["hide"] = "hide";
})(exports.NFT_PREFERENCE_TYPE || (exports.NFT_PREFERENCE_TYPE = {}));

(function (DUAL_TYPE) {
  DUAL_TYPE["DUAL_BASE"] = "DUAL_BASE";
  DUAL_TYPE["DUAL_CURRENCY"] = "DUAL_CURRENCY";
})(exports.DUAL_TYPE || (exports.DUAL_TYPE = {}));

(function (LABEL_INVESTMENT_STATUS) {
  // INVESTMENT_SUCCEEDED = "INVESTMENT_SUCCEEDED",
  // INVESTMENT_FAILED = "INVESTMENT_FAILED",
  // INVESTMENT_RECEIVED = "INVESTMENT_RECEIVED",
  LABEL_INVESTMENT_STATUS["PROCESSED"] = "processed";
  LABEL_INVESTMENT_STATUS["FAILED"] = "failed";
  LABEL_INVESTMENT_STATUS["PROCESSING"] = "processing";
  LABEL_INVESTMENT_STATUS["CANCELLED"] = "cancelled";
})(exports.LABEL_INVESTMENT_STATUS || (exports.LABEL_INVESTMENT_STATUS = {}));

(function (SETTLEMENT_STATUS) {
  SETTLEMENT_STATUS["UNSETTLED"] = "UNSETTLED";
  SETTLEMENT_STATUS["SETTLED"] = "SETTLED";
  SETTLEMENT_STATUS["PAID"] = "PAID";
})(exports.SETTLEMENT_STATUS || (exports.SETTLEMENT_STATUS = {}));

(function (LuckyTokenItemStatusIndex) {
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["SUBMITTING"] = 0] = "SUBMITTING";
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["NOT_EFFECTIVE"] = 1] = "NOT_EFFECTIVE";
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["PENDING"] = 2] = "PENDING";
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["COMPLETED"] = 3] = "COMPLETED";
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["OVER_DUE"] = 4] = "OVER_DUE";
  LuckyTokenItemStatusIndex[LuckyTokenItemStatusIndex["FAILED"] = 5] = "FAILED";
})(exports.LuckyTokenItemStatusIndex || (exports.LuckyTokenItemStatusIndex = {}));

(function (LuckyTokenWithdrawStatus) {
  LuckyTokenWithdrawStatus[LuckyTokenWithdrawStatus["RECEIVED"] = 0] = "RECEIVED";
  LuckyTokenWithdrawStatus[LuckyTokenWithdrawStatus["PROCESSING"] = 1] = "PROCESSING";
  LuckyTokenWithdrawStatus[LuckyTokenWithdrawStatus["PROCESSED"] = 2] = "PROCESSED";
  LuckyTokenWithdrawStatus[LuckyTokenWithdrawStatus["WITHDRAW_FAILED"] = 3] = "WITHDRAW_FAILED";
  LuckyTokenWithdrawStatus[LuckyTokenWithdrawStatus["PREPARE_FAILED"] = 4] = "PREPARE_FAILED";
})(exports.LuckyTokenWithdrawStatus || (exports.LuckyTokenWithdrawStatus = {}));

(function (LuckyTokenItemStatus) {
  LuckyTokenItemStatus["SUBMITTING"] = "SUBMITTING";
  LuckyTokenItemStatus["NOT_EFFECTIVE"] = "NOT_EFFECTIVE";
  LuckyTokenItemStatus["PENDING"] = "PENDING";
  LuckyTokenItemStatus["COMPLETED"] = "COMPLETED";
  LuckyTokenItemStatus["OVER_DUE"] = "OVER_DUE";
  LuckyTokenItemStatus["FAILED"] = "FAILED";
})(exports.LuckyTokenItemStatus || (exports.LuckyTokenItemStatus = {}));

(function (LuckyTokenAmountType) {
  LuckyTokenAmountType[LuckyTokenAmountType["RANDOM"] = 0] = "RANDOM";
  LuckyTokenAmountType[LuckyTokenAmountType["AVERAGE"] = 1] = "AVERAGE";
})(exports.LuckyTokenAmountType || (exports.LuckyTokenAmountType = {}));

(function (LuckyTokenViewType) {
  LuckyTokenViewType[LuckyTokenViewType["PUBLIC"] = 0] = "PUBLIC";
  LuckyTokenViewType[LuckyTokenViewType["PRIVATE"] = 1] = "PRIVATE";
})(exports.LuckyTokenViewType || (exports.LuckyTokenViewType = {}));

(function (LuckyTokenClaimType) {
  LuckyTokenClaimType[LuckyTokenClaimType["RELAY"] = 0] = "RELAY";
  LuckyTokenClaimType[LuckyTokenClaimType["COMMON"] = 1] = "COMMON";
  LuckyTokenClaimType[LuckyTokenClaimType["BLIND_BOX"] = 2] = "BLIND_BOX";
})(exports.LuckyTokenClaimType || (exports.LuckyTokenClaimType = {}));

(function (ClaimRecordStatus) {
  ClaimRecordStatus["WAITING_CLAIM"] = "WAITING_CLAIM";
  ClaimRecordStatus["CLAIMED"] = "CLAIMED";
  ClaimRecordStatus["EXPIRED"] = "EXPIRED";
})(exports.ClaimRecordStatus || (exports.ClaimRecordStatus = {}));

(function (BlindBoxStatus) {
  BlindBoxStatus["NOT_OPENED"] = "NOT_OPENED";
  BlindBoxStatus["OPENED"] = "OPENED";
  BlindBoxStatus["EXPIRED"] = "EXPIRED";
})(exports.BlindBoxStatus || (exports.BlindBoxStatus = {}));

(function (StakeStatus) {
  StakeStatus["received"] = "received";
  StakeStatus["locked"] = "locked";
  StakeStatus["partial_unlocked"] = "partial_unlocked";
  StakeStatus["completely_unlocked"] = "completely_unlocked";
  StakeStatus["failed"] = "failed";
})(exports.StakeStatus || (exports.StakeStatus = {}));

(function (StakeTransactionType) {
  StakeTransactionType["subscribe"] = "subscribe";
  StakeTransactionType["redeem"] = "redeem";
  StakeTransactionType["claim"] = "claim";
})(exports.StakeTransactionType || (exports.StakeTransactionType = {}));

(function (AddressType) {
  AddressType[AddressType["UNKNOWN_ADDRESS"] = 0] = "UNKNOWN_ADDRESS";
  AddressType[AddressType["LOOPRING_HEBAO_CF"] = 100] = "LOOPRING_HEBAO_CF"; // hebao

  AddressType[AddressType["LOOPRING_HEBAO_CONTRACT_1_1_6"] = 2000] = "LOOPRING_HEBAO_CONTRACT_1_1_6";
  AddressType[AddressType["LOOPRING_HEBAO_CONTRACT_1_2_0"] = 2001] = "LOOPRING_HEBAO_CONTRACT_1_2_0";
  AddressType[AddressType["LOOPRING_HEBAO_CONTRACT_2_0_0"] = 2002] = "LOOPRING_HEBAO_CONTRACT_2_0_0";
  AddressType[AddressType["LOOPRING_HEBAO_CONTRACT_2_1_0"] = 2003] = "LOOPRING_HEBAO_CONTRACT_2_1_0";
  AddressType[AddressType["LOOPRING_DEX_EOA"] = 300] = "LOOPRING_DEX_EOA"; //exchange

  AddressType[AddressType["EXCHANGE_OTHER"] = 4000] = "EXCHANGE_OTHER";
  AddressType[AddressType["EXCHANGE_BINANCE"] = 4001] = "EXCHANGE_BINANCE";
  AddressType[AddressType["EXCHANGE_OKX"] = 4002] = "EXCHANGE_OKX";
  AddressType[AddressType["EXCHANGE_HUOBI"] = 4003] = "EXCHANGE_HUOBI";
  AddressType[AddressType["EXCHANGE_COINBASE"] = 4004] = "EXCHANGE_COINBASE";
  AddressType[AddressType["EOA"] = 5000] = "EOA";
  AddressType[AddressType["EOA_METAMASK"] = 5001] = "EOA_METAMASK";
  AddressType[AddressType["EOA_COINBASE"] = 5002] = "EOA_COINBASE";
  AddressType[AddressType["EOA_LEDGER"] = 5003] = "EOA_LEDGER";
  AddressType[AddressType["CONTRACT"] = 600] = "CONTRACT";
})(exports.AddressType || (exports.AddressType = {}));

(function (LoopringErrorCode) {
  LoopringErrorCode[LoopringErrorCode["Unknown_Error"] = 100000] = "Unknown_Error";
  LoopringErrorCode[LoopringErrorCode["Invalid_Args"] = 100001] = "Invalid_Args";
  LoopringErrorCode[LoopringErrorCode["Address_Not_Found"] = 101001] = "Address_Not_Found";
  LoopringErrorCode[LoopringErrorCode["User_Not_Found"] = 101002] = "User_Not_Found";
  LoopringErrorCode[LoopringErrorCode["ExchangeId_Incorrect"] = 102001] = "ExchangeId_Incorrect";
  LoopringErrorCode[LoopringErrorCode["Unsupported_TokenId"] = 102002] = "Unsupported_TokenId";
  LoopringErrorCode[LoopringErrorCode["Invalid_AccountId"] = 102003] = "Invalid_AccountId";
  LoopringErrorCode[LoopringErrorCode["Invalid_OrderId"] = 102004] = "Invalid_OrderId";
  LoopringErrorCode[LoopringErrorCode["Market_Not_Supported"] = 102005] = "Market_Not_Supported";
  LoopringErrorCode[LoopringErrorCode["Illegal_Rate"] = 102006] = "Illegal_Rate";
  LoopringErrorCode[LoopringErrorCode["Order_Already_Existed"] = 102007] = "Order_Already_Existed";
  LoopringErrorCode[LoopringErrorCode["Order_Already_Expired"] = 102008] = "Order_Already_Expired";
  LoopringErrorCode[LoopringErrorCode["Order_Missing_Sig"] = 102010] = "Order_Missing_Sig";
  LoopringErrorCode[LoopringErrorCode["Invalid_User_Balance"] = 102011] = "Invalid_User_Balance";
  LoopringErrorCode[LoopringErrorCode["Order_Amount_Too_Small"] = 102012] = "Order_Amount_Too_Small";
  LoopringErrorCode[LoopringErrorCode["Failed_To_Freeze_Amt"] = 102014] = "Failed_To_Freeze_Amt";
  LoopringErrorCode[LoopringErrorCode["Exceed_Max_Order_Amt"] = 102020] = "Exceed_Max_Order_Amt";
  LoopringErrorCode[LoopringErrorCode["Invalid_Nonce"] = 102021] = "Invalid_Nonce";
  LoopringErrorCode[LoopringErrorCode["Invalid_Transfer_Sender"] = 102022] = "Invalid_Transfer_Sender";
  LoopringErrorCode[LoopringErrorCode["Invalid_Transfer_Receiver"] = 102023] = "Invalid_Transfer_Receiver";
  LoopringErrorCode[LoopringErrorCode["Unsuported_Fee_Token"] = 102024] = "Unsuported_Fee_Token";
  LoopringErrorCode[LoopringErrorCode["Transfer_Token_Is_Not_Consistent_With_Fee_Token"] = 102025] = "Transfer_Token_Is_Not_Consistent_With_Fee_Token";
  LoopringErrorCode[LoopringErrorCode["Sumbit_Order_Failed"] = 102027] = "Sumbit_Order_Failed";
  LoopringErrorCode[LoopringErrorCode["No_Order_To_Cancel"] = 102117] = "No_Order_To_Cancel";
  LoopringErrorCode[LoopringErrorCode["Fail_To_Cancel_Order"] = 102118] = "Fail_To_Cancel_Order";
  LoopringErrorCode[LoopringErrorCode["Order_Is_Not_Valid"] = 102120] = "Order_Is_Not_Valid";
  LoopringErrorCode[LoopringErrorCode["Empty_Apikey"] = 104001] = "Empty_Apikey";
  LoopringErrorCode[LoopringErrorCode["Invalid_Apikey"] = 104002] = "Invalid_Apikey";
  LoopringErrorCode[LoopringErrorCode["Invalid_AccountID"] = 104003] = "Invalid_AccountID";
  LoopringErrorCode[LoopringErrorCode["No_Sig_Provided"] = 104004] = "No_Sig_Provided";
  LoopringErrorCode[LoopringErrorCode["Wrong_Sig"] = 104005] = "Wrong_Sig";
  LoopringErrorCode[LoopringErrorCode["User_Cannot_Be_Empty"] = 107001] = "User_Cannot_Be_Empty";
  LoopringErrorCode[LoopringErrorCode["Orderhash_Cannot_Be_Empty"] = 107002] = "Orderhash_Cannot_Be_Empty";
  LoopringErrorCode[LoopringErrorCode["Order_Not_Exist"] = 107003] = "Order_Not_Exist";
  LoopringErrorCode[LoopringErrorCode["Unsupported_Market"] = 108000] = "Unsupported_Market";
  LoopringErrorCode[LoopringErrorCode["Unsupported_Depth_Level"] = 108001] = "Unsupported_Depth_Level";
  LoopringErrorCode[LoopringErrorCode["SKD_UNKNOW"] = 500000] = "SKD_UNKNOW";
  LoopringErrorCode[LoopringErrorCode["CONTRACTNFT_URI"] = 500001] = "CONTRACTNFT_URI";
  LoopringErrorCode[LoopringErrorCode["CONTRACTNFT_BALANCE"] = 500002] = "CONTRACTNFT_BALANCE";
  LoopringErrorCode[LoopringErrorCode["CONTRACTNFT_IS_APPROVE"] = 500003] = "CONTRACTNFT_IS_APPROVE";
  LoopringErrorCode[LoopringErrorCode["CONTRACTNFT_SET_APPROVE"] = 500004] = "CONTRACTNFT_SET_APPROVE";
  LoopringErrorCode[LoopringErrorCode["NOT_SUPPORT_ERROR"] = 500005] = "NOT_SUPPORT_ERROR";
  LoopringErrorCode[LoopringErrorCode["USER_DENIED"] = 500006] = "USER_DENIED";
  LoopringErrorCode[LoopringErrorCode["USER_DENIED_2"] = 500007] = "USER_DENIED_2";
  LoopringErrorCode[LoopringErrorCode["NO_EDDSA_KEY"] = 500008] = "NO_EDDSA_KEY";
  LoopringErrorCode[LoopringErrorCode["HTTP_ERROR"] = 500009] = "HTTP_ERROR";
  LoopringErrorCode[LoopringErrorCode["CEX_NO_DEPTH_ERROR"] = 500010] = "CEX_NO_DEPTH_ERROR";
  LoopringErrorCode[LoopringErrorCode["CEX_NO_PRODUCT"] = 500011] = "CEX_NO_PRODUCT";
})(exports.LoopringErrorCode || (exports.LoopringErrorCode = {}));

(function (ConnectorError) {
  ConnectorError["NOT_SUPPORT_ERROR"] = "Not supported on this device";
  ConnectorError["USER_DENIED"] = "User denied message signature";
  ConnectorError["USER_DENIED_2"] = "personalSign err before Validate";
  ConnectorError["CONTRACTNFT_URI"] = "contract nft uri Error";
  ConnectorError["CONTRACTNFT_BALANCE"] = "contract nft balance error";
  ConnectorError["CONTRACTNFT_IS_APPROVE"] = "ContractNFT is Approve error";
  ConnectorError["CONTRACTNFT_SET_APPROVE"] = "ContractNFT set Approve error";
  ConnectorError["NO_EDDSA_KEY"] = "No EDDSA KEY";
  ConnectorError["HTTP_ERROR"] = "HTTP Request Failed!";
  ConnectorError["CEX_NO_DEPTH_ERROR"] = "NO Depth for CEX";
  ConnectorError["CEX_NO_PRODUCT"] = "NO Market for CEX";
})(exports.ConnectorError || (exports.ConnectorError = {}));

var checkErrorInfo = function checkErrorInfo(errorInfo, isFirstTime) {
  var message = errorInfo.message;

  if (isFirstTime && message === "NOT_SUPPORT_ERROR") {
    return exports.ConnectorError.NOT_SUPPORT_ERROR;
  } else if (message === "USER_DENIED" || message === "USER_DENIED_2") {
    return exports.ConnectorError.USER_DENIED;
  } else if (message && (message.startsWith("personalSign last") || message.indexOf("User denied transaction") > 0)) {
    return exports.ConnectorError.USER_DENIED;
  }

  return message;
};

var IsMobile = {
  Android: function Android() {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function BlackBerry() {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function iOS() {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function Opera() {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function Windows() {
    return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
  },
  Ethereum: function Ethereum() {
    var _window, _window2;

    return ((_window = window) == null ? void 0 : _window.ethereum) && ((_window2 = window) == null ? void 0 : _window2.ethereum.isImToken);
  },
  any: function any() {
    if (typeof global.navigator === 'undefined' || typeof navigator === 'undefined') {
      console.log("IsMobile any navigator is undefined");
      return false;
    }

    return IsMobile.Android() || IsMobile.BlackBerry() || IsMobile.iOS() || IsMobile.Opera() || IsMobile.Windows() || IsMobile.Ethereum();
  }
};

BigNumber.config({
  EXPONENTIAL_AT: 100,
  RANGE: [-100000, 10000000],
  ROUNDING_MODE: 1
});
/**
 * Returns hex string with '0x' prefix
 * @param input
 * @returns {string}
 */

function addHexPrefix(input) {
  if (typeof input === "string") {
    return input.startsWith("0x") ? input : "0x" + input;
  }

  throw new Error("Unsupported type");
}
/**
 *
 * @param mixed Buffer|number|string (hex string must be with '0x' prefix)
 * @returns {Buffer}
 */

function toBuffer(mixed) {
  if (mixed instanceof Buffer) {
    return mixed;
  } else {
    return ethUtil.toBuffer(mixed);
  }
}
/**
 *
 * @param num number|string (hex string must be with '0x' prefix)
 * @param places number of zeros to pad
 * @returns {Buffer}
 */

function zeroPad(num, places) {
  return toBuffer(String(num).padStart(places, "0"));
}
/**
 *
 * @param mixed number | BigNumber |  BN  | Buffer | string | Uint8Array
 * @returns {string}
 */

function toHex(mixed) {
  if (typeof mixed === "number" || mixed instanceof BigNumber || mixed instanceof BN) {
    return addHexPrefix(mixed.toString(16));
  }

  if (mixed instanceof Buffer || mixed instanceof Uint8Array) {
    return addHexPrefix(mixed.toString("hex"));
  }

  if (typeof mixed === "string") {
    var regex = new RegExp(/^0x[0-9a-fA-F]*$/);
    return regex.test(mixed) ? mixed : addHexPrefix(toBuffer(mixed).toString("hex"));
  }

  throw new Error("Unsupported type");
}
/**
 *
 * @param mixed number | BigNumber |  BN  | Buffer | string | Uint8Array
 * @returns {number}
 */

function toNumber(mixed) {
  if (typeof mixed === "number") {
    return mixed;
  }

  if (mixed instanceof BigNumber || mixed instanceof BN) {
    return mixed.toNumber();
  }

  if (typeof mixed === "string") {
    return Number(mixed);
  }

  if (mixed instanceof Buffer || mixed instanceof Uint8Array) {
    return Number(mixed.toString("hex"));
  }

  throw new Error("Unsupported type");
}
/**
 *
 * @param mixed number | BigNumber |  BN  | Buffer | string | Uint8Array
 * @returns {BigNumber}
 */

function toBig(mixed) {
  if (mixed instanceof BigNumber) {
    return mixed;
  }

  if (typeof mixed === "number") {
    return new BigNumber(mixed.toString());
  }

  if (typeof mixed === "string") {
    return new BigNumber(mixed);
  }

  if (mixed instanceof Buffer || mixed instanceof Uint8Array) {
    return new BigNumber(mixed.toString("hex"));
  }

  throw new Error("Unsupported type");
}
/**
 *
 * @param mixed number | BigNumber |  BN  | Buffer | string
 * @returns {BN}
 */

function toBN(mixed) {
  return mixed instanceof BN ? mixed : new BN(toBig(mixed).toString(10), 10);
}
/**
 *
 * @param value number | BigNumber | Buffer | string
 * @returns {BN}
 */

function fromGWEI(value) {
  return new BigNumber(toBig(value).times(1e9).toFixed(0));
}
/**
 *
 * @param value number | BigNumber | Buffer | string
 * @returns {BN}
 */

function toGWEI(value) {
  return toBig(value).div(1e9);
}
/**
 * Returns formatted hex string of a given private key
 * @param mixed Buffer | string | Uint8Array
 * @returns {string}
 */

function formatKey(mixed) {
  if (mixed instanceof Buffer || mixed instanceof Uint8Array) {
    return mixed.toString("hex");
  }

  if (typeof mixed === "string") {
    return mixed.startsWith("0x") ? mixed.slice(2) : mixed;
  }

  throw new Error("Unsupported type");
}
/**
 * Returns hex string of a given address
 * @param mixed Buffer | string |Uint8Array
 * @returns {string}
 */

function formatAddress(mixed) {
  if (mixed instanceof Buffer || mixed instanceof Uint8Array) {
    return ethUtil.toChecksumAddress("0x" + mixed.toString("hex"));
  }

  if (typeof mixed === "string") {
    return ethUtil.toChecksumAddress(mixed.startsWith("0x") ? mixed : "0x" + mixed);
  }

  throw new Error("Unsupported type");
}
/**
 * Returns hex string without '0x' prefix
 * @param input string
 * @returns {string}
 */

function clearHexPrefix(input) {
  if (typeof input === "string") {
    return input.startsWith("0x") ? input.slice(2) : input;
  }

  throw new Error("Unsupported type");
}
/**
 *
 * @param hex
 * @returns {string}
 */

function padLeftEven(hex) {
  return hex.length % 2 !== 0 ? "0" + hex : hex;
}
/**
 * Returns symbol of a given kind of currency
 * @param settingsCurrency
 * @returns {*}
 */

function getDisplaySymbol(settingsCurrency) {
  switch (settingsCurrency) {
    case "CNY":
      return "￥";

    case "USD":
      return "$";

    default:
      return "";
  }
}
/**
 * Returns number in string with a given precision
 * @param number number | BigNumber
 * @param precision number
 * @param ceil bool  round up
 * @returns {string}
 */

function toFixed(number, precision, ceil) {
  precision = precision || 0;

  if (number instanceof BigNumber) {
    var rm = ceil ? 0 : 1;
    return number.toFixed(precision, rm);
  }

  if (typeof number === "number") {
    return ceil ? (Math.ceil(number * Number("1e" + precision)) / Number("1e" + precision)).toFixed(precision) : (Math.floor(number * Number("1e" + precision)) / Number("1e" + precision)).toFixed(precision);
  }

  throw new Error("Unsupported type");
}
function formatEddsaKey(key) {
  var hexKey = clearHexPrefix(key);
  return addHexPrefix(String(hexKey).padStart(64, "0"));
}
/**
 * Returns a number with commas as thousands separators
 * @param number number
 * @returns {*}
 */

function numberWithCommas(number) {
  if (number) {
    number = number.toString().replace(/,/g, "");

    if (isNaN(Number(number))) {
      return "-";
    }

    try {
      var parts = number.toString().split(".");
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      return parts.join(".");
    } catch (err) {
      return "-";
    }
  } else {
    return number;
  }
}
function sortObjDictionary(obj) {
  var dataToSig = new Map();

  if (obj) {
    Reflect.ownKeys(obj).sort(function (a, b) {
      return a.toString().localeCompare(b.toString());
    }).forEach(function (key) {
      dataToSig.set(key.toString(), obj[key.toString()]);
    });
  }

  return dataToSig;
}
function makeMarket(raw_data) {
  var coinMap = {};
  var totalCoinMap = {};
  var addressIndex = {};
  var idIndex = {};
  var tokensMap = {};

  if (raw_data instanceof Array) {
    raw_data.forEach(function (item) {
      if (item.symbol.startsWith("LP-")) {
        item.isLpToken = true;
      } else {
        item.isLpToken = false;
      }

      tokensMap[item.symbol] = item;
      var coinInfo = {
        icon: SoursURL + ("ethereum/assets/" + item.address + "/logo.png"),
        name: item.name,
        simpleName: item.symbol,
        description: item.type,
        company: item.name
      };

      if (!item.symbol.startsWith("LP-")) {
        coinMap[item.symbol] = coinInfo;
      }

      totalCoinMap[item.symbol] = coinInfo;
      addressIndex[item.address.toLowerCase()] = item.symbol;
      idIndex[item.tokenId] = item.symbol;
    });
  }

  return {
    tokensMap: tokensMap,
    coinMap: coinMap,
    totalCoinMap: totalCoinMap,
    idIndex: idIndex,
    addressIndex: addressIndex
  };
}
function makeAmmPool(raw_data) {
  var ammpools = {};
  var pairs = {};

  if ((raw_data == null ? void 0 : raw_data.pools) instanceof Array) {
    raw_data.pools.forEach(function (item) {
      var market = item.market;
      ammpools[market] = item;
      var base = "",
          quote = "";
      var ind = market.indexOf("-");
      var ind2 = market.lastIndexOf("-");
      base = market.substring(ind + 1, ind2);
      quote = market.substring(ind2 + 1, market.length);

      if (!pairs[base]) {
        pairs[base] = {
          tokenId: item.tokens.pooled[0],
          tokenList: [quote]
        };
      } else {
        pairs[base].tokenList = [].concat(pairs[base].tokenList, [quote]);
      }

      if (!pairs[quote]) {
        pairs[quote] = {
          tokenId: item.tokens.pooled[1],
          tokenList: [base]
        };
      } else {
        pairs[quote].tokenList = [].concat(pairs[quote].tokenList, [base]);
      }
    });
  }

  return {
    ammpools: ammpools,
    pairs: pairs
  };
}
function makeMarkets(raw_data, url) {
  if (url === void 0) {
    url = exports.LOOPRING_URLs.GET_MARKETS;
  }

  var markets = {};
  var pairs = {};
  var isMix = url === exports.LOOPRING_URLs.GET_MIX_MARKETS;

  if ((raw_data == null ? void 0 : raw_data.markets) instanceof Array) {
    raw_data.markets.forEach(function (item) {
      var marketInfo = {
        baseTokenId: item.baseTokenId,
        enabled: item.enabled,
        market: item.market,
        orderbookAggLevels: item.orderbookAggLevels,
        precisionForPrice: item.precisionForPrice,
        quoteTokenId: item.quoteTokenId
      };

      if (isMix) {
        marketInfo.status = item.status;
        marketInfo.isSwapEnabled = marketInfo.status === exports.MarketStatus.ALL || marketInfo.status === exports.MarketStatus.AMM;
        marketInfo.createdAt = parseInt(item.createdAt);
      }

      markets[item.market] = marketInfo;

      if (item.enabled) {
        var market = item.market;
        var ind = market.indexOf("-");
        var base = market.substring(0, ind);
        var quote = market.substring(ind + 1, market.length);

        if (!pairs[base]) {
          pairs[base] = {
            tokenId: item.baseTokenId,
            tokenList: [quote]
          };
        } else {
          pairs[base].tokenList = [].concat(pairs[base].tokenList, [quote]);
        }

        if (!pairs[quote]) {
          pairs[quote] = {
            tokenId: item.quoteTokenId,
            tokenList: [base]
          };
        } else {
          pairs[quote].tokenList = [].concat(pairs[quote].tokenList, [base]);
        }
      }
    });
  }

  var marketArr = Reflect.ownKeys(markets);
  var tokenArr = Reflect.ownKeys(pairs);
  return {
    markets: markets,
    pairs: pairs,
    tokenArr: tokenArr,
    tokenArrStr: tokenArr.join(SEP),
    marketArr: marketArr,
    marketArrStr: marketArr.join(SEP)
  };
}

/* eslint-disable no-console, @typescript-eslint/ban-ts-comment */
var _myLog;

{
  _myLog = console.log;
}

var myLog = _myLog;

var BIG0 = /*#__PURE__*/toBig(0);
var BIG1 = /*#__PURE__*/toBig(1);
var BIG10 = /*#__PURE__*/toBig(10);
var BIG10K = /*#__PURE__*/toBig(10000);
var getToken = function getToken(tokens, token) {
  if (!tokens) {
    throw Error("no tokens list!");
  }

  return tokens[token];
};
var getTokenInfoByToken = function getTokenInfoByToken(ammBalance, tokens, token) {
  var tokenInfo = getToken(tokens, token);
  var tokenVol = ammBalance.pooledMap[tokenInfo.tokenId].volume;
  var reserve = toBig(tokenVol);
  return {
    tokenInfo: tokenInfo,
    tokenVol: tokenVol,
    reserve: reserve
  };
};
function fromWEI(tokens, symbol, valueInWEI, precision, ceil) {
  try {
    var tokenInfo = getToken(tokens, symbol);
    var precisionToFixed = precision ? precision : tokenInfo.precision;
    var value = toBig(valueInWEI).div("1e" + tokenInfo.decimals);
    return toFixed(value, precisionToFixed, ceil);
  } catch (err) {
    return undefined;
  }

  return "0";
}
function toWEI(tokens, symbol, value, rm) {
  if (rm === void 0) {
    rm = undefined;
  }

  var tokenInfo = getToken(tokens, symbol);

  if (typeof tokenInfo === "undefined") {
    return "0";
  }

  var bigN = toBig(value).times("1e" + tokenInfo.decimals);
  return rm === undefined ? bigN.toString() : bigN.toFixed(0, rm);
}
function isEmpty(input) {
  if (!input || input.trim() === "") {
    return true;
  }

  return false;
}

function getAmountOutWithFeeBips(amountIn, feeBips, reserveIn, reserveOut) {
  var amountInBig = toBig(amountIn);
  var reserveInBig = toBig(reserveIn);
  var reserveOutBig = toBig(reserveOut);

  if (amountInBig.lt(BIG0) || reserveInBig.lt(BIG0) || reserveOutBig.lt(BIG0)) {
    return BIG0;
  }

  var feeBipsBig = toBig(feeBips);
  var amountInWithFee = amountInBig.times(BIG10K.minus(feeBipsBig));
  var numerator = amountInWithFee.times(reserveOutBig);
  var denominator = reserveInBig.times(BIG10K).plus(amountInWithFee);
  return numerator.div(denominator);
}

function getAmountInWithFeeBips(amountOut, feeBips, reserveIn, reserveOut) {
  var amountOutBig = toBig(amountOut);
  var reserveInBig = toBig(reserveIn);
  var reserveOutBig = toBig(reserveOut);

  if (amountOutBig.lt(BIG0) || reserveInBig.lt(BIG0) || reserveOutBig.lt(BIG0)) {
    return BIG0;
  }

  var feeBipsBig = toBig(feeBips);
  var numerator = reserveInBig.times(amountOutBig).times(BIG10K);
  var denominator = reserveOutBig.minus(amountOutBig).times(BIG10K.minus(feeBipsBig));
  return numerator.div(denominator).plus(BIG1);
}

function getOutputOrderbook(input, baseToken, quoteToken, feeBips, isAtoB, isReverse, depth) {
  var output = "0";
  var remain = input;
  var bids = depth.bids; // .reverse()
  // console.log('bids:', bids[0])
  // console.log('bids last:', bids[bids.length - 1])
  // console.log('asks:', depth.asks[0])
  // console.log('asks last:', depth.asks[depth.asks.length - 1])
  // console.log(`isAtoB:${isAtoB} isReverse:${isReverse}`)

  if (!baseToken || !quoteToken) {
    return output;
  } // myLog(baseToken, ' ', quoteToken)
  //amt is size(base ETH). vol is volume(quote USDT)


  if (isAtoB) {
    if (!isReverse) {
      //ETH -> USDT
      remain = toBig(remain).times("1e" + baseToken.decimals).toString();

      for (var i = bids.length - 1; i >= 0; i--) {
        var abInfo = bids[i]; // console.log(`i:${i} abInfo:`, abInfo, `decimals:${baseToken.decimals} ${quoteToken.decimals}`)

        var consume = toBig(remain).gte(toBig(abInfo.amt)) ? abInfo.amt : remain;

        if (toBig(consume).lte(BIG0)) {
          break;
        }

        var volValue = toBig(abInfo.vol).div("1e" + quoteToken.decimals);

        if (toBig(consume).eq(toBig(abInfo.amt))) {
          output = toBig(output).plus(volValue).toString();
        } else {
          var ratio = toBig(consume).div(toBig(abInfo.amt)); // myLog('got ratio:', ratio.toString(), consume, abInfo.amt)

          output = toBig(output).plus(ratio.times(volValue)).toString();
        } // myLog('1__ ', i, ' output:', output, ' remain:', remain, ' abInfo.amt:', abInfo.amt, ' abInfo.vol:', abInfo.vol, ' volValue:', volValue.toString())


        remain = toBig(remain).minus(toBig(consume)).toString();
      }
    } else {
      // USDT -> ETH
      // isAtoB = true, isReverse = false
      remain = toBig(remain).times(BIG10.pow(baseToken.decimals)).toString();

      for (var _i = 0; _i < depth.asks.length; _i++) {
        var _abInfo = depth.asks[_i]; // const placed: string = fm.toBig(abInfo.vol).div(BIG10.pow(quoteToken.decimals)).toString()

        var _consume = toBig(remain).gte(toBig(_abInfo.vol)) ? _abInfo.vol : remain;

        if (toBig(_consume).lte(BIG0)) {
          // console.log('return 22222')
          break;
        } // console.log(`i:${i} abInfo:`, abInfo, `decimals:${baseToken.decimals} ${quoteToken.decimals}`)
        // console.log('remain:', remain, ' abInfo.vol:', abInfo.vol, ' consume:', consume)


        var amtValue = toBig(_abInfo.amt).div("1e" + quoteToken.decimals);

        if (toBig(_consume).eq(toBig(_abInfo.vol))) {
          output = toBig(output).plus(amtValue).toString();
        } else {
          var _ratio = toBig(_consume).div(toBig(_abInfo.vol));

          output = toBig(output).plus(_ratio.times(amtValue)).toString();
        }

        remain = toBig(remain).minus(toBig(_consume)).toString(); // myLog('2__ ', i, ' output:', output, ' abInfo.vol:', abInfo.vol, ' remain:', remain)
      }
    }
  } else {
    if (!isReverse) {
      // ETH <- USDT
      remain = toBig(remain).times(BIG10.pow(quoteToken.decimals)).toString();

      for (var _i2 = bids.length - 1; _i2 >= 0; _i2--) {
        var _abInfo2 = bids[_i2]; // const placed: string = fm.toBig(abInfo.vol).div(BIG10.pow(quoteToken.decimals)).toString()

        var _consume2 = toBig(remain).gte(toBig(_abInfo2.vol)) ? _abInfo2.vol : remain;

        if (toBig(_consume2).lte(BIG0)) {
          break;
        } // myLog(`i:${i} abInfo:`, abInfo, `decimals:${baseToken.decimals} ${quoteToken.decimals}`)
        // myLog('remain:', remain, 'abInfo.vol:', abInfo.vol, ' consume:', consume)


        var _amtValue = toBig(_abInfo2.amt).div(BIG10.pow(baseToken.decimals));

        if (toBig(_consume2).eq(_abInfo2.vol)) {
          output = toBig(output).plus(toBig(_amtValue)).toString();
        } else {
          var _ratio2 = toBig(_consume2).div(toBig(_abInfo2.vol));

          output = toBig(output).plus(_ratio2.times(_amtValue)).toString();
        }

        remain = toBig(remain).minus(toBig(_consume2)).toString(); // myLog('3__', i, ' output:', output, ' abInfo.vol:', abInfo.vol, ' remain:', remain)
      }
    } else {
      // USDT <- ETH
      remain = toBig(remain).times(BIG10.pow(quoteToken.decimals)).toString();

      for (var _i3 = 0; _i3 < depth.asks.length; _i3++) {
        var _abInfo3 = depth.asks[_i3]; // myLog(`i:${i} abInfo:`, abInfo, `decimals:${baseToken.decimals} ${quoteToken.decimals}`)

        var _consume3 = toBig(remain).gte(toBig(_abInfo3.amt)) ? _abInfo3.amt : remain;

        if (toBig(_consume3).lte(BIG0)) {
          break;
        }

        var _volValue = toBig(_abInfo3.vol).div(BIG10.pow(baseToken.decimals));

        if (toBig(_consume3).eq(toBig(_abInfo3.amt))) {
          output = toBig(output).plus(_volValue).toString();
        } else {
          var _ratio3 = toBig(_consume3).div(toBig(_abInfo3.amt));

          output = toBig(output).plus(_ratio3.times(_volValue)).toString();
        } // myLog('4__', i, ' output:', output, ' abInfo.vol:', abInfo.vol, ' volValue:', volValue.toString())


        remain = toBig(remain).minus(toBig(_consume3)).toString();
      }
    }
  }

  return output;
}

function getReserveInfo(sell, buy, marketArr, tokenMap, marketMap, ammPoolSnapshot) {
  var _ammPoolSnapshot, _ammPoolSnapshot2;

  if (ammPoolSnapshot === void 0) {
    ammPoolSnapshot = undefined;
  }

  var _getExistedMarket = getExistedMarket(marketArr, sell, buy),
      market = _getExistedMarket.market,
      amm = _getExistedMarket.amm;

  if (isEmpty(market) || isEmpty(amm) || Object.keys(marketMap).indexOf(market) < 0) {
    return undefined;
  }

  var marketInfo = marketMap[market];
  var sellToken = getTokenInfoBySymbol(tokenMap, sell);
  var buyToken = getTokenInfoBySymbol(tokenMap, buy);
  var isReverse = false;
  var coinA = (_ammPoolSnapshot = ammPoolSnapshot) == null ? void 0 : _ammPoolSnapshot.pooled[0];
  var coinB = (_ammPoolSnapshot2 = ammPoolSnapshot) == null ? void 0 : _ammPoolSnapshot2.pooled[1];
  var reserveIn = "0";
  var reserveOut = "0";

  if ((sellToken == null ? void 0 : sellToken.tokenId) !== undefined && (buyToken == null ? void 0 : buyToken.tokenId) !== undefined && (coinA == null ? void 0 : coinA.tokenId) !== undefined && (coinB == null ? void 0 : coinB.tokenId) !== undefined) {
    if ((sellToken == null ? void 0 : sellToken.tokenId) === (coinA == null ? void 0 : coinA.tokenId)) {
      reserveIn = coinA.volume;
      reserveOut = coinB.volume;
    } else {
      reserveIn = coinB.volume;
      reserveOut = coinA.volume;
      isReverse = true;
    }
  } else {
    if (market === buy + "-" + sell) {
      isReverse = true;
    }
  }

  return {
    reserveIn: reserveIn,
    reserveOut: reserveOut,
    sellToken: sellToken,
    buyToken: buyToken,
    coinA: coinA,
    coinB: coinB,
    isReverse: isReverse,
    marketInfo: marketInfo
  };
}

function getPriceImpactStr(curPrice, toPrice) {
  if (!curPrice || !toPrice) {
    return "0";
  }

  var toPriceBig = toBig(toPrice);

  if (toPriceBig.eq(BIG0)) {
    return "0";
  }

  var percent = toBig(toPriceBig).div(curPrice);
  return BIG1.minus(percent).abs().toString();
}

function getCurPrice(reserveIn, reserveOut) {
  if (!reserveIn || !reserveOut) {
    return "0";
  }

  reserveIn = reserveIn.trim();
  reserveOut = reserveOut.trim();
  var reserveInBig = toBig(reserveIn);
  var reserveOutBig = toBig(reserveOut);

  if (reserveInBig.eq(BIG0)) {
    return "0";
  }

  return reserveOutBig.div(reserveInBig).toString();
}
function getToPrice(amountS, amountB) {
  if (!amountS || !amountB) {
    return "0";
  }

  amountS = amountS.trim();
  amountB = amountB.trim();
  var amountSBig = toBig(amountS);
  var amountBBig = toBig(amountB);

  if (amountSBig.eq(BIG0)) {
    return "0";
  }

  return amountBBig.div(amountSBig).toString();
}
function getPriceImpact(reserveIn, reserveOut, amountS, feeBips, takerFee) {
  var amountB = getAmountOutWithFeeBips(amountS, feeBips, reserveIn, reserveOut);
  amountB = amountB.times(BIG10K.minus(toBig(takerFee))).div(BIG10K);
  var curPrice = getCurPrice(reserveIn, reserveOut);
  var toPrice = getToPrice(amountS, amountB.toString());
  return getPriceImpactStr(curPrice, toPrice);
}
function updatePriceImpact_new(reverseIn, reverseOut, amountS, sellDecimal, amountBOut, buyDecimal, feeBips, takerFee, isAtoB, isReversed, exceedDepth, depth) {
  var priceImpact = "0";

  if (isEmpty(reverseIn) || isEmpty(reverseOut) || isEmpty(feeBips)) {
    return "0";
  }

  if (exceedDepth) {
    priceImpact = getPriceImpact(reverseIn, reverseOut, amountS, feeBips, "0");
  } else {
    if (!depth.mid_price) {
      return "0";
    } // LRC / ETH !isReversed isAtoB


    var coinADecimal = !isReversed ? sellDecimal : buyDecimal;
    var coinBDecimal = !isReversed ? buyDecimal : sellDecimal;
    var curPrice = toBig(depth.mid_price).times("1e" + coinBDecimal).div("1e" + coinADecimal).toString();
    var toPrice = !isReversed ? getToPrice(amountS, amountBOut) : getToPrice(amountBOut, amountS); // console.log('updatePriceImpact_new isReversed:', isReversed, ' amountS:', amountS, ' amountBOut:', amountBOut)
    // console.log('updatePriceImpact_new toPrice:', toPrice, ' curPrice:', curPrice)

    priceImpact = getPriceImpactStr(curPrice, toPrice);
  }

  return priceImpact;
}
function getMinReceived(amountBOut, minimumDecimal, slipBips) {
  var minReceived = toBig(amountBOut).times(BIG10K.minus(toBig(slipBips))).div(BIG10K);
  return {
    minReceived: minReceived.toFixed(0, 0),
    minReceivedVal: minReceived.div("1e" + minimumDecimal).toString(),
    minimumDecimal: minimumDecimal
  };
}
function getOutputAmount(_ref) {
  var input = _ref.input,
      sell = _ref.sell,
      buy = _ref.buy,
      isAtoB = _ref.isAtoB,
      marketArr = _ref.marketArr,
      tokenMap = _ref.tokenMap,
      marketMap = _ref.marketMap,
      depth = _ref.depth,
      ammPoolSnapshot = _ref.ammPoolSnapshot,
      feeBips = _ref.feeBips,
      takerRate = _ref.takerRate,
      slipBips = _ref.slipBips;
  // console.log('enter getOutputAmount:', input, base, quote, isAtoB, marketArr, tokenMap, marketMap, depth, ammPoolSnapshot, feeBips, takerRate, slipBips)
  // console.log(`getOutputAmount market: ${base} / ${quote}`)
  // console.log('ammPoolSnapshot:', ammPoolSnapshot)
  var reserveInfo = getReserveInfo(sell, buy, marketArr, tokenMap, marketMap, ammPoolSnapshot);

  if (!reserveInfo) {
    return undefined;
  }

  var reserveIn = reserveInfo.reserveIn,
      reserveOut = reserveInfo.reserveOut,
      sellToken = reserveInfo.sellToken,
      buyToken = reserveInfo.buyToken,
      isReverse = reserveInfo.isReverse,
      marketInfo = reserveInfo.marketInfo;

  if (!sellToken || !buyToken) {
    return undefined;
  }

  input = input.trim();
  var exceedDepth = false;
  var output = "0";
  var amountS = "0";
  var amountBOutWithoutFee = "0";
  var amountBOut = "0";
  var sellAmt = "0";
  var buyAmt = "0";
  var minimumDecimal = 0;

  if (isAtoB) {
    // bids_amtTotal -> bidsSizeShown
    // asks_volTotal -> asksQuoteSizeShown
    var amountInWei = toWEI(tokenMap, sell, input, 0); // console.log('isAtoB amountInWei:', amountInWei)

    if (isEmpty(depth.bids_amtTotal) || isEmpty(depth.asks_volTotal)) {
      exceedDepth = true;
    } else {
      if (!isReverse) {
        exceedDepth = toBig(amountInWei).gt(toBig(depth.bids_amtTotal)); // console.log('3 amountInWei:', amountInWei, ' bids_amtTotal:', depth.bids_amtTotal)
      } else {
        exceedDepth = toBig(amountInWei).gt(toBig(depth.asks_volTotal)); // console.log('4 amountInWei:', amountInWei, ' asks_volTotal:', depth.asks_volTotal)
      }
    } // console.log(`a2b(input:${input})  exceedDepth:`, exceedDepth, ' isSwapEnabled:', marketInfo.isSwapEnabled)


    if (exceedDepth) {
      if (marketInfo.isSwapEnabled) {
        var amountB = getAmountOutWithFeeBips(amountInWei, feeBips, reserveIn, reserveOut);
        output = fromWEI(tokenMap, buy, amountB.toFixed(0, 0));
      }
    } else {
      output = getOutputOrderbook(input, sellToken, buyToken, feeBips, isAtoB, isReverse, depth);
    }

    amountBOutWithoutFee = toWEI(tokenMap, buy, output, 0);
    var leftRatio = BIG10K.minus(toBig(takerRate)).div(BIG10K); // console.log('amountBOutWithoutFee:', amountBOutWithoutFee, ' leftRatio:', leftRatio.toString())

    amountBOut = toWEI(tokenMap, buy, toBig(output).times(leftRatio).toString(), 0);
    amountS = toWEI(tokenMap, sell, input, 0);
    sellAmt = input;
    buyAmt = output;
  } else {
    // asks_amtTotal -> asksSizeShown
    // bids_volTotal -> bidsQuoteSizeShown
    if (isEmpty(depth.bids_volTotal) || isEmpty(depth.asks_amtTotal)) {
      exceedDepth = true;
    } else {
      var _amountInWei = toWEI(tokenMap, buy, input, 0);

      if (!isReverse) {
        exceedDepth = toBig(_amountInWei).gt(toBig(depth.bids_volTotal));
      } else {
        exceedDepth = toBig(_amountInWei).gt(toBig(depth.asks_amtTotal));
      }
    }

    var amountSBint = BIG0;

    var _amountB = toWEI(tokenMap, buy, input, 0); // console.log(`b2a(input:${input}) exceedDepth:${exceedDepth} amountB:${amountB}`)


    if (exceedDepth) {
      if (marketInfo.isSwapEnabled) {
        amountSBint = getAmountInWithFeeBips(_amountB, feeBips, reserveIn, reserveOut);
      }
    } else {
      var outputOrderbook = getOutputOrderbook(input, sellToken, buyToken, feeBips, isAtoB, isReverse, depth);
      amountSBint = toBig(toWEI(tokenMap, sell, outputOrderbook));
    }

    if (amountSBint.gt(BIG0)) {
      output = fromWEI(tokenMap, sell, amountSBint.toString());
      amountBOutWithoutFee = toBig(_amountB).toFixed(0, 0); // amountBOutWithoutFee = amountB

      var _leftRatio = BIG10K.minus(toBig(takerRate)).div(BIG10K);

      amountBOut = toBig(_amountB).times(_leftRatio).toFixed(0, 0);
    }

    amountS = amountSBint.toFixed(0, 0); // console.log('got amountSBint:', amountSBint.toString(), amountSBint.gt(BIG0), ' amountBOut:', amountBOut.toString())

    sellAmt = output;
    buyAmt = input;
  }

  minimumDecimal = buyToken.decimals;
  var amountBOutSlip = getMinReceived(amountBOut, minimumDecimal, slipBips);
  var priceImpact = updatePriceImpact_new(reserveIn, reserveOut, amountS, sellToken.decimals, amountBOut, buyToken.decimals, feeBips, takerRate, isAtoB, isReverse, exceedDepth, depth);
  return {
    exceedDepth: exceedDepth,
    isReverse: isReverse,
    isAtoB: isAtoB,
    slipBips: slipBips,
    takerRate: takerRate,
    feeBips: feeBips,
    output: output,
    sellAmt: sellAmt,
    buyAmt: buyAmt,
    amountS: amountS,
    amountBOut: amountBOut,
    amountBOutWithoutFee: amountBOutWithoutFee,
    amountBOutSlip: amountBOutSlip,
    priceImpact: priceImpact
  };
}
function ammPoolCalc(rawVal, isAtoB, coinA, coinB) {
  var coinA_Vol_BIG = toBig(coinA.volume);
  var coinB_Vol_BIG = toBig(coinB.volume);
  var output = BIG0;
  var ratio = BIG0;

  if (isAtoB) {
    if (!coinA_Vol_BIG.eq(BIG0)) {
      ratio = toBig(rawVal).div(coinA_Vol_BIG);
      output = ratio.times(coinB_Vol_BIG);
    }
  } else {
    if (!coinB_Vol_BIG.eq(BIG0)) {
      ratio = toBig(rawVal).div(coinB_Vol_BIG);
      output = ratio.times(coinA_Vol_BIG);
    }
  }

  return {
    output: output.toFixed(0, 0),
    ratio: ratio
  };
}
/**
 *
 * @param rawVal
 * @param isAtoB
 * @param slippageTolerance
 * @param owner
 * @param fees
 * @param ammPoolSnapshot
 * @param tokenMap
 * @param idIdx
 * @param coinAOffchainId
 * @param coinBOffchainId
 * @param rawValMatchForRawVal first time add to pool
 */

function makeJoinAmmPoolRequest(rawVal, isAtoB, slippageTolerance, owner, fees, ammPoolSnapshot, tokenMap, idIdx, coinAOffchainId, coinBOffchainId, rawValMatchForRawVal) {
  if (coinAOffchainId === void 0) {
    coinAOffchainId = 0;
  }

  if (coinBOffchainId === void 0) {
    coinBOffchainId = 0;
  }

  var coinA = ammPoolSnapshot.pooled[0];
  var coinB = ammPoolSnapshot.pooled[1];
  var baseToken = tokenMap[idIdx[coinA.tokenId]];
  var quoteToken = tokenMap[idIdx[coinB.tokenId]];
  var fee = fees && fees[quoteToken.symbol] && fees[quoteToken.symbol].fee ? fees[quoteToken.symbol].fee : "0";
  rawVal = toBig(rawVal).times(BIG10.pow(isAtoB ? baseToken.decimals : quoteToken.decimals)).toFixed(0, 0); // eslint-disable-next-line prefer-const

  var _ammPoolCalc = ammPoolCalc(rawVal, isAtoB, coinA, coinB),
      output = _ammPoolCalc.output,
      ratio = _ammPoolCalc.ratio;

  var volLp;

  if (output === "0" && rawValMatchForRawVal) {
    output = toBig(rawValMatchForRawVal).times(BIG10.pow(isAtoB ? quoteToken.decimals : baseToken.decimals)).toFixed(0, 0); // ratio = fm.toBig("1");

    volLp = "1";
  } else {
    var rest = BIG1.minus(toBig(slippageTolerance));
    volLp = toBig(ammPoolSnapshot.lp.volume).times(ratio).times(rest).toFixed(0, 0);
  }

  var volA = isAtoB ? rawVal : output;
  var volB = isAtoB ? output : rawVal;
  var request = {
    owner: owner,
    poolAddress: ammPoolSnapshot.poolAddress,
    joinTokens: {
      pooled: [{
        tokenId: coinA.tokenId,
        volume: volA
      }, {
        tokenId: coinB.tokenId,
        volume: volB
      }],
      minimumLp: {
        tokenId: ammPoolSnapshot.lp.tokenId,
        volume: volLp
      }
    },
    storageIds: [coinAOffchainId, coinBOffchainId],
    fee: fee
  };
  return {
    request: request
  };
}
function makeExitAmmPoolMini(rawVal, ammPoolSnapshot, tokenMap, idIdx, RatioDecimal) {
  if (RatioDecimal === void 0) {
    RatioDecimal = 10;
  }

  var lpTokenVol = ammPoolSnapshot.lp;
  var lpToken = tokenMap[idIdx[lpTokenVol.tokenId]];
  var miniLpVol = toBig(lpTokenVol.volume).times(2).div("1e" + RatioDecimal);
  return {
    miniLpVol: miniLpVol.toString(),
    miniLpVal: toBig(miniLpVol).div("1e" + lpToken.decimals).toString()
  };
}
function makeExitAmmCoverFeeLP(fees, ammPoolSnapshot, tokenMap, idIdx, slippageTolerance) {
  if (slippageTolerance === void 0) {
    slippageTolerance = "0.001";
  }

  var lpTokenVol = ammPoolSnapshot.lp;
  var lpToken = tokenMap[idIdx[lpTokenVol.tokenId]];
  var quote = ammPoolSnapshot.pooled[1];
  var quoteToken = tokenMap[idIdx[quote.tokenId]];
  var quoteVolume = quote.volume;
  var maxFee = fees && fees[quoteToken.symbol] ? fees[quoteToken.symbol].fee : "0"; // feeLp = fee /snap.quote*snap.lp

  var feeLp = toBig(maxFee).times(lpTokenVol.volume).div(quoteVolume).plus(1); // feeLp = feeLp / (1-slippageTolerance)  slippageTolerance default is 0.001

  var feeLpWithSlippage = feeLp.div(BIG1.minus(toBig(slippageTolerance)));
  return {
    feeLp: feeLp.toString(),
    feeLpWithSlippage: feeLpWithSlippage.toString(),
    miniFeeLpWithSlippageVal: toBig(feeLpWithSlippage).div("1e" + lpToken.decimals).toString(),
    feeLpVal: toBig(feeLp).div("1e" + lpToken.decimals).toString()
  };
}
function makeExitAmmPoolRequest2(rawVal, slippageTolerance, owner, fees, ammPoolSnapshot, tokenMap, idIdx, offchainId, minDecimal) {
  if (offchainId === void 0) {
    offchainId = 0;
  }

  if (minDecimal === void 0) {
    minDecimal = 10;
  }

  var lpTokenVol = ammPoolSnapshot.lp;
  var lpToken = tokenMap[idIdx[lpTokenVol.tokenId]];
  var burnedVol = toBig(rawVal).times("1e" + lpToken.decimals).toFixed(0, 0);
  var ratio = toBig(burnedVol).times("1e" + minDecimal).div(lpTokenVol.volume).toFixed(0, 1);
  var coinA = ammPoolSnapshot.pooled[0];
  var coinB = ammPoolSnapshot.pooled[1];
  var rest = BIG1.minus(toBig(slippageTolerance));
  var volA = toBig(ratio).times(coinA.volume).div("1e" + minDecimal).times(rest).toFixed(0, 0);
  var volB = toBig(ratio).times(coinB.volume).div("1e" + minDecimal).times(rest).toFixed(0, 0);
  var baseToken = tokenMap[idIdx[coinA.tokenId]];
  var quoteToken = tokenMap[idIdx[coinB.tokenId]];
  var maxFee = fees && fees[quoteToken.symbol] ? fees[quoteToken.symbol].fee : "0";
  var request = {
    owner: owner,
    poolAddress: ammPoolSnapshot.poolAddress,
    exitTokens: {
      unPooled: [{
        tokenId: coinA.tokenId,
        volume: volA
      }, {
        tokenId: coinB.tokenId,
        volume: volB
      }],
      burned: {
        tokenId: ammPoolSnapshot.lp.tokenId,
        volume: burnedVol
      }
    },
    storageId: offchainId,
    maxFee: maxFee
  };
  return {
    ratio: ratio,
    volA: volA,
    volB: volB,
    volA_show: toBig(volA).div("1e" + baseToken.decimals).toString(),
    volB_show: toBig(volB).div("1e" + quoteToken.decimals).toString(),
    request: request
  };
}
/**
 * calcDefi
 * @param isJoin {boolean} true is join, false is exit
 * @param isInputSell {boolean} user input sell of buy
 * @param XOR<sellAmount,buyAmount> user input sell amount number (without decimals)
 * @param feeVol fee Volume from server-side (decimals)
 * @param marketInfo {DefiMarketInfo} DefiMarketInfo from sever-side
 * @param tokenSell {TokenInfo} token Config information
 * @param tokenBuy {TokenInfo} token Config information
 * @param buyTokenBalanceVol   buy Token Balance server-side (decimals)
 * @return {sellVol} sell Volume (decimals);
 * @return {buyVol} buy Volume (decimals);
 * @return {maxSellVol} max Sell Volume (decimals); please use ceil for view
 * @return {miniSellVol} min Sell Volume (decimals); please use round for view
 * @return {maxFeeBips} number maxFeeBips;
 * @return {isJoin} boolean;
 * @return {isInputSell} boolean;
 */

function calcDefi(_ref2) {
  var isJoin = _ref2.isJoin,
      isInputSell = _ref2.isInputSell,
      sellAmount = _ref2.sellAmount,
      buyAmount = _ref2.buyAmount,
      feeVol = _ref2.feeVol,
      marketInfo = _ref2.marketInfo,
      tokenSell = _ref2.tokenSell,
      tokenBuy = _ref2.tokenBuy,
      buyTokenBalanceVol = _ref2.buyTokenBalanceVol;

  /** isDeposit calc sellPrice & buyPrice */
  var _ref3 = isJoin ? [marketInfo.depositPrice] : [marketInfo.withdrawPrice],
      sellPrice = _ref3[0];
  /** calc MiniSellVol & MaxSellVol**/


  var dustToken = tokenBuy;
  var minVolBuy = BigNumber.max(toBig(feeVol).times(2), dustToken.orderAmounts.dust);
  var miniSellVol = BigNumber.max(minVolBuy.div(sellPrice), tokenSell.orderAmounts.dust);
  var maxSellVol = toBig(buyTokenBalanceVol).div(sellPrice);
  /** calc MiniSellVol & MaxSellVol END**/
  // debugger;

  /** View input calc sellVol & buyVol */

  var sellVol, buyVol;

  if (isInputSell) {
    sellVol = toBig(sellAmount ? sellAmount : 0).times("1e" + tokenSell.decimals);
    buyVol = sellVol.times(sellPrice);
  } else {
    buyVol = toBig(buyAmount ? buyAmount : 0).times("1e" + tokenBuy.decimals);
    sellVol = buyVol.div(sellPrice);
  }
  /** View input calc sellVol & buyVol END */

  /** calc current maxFeeBips **/


  var maxFeeBips = Math.ceil(toBig(feeVol).times(10000).div(buyVol).toNumber());
  return {
    sellVol: sellVol.toString(),
    buyVol: buyVol.toString(),
    maxSellVol: maxSellVol.toString(),
    isJoin: isJoin,
    isInputSell: isInputSell,
    maxFeeBips: maxFeeBips,
    miniSellVol: miniSellVol.toString()
  };
}
/**
 *
 * @param info
 * @param index
 * @param rule
 * @param balance
 * @param feeVol
 * @param sellToken
 * @param buyToken
 * @param sellAmount
 * @param currentPrice
 */

function calcDual(_ref4) {
  var _maxSellAmount;

  var info = _ref4.info,
      rule = _ref4.rule,
      balance = _ref4.balance,
      feeVol = _ref4.feeVol,
      sellToken = _ref4.sellToken,
      buyToken = _ref4.buyToken,
      sellAmount = _ref4.sellAmount,
      dualMarket = _ref4.dualMarket;
  var sellVol = toBig(sellAmount ? sellAmount : 0).times("1e" + sellToken.decimals);
  var lessEarnVol, lessEarnTokenSymbol, greaterEarnVol, greaterEarnTokenSymbol, maxSellAmount, miniSellVol, feeTokenSymbol, quota, maxFeeBips;
  var base = info.base,
      currency = info.currency;
  var settleRatio = toBig(info.profit).times(info.ratio).toFixed(6, BigNumber.ROUND_DOWN);

  if (info.dualType === exports.DUAL_TYPE.DUAL_BASE) {
    var _balance$base;

    lessEarnVol = toBig(settleRatio).plus(1).times(sellVol); //dualViewInfo.strike);

    lessEarnTokenSymbol = sellToken.symbol;
    greaterEarnVol = toBig(toBig(settleRatio).plus(1).times(sellAmount ? sellAmount : 0).times(info.strike).toFixed(buyToken.precision, BigNumber.ROUND_CEIL)).times("1e" + buyToken.decimals); // myLog('greaterEarnVol',toBig(settleRatio).plus(1).times(sellAmount ?sellAmount: 0)
    // 	.times(info.strike).toFixed(buyToken.precision,BigNumber.ROUND_CEIL).toString(), greaterEarnVol.toString())

    greaterEarnTokenSymbol = buyToken.symbol;
    miniSellVol = BigNumber.max(dualMarket.baseLimitAmount, toBig(rule.baseMin).times("1e" + sellToken.decimals)); // rule.baseMin;

    quota = BigNumber.min(info.baseSize, balance ? (_balance$base = balance[base]) == null ? void 0 : _balance$base.free : 0); // quota = BigNumber.min(100, balance ? balance[ base ]?.free : 0)

    maxSellAmount = BigNumber.min(rule.baseMax ? rule.baseMax : 0, quota);
    feeTokenSymbol = buyToken.symbol;
    maxFeeBips = 5; //info.dualPrice.dualBid[ 0 ].baseQty;
  } else {
    lessEarnVol = toBig(toBig(settleRatio).plus(1).times(sellAmount ? sellAmount : 0) // .times(1 + info.ratio)
    .div(info.strike).toFixed(buyToken.precision, BigNumber.ROUND_CEIL)).times("1e" + buyToken.decimals); // sellVol.times(1 + info.ratio).div(dualViewInfo.strike); //.times(1 + dualViewInfo.settleRatio);

    lessEarnTokenSymbol = buyToken.symbol;
    greaterEarnVol = toBig(settleRatio).plus(1).times(sellVol); //.div(dualViewInfo.strike);

    greaterEarnTokenSymbol = sellToken.symbol;
    miniSellVol = BigNumber.max(dualMarket.quoteLimitAmount, toBig(rule.currencyMin).times("1e" + sellToken.decimals)); // rule.baseMin;

    quota = BigNumber.min(toBig(info.baseSize).times(info.strike).toString(), balance[currency].free);
    maxSellAmount = BigNumber.min(rule.currencyMax, quota);
    /** calc current maxFeeBips **/

    feeTokenSymbol = buyToken.symbol;
    maxFeeBips = 5;
  }

  myLog("settleRatio", settleRatio, lessEarnVol.toString(), greaterEarnVol.toString(), "strike", info.strike);
  return {
    quota: quota.toString(),
    sellVol: sellVol.toString(),
    lessEarnVol: lessEarnVol.toString(),
    lessEarnTokenSymbol: lessEarnTokenSymbol,
    greaterEarnVol: greaterEarnVol.toString(),
    greaterEarnTokenSymbol: greaterEarnTokenSymbol,
    miniSellVol: miniSellVol.toString(),
    sellToken: sellToken,
    maxSellAmount: maxSellAmount ? (_maxSellAmount = maxSellAmount) == null ? void 0 : _maxSellAmount.toString() : "",
    maxFeeBips: maxFeeBips,
    // dualViewInfo: dualViewInfo as unknown as R,
    feeVol: feeVol,
    feeTokenSymbol: feeTokenSymbol
  };
}
/**
 *
 * @param info  CEX_MARKET
 * @param index
 * @param rule
 * @param balance
 * @param feeVol
 * @param sellToken
 * @param buyToken
 * @param sellAmount
 * @param currentPrice
 */

function calcDex(_ref5) {
  var _amountB2, _amountS;

  var info = _ref5.info,
      input = _ref5.input,
      sell = _ref5.sell,
      buy = _ref5.buy,
      isAtoB = _ref5.isAtoB,
      marketArr = _ref5.marketArr,
      tokenMap = _ref5.tokenMap,
      marketMap = _ref5.marketMap,
      depth = _ref5.depth,
      feeBips = _ref5.feeBips;
  var sellToken = tokenMap[sell];
  var buyToken = tokenMap[buy];
  var reserveInfo = getReserveInfo(sell, buy, marketArr, tokenMap, marketMap);

  if (!reserveInfo) {
    throw {
      message: exports.ConnectorError.CEX_NO_PRODUCT,
      msg: exports.ConnectorError.CEX_NO_PRODUCT,
      code: exports.LoopringErrorCode.CEX_NO_PRODUCT
    };
  }

  var isReverse = reserveInfo.isReverse;
  var sellVol, buyVol, amountB, amountS, exceedDepth;

  if (isAtoB) {
    sellVol = input;
    amountS = toBig(input ? input : 0).times("1e" + sellToken.decimals);
    var amountInWei = amountS;

    if (isEmpty(depth.bids_amtTotal) || isEmpty(depth.asks_volTotal)) {
      throw {
        message: exports.ConnectorError.CEX_NO_DEPTH_ERROR,
        msg: exports.ConnectorError.CEX_NO_DEPTH_ERROR,
        code: exports.LoopringErrorCode.CEX_NO_DEPTH_ERROR
      };
    } else {
      if (!isReverse) {
        exceedDepth = toBig(amountInWei).gt(toBig(depth.bids_amtTotal)); // console.log('3 amountInWei:', amountInWei, ' bids_amtTotal:', depth.bids_amtTotal)
      } else {
        exceedDepth = toBig(amountInWei).gt(toBig(depth.asks_volTotal)); // console.log('4 amountInWei:', amountInWei, ' asks_volTotal:', depth.asks_volTotal)
      }

      if (exceedDepth) {
        buyVol = undefined;
        amountB = undefined;
      } else {
        var _buyVol;

        buyVol = getOutputOrderbook(input, sellToken, buyToken, feeBips, isAtoB, isReverse, depth).toString();
        amountB = toBig((_buyVol = buyVol) != null ? _buyVol : 0).times("1e" + buyToken.decimals);
      }
    }
  } else {
    buyVol = input;
    amountB = toBig(input ? input : 0).times("1e" + buyToken.decimals);

    if (isEmpty(depth.bids_volTotal) || isEmpty(depth.asks_amtTotal)) {
      throw {
        message: exports.ConnectorError.CEX_NO_DEPTH_ERROR,
        msg: exports.ConnectorError.CEX_NO_DEPTH_ERROR,
        code: exports.LoopringErrorCode.CEX_NO_DEPTH_ERROR
      };
    } else {
      // const amountInWei = amountB;
      if (!isReverse) {
        exceedDepth = amountB.gt(toBig(depth.bids_volTotal));
      } else {
        exceedDepth = amountB.gt(toBig(depth.asks_amtTotal));
      }

      if (exceedDepth) {
        sellVol = undefined;
        amountS = undefined;
      } else {
        var _sellVol;

        var outputOrderbook = getOutputOrderbook(input, sellToken, buyToken, feeBips, isAtoB, isReverse, depth);
        sellVol = toBig(toWEI(tokenMap, sell, outputOrderbook)).toString();
        amountS = toBig((_sellVol = sellVol) != null ? _sellVol : 0).times("1e" + sellToken.decimals);
      }
    } // console.log(`b2a(input:${input}) exceedDepth:${exceedDepth} amountB:${amountB}`)

  }

  return {
    feeBips: feeBips,
    info: info,
    isAtoB: isAtoB,
    isReverse: isReverse,
    sellVol: sellVol,
    buyVol: buyVol,
    amountB: (_amountB2 = amountB) == null ? void 0 : _amountB2.toString(),
    amountS: (_amountS = amountS) == null ? void 0 : _amountS.toString(),
    exceedDepth: exceedDepth
  };
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
});

var field = function field() {}; // Fq is the base field of Jubjub

field.SNARK_SCALAR_FIELD = /*#__PURE__*/ethers.BigNumber.from("21888242871839275222246405745257275088548364400416034343698204186575808495617"); // Fr is the scalar field of Jubjub

field.FR_ORDER = /*#__PURE__*/ethers.BigNumber.from("21888242871839275222246405745257275088614511777268538073601725287587578984328"); // A class for field elements in FQ. Wrap a number in this class,
// and it becomes a field element.

var FQ = /*#__PURE__*/function () {
  function FQ(n, field_modulus) {
    if (field_modulus === void 0) {
      field_modulus = field.SNARK_SCALAR_FIELD;
    }

    this.m = field_modulus;
    this.n = n.mod(this.m);
  } //
  // Use this.n as other
  //


  var _proto = FQ.prototype;

  _proto.add = function add(other) {
    var on = other;
    var n = this.n.add(on).mod(this.m);
    return new FQ(n, this.m);
  };

  _proto.mul = function mul(other) {
    var on = other;
    var n = this.n.mul(on).mod(this.m);
    return new FQ(n, this.m);
  };

  _proto.sub = function sub(other) {
    var on = other;
    var new_n;

    if (this.n.gte(on)) {
      new_n = this.n.sub(on).mod(this.m);
    } else {
      new_n = this.n.sub(on).add(this.m).mod(this.m);
    }

    return new FQ(new_n, this.m);
  };

  _proto.div = function div(other) {
    var on_c = other;
    var m_c = this.m;
    var two_c = ethers.BigNumber.from("2");
    var on_power_c = modulo(on_c, m_c.sub(two_c), m_c);
    var n_on_power_remainder = this.n.mul(on_power_c).mod(this.m);
    return new FQ(n_on_power_remainder, this.m);
  };

  FQ.one = function one(modulus) {
    if (modulus === void 0) {
      modulus = field.SNARK_SCALAR_FIELD;
    }

    return new FQ(ethers.BigNumber.from("1"), modulus);
  };

  FQ.zero = function zero(modulus) {
    if (modulus === void 0) {
      modulus = field.SNARK_SCALAR_FIELD;
    }

    return new FQ(ethers.BigNumber.from("0"), modulus);
  };

  return FQ;
}();
function modulo(n, p, m) {
  var n_ = new jsbn.BigInteger(n.toString());
  var p_ = new jsbn.BigInteger(p.toString());
  var m_ = new jsbn.BigInteger(m.toString()); // console.log("modulo", n_.toString(), p_.toString(), m_.toString());

  var result = n_.modPow(p_, m_); // console.log(n_.toString(), p_.toString(), m_.toString(), result.toString())

  return ethers.BigNumber.from(result.toString());
}

/*
This module implements the extended twisted edwards and extended affine coordinates
described in the paper "Twisted Edwards Curves Revisited":

 - https://iacr.org/archive/asiacrypt2008/53500329/53500329.pdf
   Huseyin Hisil, Kenneth Koon-Ho Wong, Gary Carter, and Ed Dawson

        Information Security Institute,
        Queensland University of Technology, QLD, 4000, Australia
        {h.hisil, kk.wong, g.carter, e.dawson}@qut.edu.au

By using the extended coordinate system we can avoid expensive modular exponentiation
calls, for example - a scalar multiplication call (or multiple...) may perform only
one 3d->2d projection at the point where affine coordinates are necessary, and every
intermediate uses a much faster form.

# XXX: none of these functions are constant time, they should not be used interactively!
*/
var jubjub = function jubjub() {};
jubjub.JUBJUB_Q = field.SNARK_SCALAR_FIELD;
jubjub.JUBJUB_E = /*#__PURE__*/ethers.BigNumber.from("21888242871839275222246405745257275088614511777268538073601725287587578984328");
jubjub.JUBJUB_C = /*#__PURE__*/ethers.BigNumber.from("8"); // Cofactor

jubjub.JUBJUB_L = /*#__PURE__*/jubjub.JUBJUB_E.div(jubjub.JUBJUB_C); // L*B = 0, and (2^C)*L == #E

jubjub.JUBJUB_A = /*#__PURE__*/ethers.BigNumber.from("168700"); // Coefficient A

jubjub.JUBJUB_D = /*#__PURE__*/ethers.BigNumber.from("168696"); // Coefficient D

var Point = /*#__PURE__*/function () {
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.generate = function generate() {
    var xBigInt = ethers.BigNumber.from("16540640123574156134436876038791482806971768689494387082833631921987005038935");
    var yBigInt = ethers.BigNumber.from("20819045374670962167435360035096875258406992893633759881276124905556507972311");
    var point = new Point(new FQ(xBigInt), new FQ(yBigInt));
    return point;
  };

  var _proto = Point.prototype;

  _proto.mul = function mul(scaler) {
    var p = new Point(this.x, this.y);
    var a = Point.infinity();

    while (!scaler.eq(ethers.BigNumber.from("0"))) {
      var bitwiseAnd = scaler.and(ethers.BigNumber.from("1"));

      if (!bitwiseAnd.eq(ethers.BigNumber.from("0"))) {
        a = a.add(p);
      }

      var copyP1 = new Point(p.x, p.y);
      var copyP2 = new Point(p.x, p.y);
      p = copyP1.add(copyP2);
      scaler = scaler.div(ethers.BigNumber.from("2")); // console.log(i + " scaler", scaler.toString())
    }

    return a;
  };

  _proto.add = function add(other) {
    if (this.x.n.eq(ethers.BigNumber.from("0")) && this.y.n.eq(ethers.BigNumber.from("0"))) {
      return other;
    }

    var u1 = this.x;
    var v1 = this.y;
    var u2 = other.x;
    var v2 = other.y;
    var u3_tmp0 = u1.mul(v2.n).add(v1.mul(u2.n).n);
    var u3_tmp1 = u1.mul(u2.n).mul(v1.n).mul(v2.n).mul(jubjub.JUBJUB_D);
    var u3_tmp2 = FQ.one().add(u3_tmp1.n);
    var u3 = u3_tmp0.div(u3_tmp2.n);
    var v3_tmp0 = v1.mul(v2.n);
    var v3_tmp1 = u1.mul(u2.n).mul(jubjub.JUBJUB_A);
    var v3_tmp3 = v3_tmp0.sub(v3_tmp1.n);
    var v3_tmp5 = FQ.one().sub(u3_tmp1.n);
    var v3 = v3_tmp3.div(v3_tmp5.n);
    return new Point(u3, v3);
  };

  Point.infinity = function infinity() {
    return new Point(new FQ(ethers.BigNumber.from("0")), new FQ(ethers.BigNumber.from("1")));
  };

  return Point;
}();

/*
 Implements the Poseidon permutation:

 Starkad and Poseidon: New Hash Functions for Zero Knowledge Proof Systems
  - Lorenzo Grassi, Daniel Kales, Dmitry Khovratovich, Arnab Roy, Christian Rechberger, and Markus Schofnegger
  - https://eprint.iacr.org/2019/458.pdf

 Other implementations:

  - https://github.com/shamatar/PoseidonTree/
  - https://github.com/iden3/circomlib/blob/master/src/poseidon.js
  - https://github.com/dusk-network/poseidon252
 */

var blake2b = /*#__PURE__*/require('blake2b');

var PoseidonParams = function PoseidonParams(p, t, nRoundsF, nRoundsP, seed, e, constants_C, constants_M, security_target) {
  this.p = p;
  this.t = t;
  this.nRoundsF = nRoundsF;
  this.nRoundsP = nRoundsP;
  this.seed = seed;
  this.e = e;

  if (constants_C == null) {
    this.constants_C = permunation.poseidon_constants(p, seed + "_constants", nRoundsF + nRoundsP);
  } else {
    this.constants_C = constants_C;
  }

  if (constants_M == null) {
    this.constants_M = permunation.poseidon_matrix(p, seed + "_matrix_0000", t);
  } else {
    this.constants_M = constants_M;
  }

  this.security_target = security_target;
};
var permunation = /*#__PURE__*/function () {
  function permunation() {}

  permunation.H = function H(arg) {
    var outputLength = 32;
    var enc = new webEncoding.TextEncoder();
    var message = enc.encode(arg); // console.log(`message ${message}`)

    var buf = Buffer.alloc(outputLength); // console.log(`hashOfSize32Bytes ${buf.toString()}`)    
    // console.log(`message ${message}`)    

    blake2b(buf.length, null).update(message).final(buf);
    var items = buf.toJSON().data; // console.log(`H items ${items}`)

    var sum = ethers.BigNumber.from("0");
    var i = 0;

    for (var i = 0; i < items.length; i++) {
      var itemBigInt = ethers.BigNumber.from(items[i]);
      var tmp = itemBigInt.mul(ethers.BigNumber.from("256").pow(ethers.BigNumber.from(i)));
      sum = sum.add(tmp);
    } // console.log(`sum ${sum}`)


    return sum;
  };

  permunation.H_Bigint = function H_Bigint(arg) {
    var outputLength = 32;
    var message = new Uint8Array(SignatureScheme.to_bytes(arg)); // console.log(`message ${message}`)

    var buf = Buffer.alloc(outputLength); // console.log(`hashOfSize32Bytes ${buf.toString()}`)    

    blake2b(buf.length, null).update(message).final(buf);
    var items = buf.toJSON().data; // console.log(`H_Bigint items ${items}`)

    var sum = ethers.BigNumber.from("0");
    var i = 0;

    for (var i = 0; i < items.length; i++) {
      var itemBigInt = ethers.BigNumber.from(items[i]);
      var tmp = itemBigInt.mul(ethers.BigNumber.from("256").pow(ethers.BigNumber.from(i)));
      sum = sum.add(tmp);
    } // console.log(`sum ${sum}`)


    return sum;
  };

  permunation.poseidon_constants = function poseidon_constants(p, seed, n) {
    var c;
    c = [];
    var seedBigInt = this.H(seed);
    var result = seedBigInt.mod(p);
    c.push(result);

    for (var i = 0; i < n - 1; i++) {
      seedBigInt = this.H_Bigint(seedBigInt);

      var _result = seedBigInt.mod(p);

      c.push(_result);
    }

    return c;
  };

  permunation.poseidon_matrix = function poseidon_matrix(p, seed, t) {
    var c = this.poseidon_constants(p, seed, t * 2);
    var matrix;
    matrix = [];

    for (var i = 0; i < t; i++) {
      var row = void 0;
      row = [];

      for (var j = 0; j < t; j++) {
        var c_i = c[i];
        var c_t_j = c[t + j];
        var p_c = p;
        var c_t_j_p = c_t_j.mod(p_c);
        var left = c_i.sub(c_t_j_p);
        var p_2 = p_c.sub(2);
        var item_c = modulo(left, p_2, p_c);
        row.push(item_c);
      }

      matrix.push(row);
    }

    return matrix;
  };

  permunation.poseidon_sbox = function poseidon_sbox(state, i, params) {
    /*
    iacr.org/2019/458 § 2.2 The Hades Strategy (pg 6)
         In more details, assume R_F = 2 · R_f is an even number. Then
    - the first R_f rounds have a full S-Box layer,
    - the middle R_P rounds have a partial S-Box layer (i.e., 1 S-Box layer),
    - the last R_f rounds have a full S-Box layer
    */
    var half_F = params.nRoundsF / 2;

    if (i < half_F || i >= half_F + params.nRoundsP) {
      for (var j = 0; j < state.length; j++) {
        var element_c = state[j];
        var e_c = params.e;
        var p_c = params.p;
        var item = modulo(element_c, e_c, p_c);
        state[j] = item;
      }
    } else {
      var _element_c = state[0];
      var _e_c = params.e;
      var _p_c = params.p;

      var _item = modulo(_element_c, _e_c, _p_c);

      state[0] = _item;
    }

    return state;
  };

  permunation.poseidon_mix = function poseidon_mix(state, M, p) {
    /*
    The mixing layer is a matrix vector product of the state with the mixing matrix
      - https://mathinsight.org/matrix_vector_multiplication
    */
    var newState;
    newState = [];

    for (var i = 0; i < M.length; i++) {
      var sum = ethers.BigNumber.from(0);

      for (var j = 0; j < state.length; j++) {
        var element = state[j];
        sum = sum.add(M[i][j].mul(element));
      }

      newState.push(sum.mod(p));
    }

    return newState;
  } // poseidon

  /*
    Main instansiation of the Poseidon permutation
       The state is `t` elements wide, there are `F` full-rounds
    followed by `P` partial rounds, then `F` full rounds again.
           [    ARK    ]    --,
          | | | | | |       |
        [    SBOX   ]       -  Full Round
          | | | | | |       |
        [    MIX    ]    --`
   
        [    ARK    ]    --,
          | | | | | |       |
        [    SBOX   ]       -  Partial Round
                    |       |   Only 1 element is substituted in partial round
        [    MIX    ]    --`
       There are F+P rounds for the full permutation.
       You can provide `r = N - 2s` bits of input per round, where `s` is the desired
    security level, in most cases this means you can provide `t-1` inputs with
    appropriately chosen parameters. The permutation can be 'chained' together
    to form a sponge construct.
  */
  ;

  permunation.poseidon = function poseidon(inputs, params) {
    var state;
    state = [];
    state = state.concat(inputs); // console.log(`state ${state}`)

    for (var i = 0; i < params.t - inputs.length; i++) {
      state.push(ethers.BigNumber.from(0));
    } // console.log(`state ${state}`)
    // console.log(`params.constants_C.length ${params.constants_C.length}`)


    for (var i = 0; i < params.constants_C.length; i++) {
      var C_i = params.constants_C[i];

      for (var index = 0; index < state.length; index++) {
        var element = state[index];
        state[index] = element.add(C_i);
      }

      state = this.poseidon_sbox(state, i, params); // console.log(`after poseidon_sbox ${state}`)

      state = this.poseidon_mix(state, params.constants_M, params.p); // console.log(`after poseidon_mix ${state}`)
    } // console.log(`hash is ${state[0]}`)


    return state[0];
  };

  return permunation;
}();

/*
Implements Pure-EdDSA and Hash-EdDSA

The signer has two secret values:

    * k = Secret key
    * r = Per-(message,key) nonce

The signer provides a signature consiting of two values:

    * R = Point, image of `r*B`
    * s = Image of `r + (k*t)`

The signer provides the verifier with their public key:

    * A = k*B

Both the verifier and the signer calculate the common reference string:

    * t = H(R, A, M)

The nonce `r` is secret, and protects the value `s` from revealing the
signers secret key.

For Hash-EdDSA, the message `M` is compressed before H(R,A,M)

For further information see: https://ed2519.cr.yp.to/eddsa-20150704.pdf
*/
var Signature = /*#__PURE__*/function () {
  function Signature(R, s) {
    this.R = R;
    this.s = s;
  }

  var _proto = Signature.prototype;

  _proto.toStr = function toStr() {
    return this.R.x.n + " " + this.R.y.n + " " + this.s.n;
  };

  return Signature;
}();
var SignedMessage = /*#__PURE__*/function () {
  function SignedMessage(A, sig, msg) {
    this.A = A;
    this.sig = sig;
    this.msg = msg;
  }

  var _proto2 = SignedMessage.prototype;

  _proto2.toStr = function toStr() {
    return this.A.x.n + " " + this.A.y.n + " " + this.sig.toStr() + " " + this.msg.toString();
  };

  return SignedMessage;
}();
var SignatureScheme = /*#__PURE__*/function () {
  function SignatureScheme() {}

  SignatureScheme.to_bytes = function to_bytes(arg) {
    var outputLength = 32; // console.log(`input ${arg.toString()}`)

    var bitIntDataItems = bnToBuf(arg.toString()); // console.log(`bigIntData ${bitIntDataItems}`)

    var more = outputLength - bitIntDataItems.length; // console.log('more', more)

    if (more > 0) {
      for (var i = 0; i < more; i++) {
        bitIntDataItems = [0].concat(bitIntDataItems);
      }
    } else {
      bitIntDataItems = bitIntDataItems.slice(0, outputLength);
    }

    bitIntDataItems = bitIntDataItems.reverse(); // console.log(`bigIntData return ${bitIntDataItems}`)

    return bitIntDataItems;
  }
  /*
  Identity function for message
     Can be used to truncate the message before hashing it
  as part of the public parameters.
  */
  ;

  SignatureScheme.prehash_message = function prehash_message(M) {
    return M;
  }
  /*
  Hash the key and message to create `r`, the blinding factor for this signature.
     If the same `r` value is used more than once, the key for the signature is revealed.
     From: https://eprint.iacr.org/2015/677.pdf (EdDSA for more curves)
     Page 3:
         (Implementation detail: To save time in the computation of `rB`, the signer
      can replace `r` with `r mod L` before computing `rB`.)
  */
  ;

  SignatureScheme.hash_secret_python = function hash_secret_python(k, arg) {
    var byteArray0 = this.to_bytes(k.n);
    var byteArray1 = this.to_bytes(arg);
    var sum = byteArray0.concat(byteArray1); // console.log("sum", sum)
    // let byteArrayHexStr = bytesToHexString(sum)
    // console.log("byteArrayHexStr", byteArrayHexStr)

    var digest1 = jsSha512.sha512.array(new Uint8Array(sum).buffer); // let digest1 = createHash('sha512').update .digest("SHA-512", new Uint8Array(sum).buffer)

    var sha512StrItems; // console.log('digest1', digest1);

    for (var i = 0; i < digest1.length; i++) {
      var itemInt = digest1[i];
      var st = itemInt.toString(16);

      if (st.length == 1) {
        st = "0" + st;
      }

      sha512StrItems = [st].concat(sha512StrItems);
    }

    var sha512MessageHexStr = sha512StrItems.join(""); // console.log(`sha512MessageHexStr ${sha512MessageHexStr}`)

    var sha512MessageHexStrBigInt = ethers.BigNumber.from("0x" + sha512MessageHexStr); // console.log(`sha512MessageHexStrBigInt ${sha512MessageHexStrBigInt}`)

    var hashed = sha512MessageHexStrBigInt.mod(jubjub.JUBJUB_L); // console.log(`hashed ${hashed.toString()}`)

    return hashed;
  };

  SignatureScheme.B = function B() {
    return Point.generate();
  };

  SignatureScheme.sign = function sign(msg, key, B) {
    // console.log("B ", B.x.n.toString(), B.y.n.toString())
    var copyKey = new FQ(key.n, key.m);
    var A = B.mul(copyKey.n); // console.log("A.x ", A.x.n.toString(), A.x.m.toString())
    // console.log("A.y ", B.y.n.toString(), A.y.m.toString())

    var M = this.prehash_message(msg); // console.log("M ", M.toString())

    var r = this.hash_secret_python(key, M); // console.log("r ", r.toString())

    var copy_r = ethers.BigNumber.from(r.toString());
    var R = B.mul(copy_r); // console.log("R.x ", R.x.n.toString(), R.x.m.toString())
    // console.log("R.y ", R.y.n.toString(), R.y.m.toString())

    var t = this.hash_public(R, A, M); // console.log("hello world")
    // console.log("t ", t.toString())

    var t_c = t;
    var key_n_t = key.n.mul(t_c);
    var left = r.add(key_n_t);
    var S = left.mod(jubjub.JUBJUB_E); // console.log("S ", S.toString())

    var signatureResult = new Signature(R, new FQ(S)); // console.log("signatureResult", signatureResult.toStr())

    var signedMessage = new SignedMessage(A, signatureResult, msg); // console.log("signedMessage", signedMessage.toStr())

    return signedMessage;
  };

  SignatureScheme.as_scalar = function as_scalar(point) {
    // console.log(`as_scalar ${point.x.n.toString()}`)
    return [point.x.n, point.y.n];
  };

  SignatureScheme.hash_public = function hash_public(R, A, M) {
    var inputMsg;
    inputMsg = this.as_scalar(R).concat(this.as_scalar(A)).concat([M]); // console.log(`inputMsg ${inputMsg}`)

    var params = new PoseidonParams(field.SNARK_SCALAR_FIELD, 6, 6, 52, "poseidon", ethers.BigNumber.from(5), null, null, 128);
    var result = permunation.poseidon(inputMsg, params);
    return result;
  };

  return SignatureScheme;
}();
function bnToBuf(bn) {
  var hex = BigInt(bn).toString(16);

  if (hex.length % 2) {
    hex = "0" + hex;
  }

  var len = hex.length / 2; // console.log("length", len);

  var u8 = new Uint8Array(len);
  var i = 0;
  var j = 0;

  while (i < len) {
    u8[i] = parseInt(hex.slice(j, j + 2), 16);
    i += 1;
    j += 2;
  }

  return Array.from(u8);
}
function bnToBufWithFixedLength(bn, outputLength) {
  var hex = BigInt(bn).toString(16);

  if (hex.length % 2) {
    hex = "0" + hex;
  }

  var len = hex.length / 2; // console.log("len", len);

  var u8 = new Uint8Array(len);
  var i = 0;
  var j = 0;

  while (i < len) {
    u8[i] = parseInt(hex.slice(j, j + 2), 16);
    i += 1;
    j += 2;
  }

  var bitIntDataItems = Array.from(u8);
  var more = outputLength - bitIntDataItems.length; // console.log('diff len', more)

  if (more > 0) {
    for (var _i = 0; _i < more; _i++) {
      bitIntDataItems = [0].concat(bitIntDataItems);
    }
  } else {
    bitIntDataItems = bitIntDataItems.slice(0, outputLength);
  }

  return bitIntDataItems;
}
function bytesToHexString(bytes) {
  var strItems;
  strItems = [];

  for (var i = 0; i < bytes.length; i++) {
    var item = bytes[i];
    var st = item.toString(16);

    if (st.length == 1) {
      st = "0" + st;
    } // st = st.toUpperCase()


    strItems.push(st);
  }

  var strItemsJoined = strItems.join("");
  return strItemsJoined;
}

var babyJub = /*#__PURE__*/function () {
  function babyJub() {}

  babyJub.packPoint = function packPoint(P0, P1) {
    var packed = SignatureScheme.to_bytes(P1).reverse(); // console.log("packed", packed)

    if (babyJub.lt(P0, ethers.BigNumber.from("0"))) {
      // console.log("Update .... lt ")
      packed[0] = packed[0] | 0x80;
    }

    var hexStr = bytesToHexString(packed); // console.log("hexStr", hexStr)

    return hexStr;
  };

  babyJub.lt = function lt(a, b) {
    var half = field.SNARK_SCALAR_FIELD.div(ethers.BigNumber.from("2"));
    var p = field.SNARK_SCALAR_FIELD;
    var aa;
    var bb;

    if (a.gt(half)) {
      aa = a.sub(p);
    } else {
      aa = a;
    }

    if (b.gt(half)) {
      bb = b.sub(p);
    } else {
      bb = b;
    } // console.log("lt", a.toString(), b.toString(), aa.toString(), bb.toString());


    return aa.lt(bb);
  };

  babyJub.gt = function gt(a, b) {
    var half = field.SNARK_SCALAR_FIELD.div(ethers.BigNumber.from("2"));
    var p = field.SNARK_SCALAR_FIELD;
    var aa;
    var bb;

    if (a.gt(half)) {
      aa = a.sub(p);
    } else {
      aa = a;
    }

    if (b.gt(half)) {
      bb = b.sub(p);
    } else {
      bb = b;
    } // console.log("gt", a.toString(), b.toString(), aa.toString(), bb.toString());


    return aa.gt(bb);
  };

  return babyJub;
}();

var EDDSAUtil = /*#__PURE__*/function () {
  function EDDSAUtil() {}

  EDDSAUtil.sign = function sign(PrivateKey, hash) {
    var strKey = ethers.BigNumber.from(PrivateKey);
    var msg = ethers.BigNumber.from(hash); // console.log("strKey", strKey.toString())
    // console.log("msg", msg.toString())

    var copyKey = new FQ(strKey);
    var B = SignatureScheme.B();
    var signed = SignatureScheme.sign(msg, copyKey, B); // console.log("signed", signed.toStr())

    var x = EDDSAUtil.formatted(signed.sig.R.x.n.toHexString().slice(2));
    var y = EDDSAUtil.formatted(signed.sig.R.y.n.toHexString().slice(2));
    var s = EDDSAUtil.formatted(signed.sig.s.n.toHexString().slice(2));

    return {
      "Rx": signed.sig.R.x.n.toString(),
      "Ry": signed.sig.R.y.n.toString(),
      "s": signed.sig.s.n.toString()
    };
  };

  EDDSAUtil.formatted = function formatted(hexString) {
    var outputLength = 32 * 2;
    var more = outputLength - hexString.length;

    if (more > 0) {
      for (var i = 0; i < more; i++) {
        hexString = "0" + hexString;
      }
    } else {
      hexString = hexString.slice(0, outputLength);
    }

    return hexString;
  };

  EDDSAUtil.generateKeyPair = function generateKeyPair(seed) {
    var bigInt = ethers.BigNumber.from(0);

    for (var i = 0; i < seed.length; i++) {
      var item = seed[i];
      var itemBigInt = ethers.BigNumber.from(item);
      var tmp = ethers.BigNumber.from("256").pow(ethers.BigNumber.from(i));
      bigInt = bigInt.add(itemBigInt.mul(tmp));
    } // console.log("sum", bigInt.toString())


    var secretKey = bigInt.mod(jubjub.JUBJUB_L); // console.log("secretKey", secretKey.toString())

    var copySecretKey = ethers.BigNumber.from(secretKey.toString()); // console.log("copySecretKey", copySecretKey.toString())

    var B = SignatureScheme.B(); // console.log("B", B.toString())

    var publicKey = B.mul(copySecretKey); // console.log("publicKey", publicKey.x.n.toString(), publicKey.y.n.toString())

    var keyPair = {
      "publicKeyX": publicKey.x.n.toString(),
      "publicKeyY": publicKey.y.n.toString(),
      "secretKey": secretKey.toString()
    };
    return keyPair;
  };

  EDDSAUtil.pack = function pack(publicKeyX, publicKeyY) {
    var P0 = ethers.BigNumber.from(publicKeyX);
    var P1 = ethers.BigNumber.from(publicKeyY);
    var newPack = babyJub.packPoint(P0, P1);
    return newPack;
  };

  return EDDSAUtil;
}();

(function (GetEcDSASigType) {
  GetEcDSASigType[GetEcDSASigType["HasDataStruct"] = 0] = "HasDataStruct";
  GetEcDSASigType[GetEcDSASigType["WithoutDataStruct"] = 1] = "WithoutDataStruct";
  GetEcDSASigType[GetEcDSASigType["Contract"] = 2] = "Contract";
})(exports.GetEcDSASigType || (exports.GetEcDSASigType = {}));

var MIN_NFT_TOKENID = 32768;
var SNARK_SCALAR_FIELD = /*#__PURE__*/new BigNumber("21888242871839275222246405745257275088548364400416034343698204186575808495617", 10);
function generatePrivateKey(result) {
  if (!result.error) {
    // myLog("sig:", result.sig);
    var seedBuff = ethUtil.sha256(toBuffer(result.sig)); // myLog(`seedBuff.toString('hex') ${seedBuff.toString('hex')}`)

    var seed = ethers.BigNumber.from("0x" + seedBuff.toString("hex")); // myLog(`seed ${seed.toString()}`)

    var bitIntDataItems = bnToBufWithFixedLength(seed.toString(), 32); // myLog(`bigIntData ${bitIntDataItems}`)

    var keyPair = EDDSAUtil.generateKeyPair(bitIntDataItems); // myLog("keyPair", keyPair)

    var formatedPx = formatEddsaKey(toHex(toBig(keyPair.publicKeyX)));
    var formatedPy = formatEddsaKey(toHex(toBig(keyPair.publicKeyY)));
    var sk = toHex(toBig(keyPair.secretKey));
    return {
      keyPair: keyPair,
      formatedPx: formatedPx,
      formatedPy: formatedPy,
      sk: sk,
      counterFactualInfo: result.counterFactualInfo
    };
  } else {
    console.log("generateKeyPair personalSign error", result.error);
    throw Error(result.error);
  }
}
function generateKeyPair(_x, _x2) {
  return _generateKeyPair.apply(this, arguments);
}

function _generateKeyPair() {
  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(_ref, publicKey) {
    var web3, address, walletType, keySeed, chainId, accountId, counterFactualInfo, isMobile, result, _generatePrivateKey, keyPair, formatedPx, formatedPy, sk, _counterFactualInfo, value, end, newValue;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            web3 = _ref.web3, address = _ref.address, walletType = _ref.walletType, keySeed = _ref.keySeed, chainId = _ref.chainId, accountId = _ref.accountId, counterFactualInfo = _ref.counterFactualInfo, isMobile = _ref.isMobile;

            if (publicKey === void 0) {
              publicKey = undefined;
            }

            _context.next = 4;
            return personalSign(web3, address, "", keySeed, walletType, chainId, accountId, counterFactualInfo, isMobile === undefined ? IsMobile.any() : isMobile);

          case 4:
            result = _context.sent;
            _context.prev = 5;
            _generatePrivateKey = generatePrivateKey(result), keyPair = _generatePrivateKey.keyPair, formatedPx = _generatePrivateKey.formatedPx, formatedPy = _generatePrivateKey.formatedPy, sk = _generatePrivateKey.sk, _counterFactualInfo = _generatePrivateKey.counterFactualInfo;

            if (!(publicKey && result.sig.length > 3 && publicKey.x && publicKey.y && (!toBig(formatedPx).eq(toBig(publicKey.x)) || !toBig(formatedPy).eq(toBig(publicKey.y))))) {
              _context.next = 17;
              break;
            }

            value = result.sig.split("");
            end = value.splice(result.sig.length - 2, 2).join("");
            end = end == "1c" ? "01" : "1c";
            result.sig = value.concat(end.split("")).join("");
            newValue = generatePrivateKey(result); // LOG: for signature

            console.log("personalSign ->", "publicKey calc by sign", "x", formatedPx, "y", formatedPy, "publicKey from server", publicKey, "personalSign again->", "publicKey calc by sign", "x", end, newValue.formatedPx, "y", newValue.formatedPy);
            return _context.abrupt("return", {
              keyPair: newValue.keyPair,
              formatedPx: newValue.formatedPx,
              formatedPy: newValue.formatedPy,
              sk: newValue.sk,
              counterFactualInfo: _counterFactualInfo
            });

          case 17:
            return _context.abrupt("return", {
              keyPair: keyPair,
              formatedPx: formatedPx,
              formatedPy: formatedPy,
              sk: sk,
              counterFactualInfo: _counterFactualInfo
            });

          case 18:
            _context.next = 23;
            break;

          case 20:
            _context.prev = 20;
            _context.t0 = _context["catch"](5);
            throw Error(_context.t0);

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 20]]);
  }));
  return _generateKeyPair.apply(this, arguments);
}

var makeRequestParamStr = function makeRequestParamStr(request) {
  var arrObj = Array.from(request);
  arrObj.sort(function (a, b) {
    return a[0].localeCompare(b[0]);
  });
  var orderedMap = new Map(arrObj.map(function (i) {
    return [i[0], i[1]];
  }));
  var paramlist = [];
  var keys = Object.keys(Object.fromEntries(orderedMap));

  if (keys) {
    keys.forEach(function (key) {
      var value = request.get(key);
      if (value !== undefined && value !== "") paramlist.push(key + "=" + value);
    });
  } // force to change encode ',' due to different encode rules between server and client


  return encodeURIComponent(paramlist.join("&")).replace(/%2C/g, "%252C");
}; //submitOrderV3


var genSigWithPadding = function genSigWithPadding(PrivateKey, hash) {
  var signature = EDDSAUtil.sign(PrivateKey, hash);
  var signatureRx_Hex = clearHexPrefix(toHex(toBN(signature.Rx)));

  if (signatureRx_Hex.length < 64) {
    var padding = new Array(64 - signatureRx_Hex.length).fill(0);
    signatureRx_Hex = padding.join("").toString() + signatureRx_Hex;
  }

  var signatureRy_Hex = clearHexPrefix(toHex(toBN(signature.Ry)));

  if (signatureRy_Hex.length < 64) {
    var _padding = new Array(64 - signatureRy_Hex.length).fill(0);

    signatureRy_Hex = _padding.join("").toString() + signatureRy_Hex;
  }

  var signatureS_Hex = clearHexPrefix(toHex(toBN(signature.s)));

  if (signatureS_Hex.length < 64) {
    var _padding2 = new Array(64 - signatureS_Hex.length).fill(0);

    signatureS_Hex = _padding2.join("").toString() + signatureS_Hex;
  }

  var result = "0x" + signatureRx_Hex + signatureRy_Hex + signatureS_Hex; // myLog("signature result", result)

  return result;
};

var makeObjectStr = function makeObjectStr(request) {
  var jsonTxt = JSON.stringify(Object.fromEntries(request));
  return encodeURIComponent(jsonTxt).replace(/[!'()]/g, escape); //replace(/'/ig, "%27")
};

function getEdDSASig(method, basePath, api_url, requestInfo, PrivateKey) {
  var params = undefined;
  method = method.toUpperCase().trim();

  if (method === "GET" || method === "DELETE") {
    params = makeRequestParamStr(requestInfo);
  } else if (method === "POST" || method === "PUT") {
    params = makeObjectStr(requestInfo);
  } else {
    throw new Error(method + " is not supported yet!");
  }

  var uri = encodeURIComponent("" + basePath + api_url);
  var message = method + "&" + uri + "&" + params; // LOG: for signature

  myLog("getEdDSASig", message);

  var _hash = new BigNumber(sha256(message).toString(), 16);

  var hash = _hash.mod(SNARK_SCALAR_FIELD).toFormat(0, 0, {}); // LOG: for signature


  myLog("getEdDSASig hash", message, "_hash", _hash, "hash", hash);
  var sig = genSigWithPadding(PrivateKey, hash);
  return sig;
}
function verifyEdDSASig(hash, input) {
  return true;
}
var getEdDSASigWithPoseidon = function getEdDSASigWithPoseidon(inputs, PrivateKey) {
  var p = field.SNARK_SCALAR_FIELD;
  var poseidonParams = new PoseidonParams(p, inputs.length + 1, 6, 53, "poseidon", ethers.BigNumber.from(5), null, null, 128);
  var bigIntInputs;
  bigIntInputs = [];

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    bigIntInputs.push(ethers.BigNumber.from(input));
  }

  var hash = permunation.poseidon(bigIntInputs, poseidonParams); // myLog("getEdDSASigWithPoseidon", hash.toHexString(), bigIntInputs);

  return {
    hash: hash,
    result: genSigWithPadding(PrivateKey, hash)
  };
};
/**
 * @description sign EIP712
 * @param web3
 * @param account
 * @param method
 * @param params
 * @returns {Promise.<*>}
 */

function signEip712(_x3, _x4, _x5, _x6) {
  return _signEip.apply(this, arguments);
}

function _signEip() {
  _signEip = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(web3, account, method, params) {
    var response;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new Promise(function (resolve) {
              var _web3$currentProvider;

              (_web3$currentProvider = web3.currentProvider) == null ? void 0 : _web3$currentProvider.sendAsync({
                method: method,
                params: params,
                account: account
              }, function (err, result) {
                if (err) {
                  resolve({
                    error: {
                      message: err.message
                    }
                  });
                  return;
                }

                if (result.error) {
                  resolve({
                    error: {
                      message: result.error.message
                    }
                  });
                  return;
                }

                resolve({
                  result: result.result
                });
              });
            });

          case 2:
            response = _context2.sent;

            if (!response["result"]) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", response);

          case 7:
            throw new Error(response["error"]["message"]);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _signEip.apply(this, arguments);
}

function signEip712WalletConnect(_x7, _x8, _x9) {
  return _signEip712WalletConnect.apply(this, arguments);
}

function _signEip712WalletConnect() {
  _signEip712WalletConnect = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(web3, account, typedData) {
    var _web3$currentProvider2, response;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return (_web3$currentProvider2 = web3.currentProvider) == null ? void 0 : _web3$currentProvider2.send("eth_signTypedData", [account, typedData]);

          case 3:
            response = _context3.sent;
            return _context3.abrupt("return", response);

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", {
              error: _context3.t0
            });

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 7]]);
  }));
  return _signEip712WalletConnect.apply(this, arguments);
}

function getEcDSASig(_x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18) {
  return _getEcDSASig.apply(this, arguments);
}

function _getEcDSASig() {
  _getEcDSASig = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(web3, typedData, address, type, chainId, accountId, pwd, walletType, counterFactualInfo) {
    var _signature;

    var msgParams, params, response, hash, signEip712Result, signature;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (pwd === void 0) {
              pwd = "";
            }

            msgParams = JSON.stringify(typedData);
            params = [address, msgParams];
            _context4.t0 = type;
            _context4.next = _context4.t0 === exports.GetEcDSASigType.HasDataStruct ? 6 : _context4.t0 === exports.GetEcDSASigType.WithoutDataStruct ? 12 : _context4.t0 === exports.GetEcDSASigType.Contract ? 22 : 31;
            break;

          case 6:
            _context4.next = 8;
            return new Promise(function (resolve) {
              web3.currentProvider.send({
                method: "eth_signTypedData_v4",
                params: params,
                address: address
              }, function (err, result) {
                if (err) {
                  resolve({
                    error: {
                      message: err.message
                    }
                  });
                } else if (result != null && result.error) {
                  resolve({
                    error: {
                      message: result.error.message
                    }
                  });
                } else {
                  resolve({
                    result: result.result
                  });
                }
              });
            });

          case 8:
            response = _context4.sent;

            if (response["result"]) {
              _context4.next = 11;
              break;
            }

            throw new Error(response["error"]["message"]);

          case 11:
            return _context4.abrupt("return", {
              ecdsaSig: response.result
            });

          case 12:
            hash = sigUtil.TypedDataUtils.sign(typedData);
            hash = toHex(hash); // myLog('WithoutDataStruct hash:', hash)

            if (walletType) {
              _context4.next = 16;
              break;
            }

            throw Error("no walletType set!");

          case 16:
            _context4.next = 18;
            return personalSign(web3, address, pwd, hash, walletType, chainId, counterFactualInfo ? counterFactualInfo.accountId : undefined, counterFactualInfo, IsMobile.any());

          case 18:
            signature = _context4.sent;

            if (!((_signature = signature) != null && _signature.sig)) {
              _context4.next = 21;
              break;
            }

            return _context4.abrupt("return", {
              ecdsaSig: signature.sig,
              counterFactualInfo: signature.counterFactualInfo
            });

          case 21:
            throw new Error(signature.error);

          case 22:
            // TODO:
            hash = sigUtil.TypedDataUtils.sign(typedData);
            hash = toHex(hash);
            myLog("Contract Contract hash", hash);
            _context4.next = 27;
            return signEip712WalletConnect(web3, address, msgParams);

          case 27:
            signEip712Result = _context4.sent;

            if (!signEip712Result.error) {
              _context4.next = 30;
              break;
            }

            throw Error("Contract sig error");

          case 30:
            return _context4.abrupt("return", {
              ecdsaSig: signEip712Result
            });

          case 31:
            return _context4.abrupt("break", 32);

          case 32:
            throw Error("getEcDSASig unsupported switch case:" + type);

          case 33:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getEcDSASig.apply(this, arguments);
}

function convertPublicKey2(pk) {
  // return new BN(EdDSA.pack(pk.x, pk.y), 16);
  return new BN(EDDSAUtil.pack(pk.x, pk.y), 16);
}
function convertPublicKey(pk) {
  var publicKeyX = formatEddsaKey(toHex(toBig(pk.x)));
  var publicKeyY = formatEddsaKey(toHex(toBig(pk.y))); // return new BN(EdDSA.pack(publicKeyX, publicKeyY), 16);

  return new BN(EDDSAUtil.pack(publicKeyX, publicKeyY), 16);
}
function getUpdateAccountEcdsaTypedData(data, chainId) {
  var message = {
    owner: data.owner,
    accountID: data.accountId,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.volume,
    publicKey: addHexPrefix(convertPublicKey2(data.publicKey).toString(16)),
    validUntil: data.validUntil,
    nonce: data.nonce
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      AccountUpdate: [{
        name: "owner",
        type: "address"
      }, {
        name: "accountID",
        type: "uint32"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "publicKey",
        type: "uint256"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "nonce",
        type: "uint32"
      }]
    },
    primaryType: "AccountUpdate",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function signUpdateAccountWithDataStructure(_x19, _x20, _x21, _x22, _x23, _x24) {
  return _signUpdateAccountWithDataStructure.apply(this, arguments);
}

function _signUpdateAccountWithDataStructure() {
  _signUpdateAccountWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(web3, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            typedData = getUpdateAccountEcdsaTypedData(bodyParams, chainId); // myLog('typedData:', typedData)

            _context5.next = 3;
            return getEcDSASig(web3, typedData, bodyParams.owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context5.sent;
            return _context5.abrupt("return", result);

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _signUpdateAccountWithDataStructure.apply(this, arguments);
}

function signUpdateAccountWithoutDataStructure(_x25, _x26, _x27, _x28, _x29, _x30) {
  return _signUpdateAccountWithoutDataStructure.apply(this, arguments);
}

function _signUpdateAccountWithoutDataStructure() {
  _signUpdateAccountWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(web3, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            typedData = getUpdateAccountEcdsaTypedData(bodyParams, chainId);
            _context6.next = 3;
            return getEcDSASig(web3, typedData, bodyParams.owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context6.sent;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _signUpdateAccountWithoutDataStructure.apply(this, arguments);
}

function signUpdateAccountWithDataStructureForContract(_x31, _x32, _x33, _x34, _x35) {
  return _signUpdateAccountWithDataStructureForContract.apply(this, arguments);
} // withdraw

function _signUpdateAccountWithDataStructureForContract() {
  _signUpdateAccountWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(web3, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            typedData = getUpdateAccountEcdsaTypedData(bodyParams, chainId);
            _context7.next = 3;
            return getEcDSASig(web3, typedData, bodyParams.owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context7.sent;
            return _context7.abrupt("return", result);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _signUpdateAccountWithDataStructureForContract.apply(this, arguments);
}

function get_EddsaSig_OffChainWithdraw(request, eddsaKey) {
  var onchainDataHash = abi.soliditySHA3(["uint256", "address", "bytes"], [request.minGas, new BN(clearHexPrefix(request.to), 16), ethUtil.toBuffer(request.extraData)]).slice(0, 20);
  var orderHashStr = addHexPrefix(onchainDataHash.toString("hex"));
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.accountId, request.token.tokenId, request.token.volume, request.maxFee.tokenId, request.maxFee.volume, orderHashStr, request.validUntil, request.storageId];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function getOrderHash(request) {
  var p = field.SNARK_SCALAR_FIELD;
  var poseidonParams = new PoseidonParams(p, 12, 6, 53, "poseidon", ethers.BigNumber.from(5), null, null, 128);
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.storageId, request.accountId, request.sellToken.tokenId, request.buyToken.tokenId, request.sellToken.volume, request.buyToken.volume, request.validUntil, request.maxFeeBips, request.fillAmountBOrS ? 1 : 0, new BN(ethUtil.toBuffer(request.taker)).toString()];
  var bigIntInputs;
  bigIntInputs = [];

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    bigIntInputs.push(ethers.BigNumber.from(input));
  }

  var hash = permunation.poseidon(bigIntInputs, poseidonParams);
  var hashInHex = hash.toHexString();
  return hashInHex;
}
function getWithdrawTypedData(data, chainId) {
  var message = {
    owner: data.owner,
    accountID: data.accountId,
    tokenID: data.token.tokenId,
    amount: data.token.volume,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.volume,
    to: data.to,
    extraData: data.extraData ? data.extraData : "",
    minGas: data.minGas,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Withdrawal: [{
        name: "owner",
        type: "address"
      }, {
        name: "accountID",
        type: "uint32"
      }, {
        name: "tokenID",
        type: "uint16"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "to",
        type: "address"
      }, {
        name: "extraData",
        type: "bytes"
      }, {
        name: "minGas",
        type: "uint256"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Withdrawal",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function signOffchainWithdrawWithDataStructure(_x36, _x37, _x38, _x39, _x40, _x41) {
  return _signOffchainWithdrawWithDataStructure.apply(this, arguments);
}

function _signOffchainWithdrawWithDataStructure() {
  _signOffchainWithdrawWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            typedData = getWithdrawTypedData(bodyParams, chainId);
            _context8.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context8.sent;
            return _context8.abrupt("return", result);

          case 5:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _signOffchainWithdrawWithDataStructure.apply(this, arguments);
}

function signOffchainWithdrawWithoutDataStructure(_x42, _x43, _x44, _x45, _x46, _x47, _x48) {
  return _signOffchainWithdrawWithoutDataStructure.apply(this, arguments);
}

function _signOffchainWithdrawWithoutDataStructure() {
  _signOffchainWithdrawWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            typedData = getWithdrawTypedData(bodyParams, chainId);
            _context9.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context9.sent;
            return _context9.abrupt("return", result);

          case 5:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _signOffchainWithdrawWithoutDataStructure.apply(this, arguments);
}

function signOffchainWithdrawWithDataStructureForContract(_x49, _x50, _x51, _x52, _x53, _x54) {
  return _signOffchainWithdrawWithDataStructureForContract.apply(this, arguments);
} //NFT Withdraw

function _signOffchainWithdrawWithDataStructureForContract() {
  _signOffchainWithdrawWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            typedData = getWithdrawTypedData(bodyParams, chainId);
            _context10.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context10.sent;
            return _context10.abrupt("return", result);

          case 5:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _signOffchainWithdrawWithDataStructureForContract.apply(this, arguments);
}

function get_EddsaSig_NFT_Withdraw(request, eddsaKey) {
  var onchainDataHash = abi.soliditySHA3(["uint256", "address", "bytes"], [request.minGas, new BN(clearHexPrefix(request.to), 16), ethUtil.toBuffer(request.extraData)]).slice(0, 20);
  var orderHashStr = addHexPrefix(onchainDataHash.toString("hex"));
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.accountId, request.token.tokenId, request.token.amount, request.maxFee.tokenId, request.maxFee.amount, orderHashStr, request.validUntil, request.storageId];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function getNftData(request) {
  var p = field.SNARK_SCALAR_FIELD;
  var poseidonParams = new PoseidonParams(p, 7, 6, 52, "poseidon", ethers.BigNumber.from(5), null, null, 128);
  var idNo0x = clearHexPrefix(request.nftId);
  var nftIdLo, nftIdHi;

  if (idNo0x.length > 32) {
    nftIdLo = new BN(idNo0x.substr(idNo0x.length - 32, 32), 16).toString(10);
    nftIdHi = new BN(idNo0x.substr(0, idNo0x.length - 32), 16).toString(10);
  } else {
    nftIdLo = new BN(idNo0x.substr(0, idNo0x.length), 16).toString(10);
    nftIdHi = 0;
  }

  myLog("nftIdLo", nftIdLo, "nftIdHi", nftIdHi);
  var inputs = [request.minterAddress, request.nftType, request.tokenAddress, nftIdLo, nftIdHi, request.royaltyPercentage];
  var bigIntInputs;
  bigIntInputs = [];

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    bigIntInputs.push(ethers.BigNumber.from(input));
  }

  var hash = permunation.poseidon(bigIntInputs, poseidonParams); // myLog("get hasher *16 hash:", hash);

  return hash;
}
function getNFTMintTypedData(data, chainId, web3) {
  var nftId = data.nftId;

  if (data.nftId.startsWith("0x")) {
    nftId = web3.utils.hexToNumberString(data.nftId);
  }

  var message = {
    minterAddress: data.minterAddress,
    toAccountId: data.toAccountId,
    nftType: data.nftType.toString(),
    amount: data.amount,
    nftId: nftId,
    nftAddress: data.tokenAddress,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.amount,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Mint: [{
        name: "minterAddress",
        type: "address"
      }, {
        name: "toAccountId",
        type: "uint32"
      }, {
        name: "nftType",
        type: "string"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "nftId",
        type: "uint256"
      }, {
        name: "nftAddress",
        type: "address"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Mint",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function getNFTWithdrawTypedData(data, chainId) {
  var message = {
    owner: data.owner,
    accountID: data.accountId,
    tokenID: data.token.tokenId,
    amount: data.token.amount,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.amount,
    to: data.to,
    extraData: data.extraData ? data.extraData : "",
    minGas: data.minGas,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Withdrawal: [{
        name: "owner",
        type: "address"
      }, {
        name: "accountID",
        type: "uint32"
      }, {
        name: "tokenID",
        type: "uint16"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "to",
        type: "address"
      }, {
        name: "extraData",
        type: "bytes"
      }, {
        name: "minGas",
        type: "uint256"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Withdrawal",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function signNFTWithdrawWithDataStructure(_x55, _x56, _x57, _x58, _x59, _x60, _x61) {
  return _signNFTWithdrawWithDataStructure.apply(this, arguments);
}

function _signNFTWithdrawWithDataStructure() {
  _signNFTWithdrawWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            typedData = getNFTWithdrawTypedData(bodyParams, chainId);
            _context11.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context11.sent;
            return _context11.abrupt("return", result);

          case 5:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _signNFTWithdrawWithDataStructure.apply(this, arguments);
}

function signNFTWithdrawWithoutDataStructure(_x62, _x63, _x64, _x65, _x66, _x67, _x68) {
  return _signNFTWithdrawWithoutDataStructure.apply(this, arguments);
}

function _signNFTWithdrawWithoutDataStructure() {
  _signNFTWithdrawWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            typedData = getNFTWithdrawTypedData(bodyParams, chainId);
            _context12.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context12.sent;
            return _context12.abrupt("return", result);

          case 5:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _signNFTWithdrawWithoutDataStructure.apply(this, arguments);
}

function signNFTWithdrawWithDataStructureForContract(_x69, _x70, _x71, _x72, _x73, _x74) {
  return _signNFTWithdrawWithDataStructureForContract.apply(this, arguments);
} //NFT Mint

function _signNFTWithdrawWithDataStructureForContract() {
  _signNFTWithdrawWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            typedData = getNFTWithdrawTypedData(bodyParams, chainId);
            _context13.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context13.sent;
            return _context13.abrupt("return", result);

          case 5:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));
  return _signNFTWithdrawWithDataStructureForContract.apply(this, arguments);
}

function get_EddsaSig_NFT_Mint(request, eddsaKey) {
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.minterId, request.toAccountId, getNftData(request), request.amount, request.maxFee.tokenId, request.maxFee.amount, request.validUntil, request.storageId];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function get_Is_Nft_Token(tokenId) {
  return tokenId >= MIN_NFT_TOKENID;
} // NFT Order

function get_EddsaSig_NFT_Order(request, eddsaKey) {
  var _request$sellToken, _request$buyToken, _request$sellToken2, _request$buyToken2;

  var fillAmountBOrS = 0;

  if (request.fillAmountBOrS) {
    fillAmountBOrS = 1;
  }

  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.storageId, request.accountId, (_request$sellToken = request.sellToken) != null && _request$sellToken.tokenId ? request.sellToken.tokenId : "", (_request$buyToken = request.buyToken) != null && _request$buyToken.nftData ? request.buyToken.nftData : request.buyToken.tokenId, (_request$sellToken2 = request.sellToken) != null && _request$sellToken2.amount ? request.sellToken.amount : 0, (_request$buyToken2 = request.buyToken) != null && _request$buyToken2.amount ? request.buyToken.amount : 0, request.validUntil, request.maxFeeBips, fillAmountBOrS, new BN(ethUtil.toBuffer(request.taker)).toString()];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function get_EddsaSig_Dual_Order(request, eddsaKey) {
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.storageId, request.accountId, request.sellToken.tokenId, request.buyToken.tokenId, request.sellToken.volume, request.buyToken.volume, request.validUntil, request.maxFeeBips, request.fillAmountBOrS ? 1 : 0, 0];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function signNFTMintWithDataStructure(_x75, _x76, _x77, _x78, _x79, _x80, _x81) {
  return _signNFTMintWithDataStructure.apply(this, arguments);
}

function _signNFTMintWithDataStructure() {
  _signNFTMintWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            typedData = getNFTMintTypedData(bodyParams, chainId, web3);
            _context14.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context14.sent;
            return _context14.abrupt("return", result);

          case 5:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));
  return _signNFTMintWithDataStructure.apply(this, arguments);
}

function signNFTMintWithoutDataStructure(_x82, _x83, _x84, _x85, _x86, _x87, _x88) {
  return _signNFTMintWithoutDataStructure.apply(this, arguments);
}

function _signNFTMintWithoutDataStructure() {
  _signNFTMintWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            typedData = getNFTMintTypedData(bodyParams, chainId, web3);
            _context15.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context15.sent;
            return _context15.abrupt("return", result);

          case 5:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));
  return _signNFTMintWithoutDataStructure.apply(this, arguments);
}

function signNFTMintWithDataStructureForContract(_x89, _x90, _x91, _x92, _x93, _x94) {
  return _signNFTMintWithDataStructureForContract.apply(this, arguments);
} // transfer

function _signNFTMintWithDataStructureForContract() {
  _signNFTMintWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            typedData = getNFTMintTypedData(bodyParams, chainId, web3);
            _context16.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context16.sent;
            return _context16.abrupt("return", result);

          case 5:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));
  return _signNFTMintWithDataStructureForContract.apply(this, arguments);
}

function get_EddsaSig_Transfer(request, eddsaKey) {
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.payerId, request.payeeId, request.token.tokenId, request.token.volume, request.maxFee.tokenId, request.maxFee.volume, new BN(ethUtil.toBuffer(request.payeeAddr)).toString(), 0, 0, request.validUntil, request.storageId];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function getTransferOldTypedData(data, chainId) {
  var message = {
    from: data.payerAddr,
    to: data.payeeAddr,
    tokenID: data.token.tokenId,
    amount: data.token.volume,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.volume,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Transfer: [{
        name: "from",
        type: "address"
      }, {
        name: "to",
        type: "address"
      }, {
        name: "tokenID",
        type: "uint16"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Transfer",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function getTransferTypedData(data, chainId) {
  var message = {
    from: data.payerAddr,
    to: data.payeeAddr,
    tokenID: data.token.tokenId,
    amount: data.token.volume,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.volume,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Transfer: [{
        name: "from",
        type: "address"
      }, {
        name: "to",
        type: "address"
      }, {
        name: "tokenID",
        type: "uint16"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Transfer",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function signTransferWithDataStructure(_x95, _x96, _x97, _x98, _x99, _x100, _x101) {
  return _signTransferWithDataStructure.apply(this, arguments);
}

function _signTransferWithDataStructure() {
  _signTransferWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            typedData = getTransferTypedData(bodyParams, chainId);
            _context17.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context17.sent;
            return _context17.abrupt("return", result);

          case 5:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));
  return _signTransferWithDataStructure.apply(this, arguments);
}

function signTransferWithoutDataStructure(_x102, _x103, _x104, _x105, _x106, _x107, _x108) {
  return _signTransferWithoutDataStructure.apply(this, arguments);
}

function _signTransferWithoutDataStructure() {
  _signTransferWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            typedData = getTransferTypedData(bodyParams, chainId);
            _context18.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context18.sent;
            return _context18.abrupt("return", result);

          case 5:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18);
  }));
  return _signTransferWithoutDataStructure.apply(this, arguments);
}

function signTransferWithDataStructureForContract(_x109, _x110, _x111, _x112, _x113, _x114) {
  return _signTransferWithDataStructureForContract.apply(this, arguments);
}

function _signTransferWithDataStructureForContract() {
  _signTransferWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            typedData = getTransferTypedData(bodyParams, chainId);
            _context19.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context19.sent;
            return _context19.abrupt("return", result);

          case 5:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19);
  }));
  return _signTransferWithDataStructureForContract.apply(this, arguments);
}

function get_EddsaSig_NFT_Transfer(request, eddsaKey) {
  var inputs = [new BN(ethUtil.toBuffer(request.exchange)).toString(), request.fromAccountId, request.toAccountId, request.token.tokenId, request.token.amount, request.maxFee.tokenId, request.maxFee.amount, new BN(ethUtil.toBuffer(request.toAddress)).toString(), 0, 0, request.validUntil, request.storageId];
  return getEdDSASigWithPoseidon(inputs, eddsaKey);
}
function getNftTradeHash(request) {
  var p = field.SNARK_SCALAR_FIELD;
  var poseidonParams = new PoseidonParams(p, 7, 6, 52, "poseidon", ethers.BigNumber.from(5), null, null, 128);
  var inputs = [request.taker.accountId, request.taker.sellToken.tokenId, request.taker.storageId, request.maker.accountId, request.maker.sellToken.tokenId, request.maker.storageId];
  var bigIntInputs;
  bigIntInputs = [];

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    bigIntInputs.push(ethers.BigNumber.from(input));
  }

  var hash = permunation.poseidon(bigIntInputs, poseidonParams);
  var hashInHex = hash.toHexString();
  return hashInHex;
}
function getNFTTransferTypedData(data, chainId) {
  var message = {
    from: data.fromAddress,
    to: data.toAddress,
    tokenID: data.token.tokenId,
    amount: data.token.amount,
    feeTokenID: data.maxFee.tokenId,
    maxFee: data.maxFee.amount,
    validUntil: data.validUntil,
    storageID: data.storageId
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      Transfer: [{
        name: "from",
        type: "address"
      }, {
        name: "to",
        type: "address"
      }, {
        name: "tokenID",
        type: "uint16"
      }, {
        name: "amount",
        type: "uint96"
      }, {
        name: "feeTokenID",
        type: "uint16"
      }, {
        name: "maxFee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }, {
        name: "storageID",
        type: "uint32"
      }]
    },
    primaryType: "Transfer",
    domain: {
      name: "Loopring Protocol",
      version: "3.6.0",
      chainId: chainId,
      verifyingContract: data.exchange
    },
    message: message
  };
  return typedData;
}
function signTNFTransferWithDataStructure(_x115, _x116, _x117, _x118, _x119, _x120, _x121) {
  return _signTNFTransferWithDataStructure.apply(this, arguments);
}

function _signTNFTransferWithDataStructure() {
  _signTNFTransferWithDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            typedData = getNFTTransferTypedData(bodyParams, chainId);
            _context20.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.HasDataStruct, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context20.sent;
            return _context20.abrupt("return", result);

          case 5:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20);
  }));
  return _signTNFTransferWithDataStructure.apply(this, arguments);
}

function signNFTTransferWithoutDataStructure(_x122, _x123, _x124, _x125, _x126, _x127, _x128) {
  return _signNFTTransferWithoutDataStructure.apply(this, arguments);
} // export async function signNFTTransferWithoutDataStructure(web3: Web3, owner: string, bodyParams: OriginTransferRequestV3,
//                                                        chainId: ChainId, walletType: ConnectorNames) {
//   const typedData: any = getTransferTypedData(bodyParams, chainId)
//   const result = await getEcDSASig(web3, typedData, owner, GetEcDSASigType.WithoutDataStruct, '', walletType)
//   return result
// }

function _signNFTTransferWithoutDataStructure() {
  _signNFTTransferWithoutDataStructure = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(web3, owner, bodyParams, chainId, walletType, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            typedData = getNFTTransferTypedData(bodyParams, chainId);
            _context21.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.WithoutDataStruct, chainId, accountId, "", walletType, counterFactualInfo);

          case 3:
            result = _context21.sent;
            return _context21.abrupt("return", result);

          case 5:
          case "end":
            return _context21.stop();
        }
      }
    }, _callee21);
  }));
  return _signNFTTransferWithoutDataStructure.apply(this, arguments);
}

function signNFTTransferWithDataStructureForContract(_x129, _x130, _x131, _x132, _x133, _x134) {
  return _signNFTTransferWithDataStructureForContract.apply(this, arguments);
}

function _signNFTTransferWithDataStructureForContract() {
  _signNFTTransferWithDataStructureForContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(web3, owner, bodyParams, chainId, accountId, counterFactualInfo) {
    var typedData, result;
    return runtime_1.wrap(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            typedData = getNFTTransferTypedData(bodyParams, chainId);
            _context22.next = 3;
            return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, accountId, "", exports.ConnectorNames.Unknown, counterFactualInfo);

          case 3:
            result = _context22.sent;
            return _context22.abrupt("return", result);

          case 5:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee22);
  }));
  return _signNFTTransferWithDataStructureForContract.apply(this, arguments);
}

function eddsaSign(typedData, eddsaKey) {
  var hash = toHex(sigUtil.TypedDataUtils.sign(typedData));
  myLog("eddsaSign", hash);
  var sigHash = toHex(new BigNumber(hash, 16).idiv(8));
  var signature = EDDSAUtil.sign(eddsaKey, sigHash);
  return {
    eddsaSig: formatEddsaKey(toHex(toBig(signature.Rx))) + clearHexPrefix(formatEddsaKey(toHex(toBig(signature.Ry)))) + clearHexPrefix(formatEddsaKey(toHex(toBig(signature.s))))
  };
}
function eddsaSignWithDomain(domainHax, primaryType, message, types, eddsaKey) {
  var parts = [Buffer.from("1901", "hex")];
  parts.push(Buffer.from(domainHax.slice(2), "hex"));
  parts.push(sigUtil.TypedDataUtils.hashStruct(primaryType, message, types));
  var hash = toHex(ethUtil.sha3(Buffer.concat(parts)));
  var sigHash = toHex(new BigNumber(hash, 16).idiv(8));
  var signature = EDDSAUtil.sign(eddsaKey, sigHash);
  return {
    eddsaSig: formatEddsaKey(toHex(toBig(signature.Rx))) + clearHexPrefix(formatEddsaKey(toHex(toBig(signature.Ry)))) + clearHexPrefix(formatEddsaKey(toHex(toBig(signature.s))))
  };
}
function getAmmJoinEcdsaTypedData(data, patch) {
  var message = {
    owner: data.owner,
    joinAmounts: [data.joinTokens.pooled[0].volume, data.joinTokens.pooled[1].volume],
    joinStorageIDs: data.storageIds,
    mintMinAmount: data.joinTokens.minimumLp.volume,
    fee: data.fee,
    validUntil: data.validUntil
  }; // myLog('message:', message)

  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      PoolJoin: [{
        name: "owner",
        type: "address"
      }, {
        name: "joinAmounts",
        type: "uint96[]"
      }, {
        name: "joinStorageIDs",
        type: "uint32[]"
      }, {
        name: "mintMinAmount",
        type: "uint96"
      }, {
        name: "fee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }]
    },
    primaryType: "PoolJoin",
    domain: {
      name: patch.ammName,
      version: "1.0.0",
      chainId: patch.chainId,
      verifyingContract: patch.poolAddress
    },
    message: message
  };
  return typedData;
} // ammpool join

function get_EddsaSig_JoinAmmPool(data, patch) {
  if (data.domainSeparator) {
    var typedData = getAmmJoinEcdsaTypedData(data, patch);
    return eddsaSignWithDomain(data.domainSeparator, typedData.primaryType, typedData.message, typedData.types, patch.eddsaKey);
  } else {
    var _typedData = getAmmJoinEcdsaTypedData(data, patch);

    return eddsaSign(_typedData, patch.eddsaKey);
  }
}
function getAmmExitEcdsaTypedData(data, patch) {
  var message = {
    owner: data.owner,
    burnAmount: data.exitTokens.burned.volume,
    burnStorageID: data.storageId,
    exitMinAmounts: [data.exitTokens.unPooled[0].volume, data.exitTokens.unPooled[1].volume],
    fee: data.maxFee,
    validUntil: data.validUntil
  };
  var typedData = {
    types: {
      EIP712Domain: [{
        name: "name",
        type: "string"
      }, {
        name: "version",
        type: "string"
      }, {
        name: "chainId",
        type: "uint256"
      }, {
        name: "verifyingContract",
        type: "address"
      }],
      PoolExit: [{
        name: "owner",
        type: "address"
      }, {
        name: "burnAmount",
        type: "uint96"
      }, {
        name: "burnStorageID",
        type: "uint32"
      }, {
        name: "exitMinAmounts",
        type: "uint96[]"
      }, {
        name: "fee",
        type: "uint96"
      }, {
        name: "validUntil",
        type: "uint32"
      }]
    },
    primaryType: "PoolExit",
    domain: {
      name: patch.ammName,
      version: "1.0.0",
      chainId: patch.chainId,
      verifyingContract: patch.poolAddress
    },
    message: message
  };
  return typedData;
} // ammpool exit

function get_EddsaSig_ExitAmmPool(data, patch) {
  if (data.domainSeparator) {
    var typedData = getAmmExitEcdsaTypedData(data, patch);
    return eddsaSignWithDomain(data.domainSeparator, typedData.primaryType, typedData.message, typedData.types, patch.eddsaKey);
  } else {
    var _typedData2 = getAmmExitEcdsaTypedData(data, patch);

    return eddsaSign(_typedData2, patch.eddsaKey);
  }
} // export function getDefiEcdsaTypedData(
//   data: DefiOrderRequest,
//   patch: DefiRequestPatch
// ) {
//   const message: any = {
//     owner: data.owner,
//     burnAmount: data.exitTokens.burned.volume,
//     burnStorageID: data.storageId,
//     exitMinAmounts: [
//       data.exitTokens.unPooled[0].volume,
//       data.exitTokens.unPooled[1].volume,
//     ],
//     fee: data.maxFee,
//     validUntil: data.validUntil,
//   };
//
//   const typedData: EIP712TypedData = {
//     types: {
//       EIP712Domain: [
//         { name: "name", type: "string" },
//         { name: "version", type: "string" },
//         { name: "chainId", type: "uint256" },
//         { name: "verifyingContract", type: "address" },
//       ],
//       DefiOrder: [
//         { name: "exchange", type: "address" },
//         { name: "storageId", type: "uint96" },
//         { name: "accountId", type: "uint32" },
//         { name: "sellToken.tokenId", type: "uint16" },
//         { name: "buyToken.tokenId", type: "uint16" },
//         { name: "sellToken.volume", type: "uint96" },
//         { name: "buyToken.volume", type: "uint96" },
//         { name: "validUntil", type: "uint32" },
//         { name: "maxFeeBips", type: "uint32" },
//         { name: "fillAmountBOrS", type: "uint32" },
//         { nane: "taker", type: "uint32" },
//       ],
//     },
//     primaryType: "DefiOrder",
//     domain: {
//       name: patch.ammName,
//       version: "1.0.0",
//       chainId: patch.chainId,
//       verifyingContract: patch.poolAddress,
//     },
//     message: message,
//   };
//   return typedData;
// }
// export function get_EddsaSig_Defi(request: DefiOrderRequest, eddsaKey: string) {
//
//   myLog('get_EddsaSig_Defi input',inputs)
//   return getEdDSASigWithPoseidon(inputs, eddsaKey);
//   // return eddsaSign(typedData, patch.eddsaKey);
// }

var sortObject = function sortObject(o) {
  return Object.keys(o).sort().reduce(function (r, k) {
    return r[k] = o[k], r;
  }, {});
};

/**
 *
 * @export
 */

var setSearchParams = function setSearchParams(url) {
  var searchParams = new URLSearchParams(url.search);

  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {
    var object = _objects[_i];

    if (object) {
      var objectTmp = sortObject(object);

      for (var key in objectTmp) {
        if (objectTmp[key] != undefined) searchParams.set(key, objectTmp[key]);
      }
    }
  }

  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function serializeDataIfNeeded(value) {
  var nonString = typeof value !== "string";
  return nonString ? JSON.stringify(value !== undefined ? sortObject(value) : {}) : value || "";
};
/**
 *
 * @export
 */

var toPathString = function toPathString(url) {
  return url.pathname + url.search + url.hash;
};
var Request = /*#__PURE__*/function () {
  function Request(baseUrl, timeout) {
    this.baseOptions = {};
    this.baseOptions = {
      baseURL: baseUrl,
      timeout: timeout,
      headers: {
        // 'Accept': '*/*',
        // 'Accept-Encoding': 'gzip, deflate, br',
        feeVersion: "v2",
        "Content-Type": "application/json",
        pf: "web"
      },
      validateStatus: function validateStatus(status) {
        if (status >= 200 && status < 300 || status === 400) {
          return true;
        }

        return false; // return true // always true, handle exception in each bussiness logic
      },
      insecure: true
    };
    this._axios = axios.create(this.baseOptions);
  }

  var _proto = Request.prototype;

  _proto.getIns = function getIns() {
    return this._axios;
  };

  _proto.request = /*#__PURE__*/function () {
    var _request = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(params, options) {
      var _params$sigObj, _params$sigObj2, _params$sigObj3, _params$sigObj4, _params$sigObj5, _params$sigObj6;

      var localUrl, localVarRequestOptions, urlPathStr, headers, sig, _params$sigObj7, bodyParams, _params$sigObj8, optInOne;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              localUrl = new URL(params.url, this.baseOptions.baseURL);
              localVarRequestOptions = _extends({
                method: params.method
              }, options);
              setSearchParams(localUrl, params == null ? void 0 : params.queryParams);
              urlPathStr = toPathString(localUrl);
              headers = {};

              if (params != null && params.apiKey) {
                headers["X-API-KEY"] = params == null ? void 0 : params.apiKey;
              }

              sig = (_params$sigObj = params.sigObj) == null ? void 0 : _params$sigObj.sig;

              if (!(params.sigFlag !== exports.SIG_FLAG.NO_SIG && !(params != null && (_params$sigObj2 = params.sigObj) != null && _params$sigObj2.dataToSig))) {
                _context.next = 10;
                break;
              }

              throw Error("no dataToSig field!");

            case 10:
              _context.t0 = params.sigFlag;
              _context.next = _context.t0 === exports.SIG_FLAG.NO_SIG ? 13 : _context.t0 === exports.SIG_FLAG.EDDSA_SIG_POSEIDON ? 14 : _context.t0 === exports.SIG_FLAG.EDDSA_SIG ? 16 : 18;
              break;

            case 13:
              return _context.abrupt("break", 19);

            case 14:
              sig = getEdDSASigWithPoseidon((_params$sigObj3 = params.sigObj) == null ? void 0 : _params$sigObj3.dataToSig, (_params$sigObj4 = params.sigObj) == null ? void 0 : _params$sigObj4.PrivateKey).result;
              return _context.abrupt("break", 19);

            case 16:
              sig = getEdDSASig(params.method, this.baseOptions.baseURL, params.url, (_params$sigObj5 = params.sigObj) == null ? void 0 : _params$sigObj5.dataToSig, (_params$sigObj6 = params.sigObj) == null ? void 0 : _params$sigObj6.PrivateKey);
              return _context.abrupt("break", 19);

            case 18:
              return _context.abrupt("break", 19);

            case 19:
              if (sig) {
                headers["X-API-SIG"] = sig;
              } else if (params != null && params.ecdsaSignature) {
                headers["X-API-SIG"] = params == null ? void 0 : params.ecdsaSignature;
              } else if (params != null && params.eddsaSignature) {
                headers["X-API-SIG"] = params == null ? void 0 : params.eddsaSignature;
              } // myLog('headers["X-API-SIG"]', headers["X-API-SIG"]);


              if (params != null && params.bodyParams) {
                bodyParams = params == null ? void 0 : params.bodyParams;

                if (sig && (_params$sigObj7 = params.sigObj) != null && _params$sigObj7.sigPatch) {
                  bodyParams[(_params$sigObj8 = params.sigObj) == null ? void 0 : _params$sigObj8.sigPatch] = sig;
                }

                if (params != null && params.ecdsaSignature) {
                  bodyParams.ecdsaSignature = params == null ? void 0 : params.ecdsaSignature;
                }

                if (params != null && params.eddsaSignature) {
                  bodyParams.eddsaSignature = params == null ? void 0 : params.eddsaSignature;
                }

                localVarRequestOptions.data = serializeDataIfNeeded(bodyParams);
              }

              headers = _extends({}, this.baseOptions.headers, headers);
              optInOne = _extends({}, this.baseOptions, {
                headers: headers
              }, localVarRequestOptions, {
                url: this.baseOptions.baseURL + urlPathStr
              }); // myLog(optInOne);
              // myLog("headers config", optInOne);

              _context.next = 25;
              return this._axios.request(optInOne);

            case 25:
              return _context.abrupt("return", _context.sent);

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function request(_x, _x2) {
      return _request.apply(this, arguments);
    }

    return request;
  }();

  _proto.updateOpt = function updateOpt(reqOpt) {
    this._axios.interceptors.request.use(function (req) {
      if (reqOpt != null && reqOpt.baseUrl) {
        req.baseURL = reqOpt == null ? void 0 : reqOpt.baseUrl;
      }

      if (reqOpt != null && reqOpt.url) {
        req.url = reqOpt == null ? void 0 : reqOpt.url;
      }

      if (reqOpt != null && reqOpt.apiKey) {
        req.headers["X-API-KEY"] = reqOpt == null ? void 0 : reqOpt.apiKey;
      }

      if (reqOpt != null && reqOpt.signature) {
        req.headers["X-API-SIG"] = reqOpt == null ? void 0 : reqOpt.signature;
      }

      return req;
    });

    return this;
  };

  _proto.addApiKey = function addApiKey(apiKey) {
    return this.updateOpt({
      apiKey: apiKey
    });
  };

  _proto.addSig = function addSig(signature) {
    return this.updateOpt({
      signature: signature
    });
  };

  _proto.updateBaseUrl = function updateBaseUrl(baseUrl) {
    return this.updateOpt({
      baseUrl: baseUrl
    });
  };

  _proto.handle400 = function handle400(callback) {
    if (callback === void 0) {
      callback = undefined;
    }

    this._axios.interceptors.response.use(function (res) {
      if (res.status == 400) {
        // eslint-disable-next-line no-console
        console.log(res.request + " got " + res.statusText);
      }

      if (callback) {
        callback();
      }

      return res;
    });
  };

  return Request;
}();

var AbiFunction = /*#__PURE__*/function () {
  function AbiFunction(_ref) {
    var inputs = _ref.inputs,
        name = _ref.name,
        outputs = _ref.outputs,
        constant = _ref.constant;
    this.name = name;
    this.inputTypes = inputs.map(function (_ref2) {
      var type = _ref2.type;
      return type;
    });
    this.inputs = inputs;
    this.outputTypes = outputs.map(function (_ref3) {
      var type = _ref3.type;
      return type;
    });
    this.outputs = outputs;
    this.constant = constant;
    this.methodAbiHash = toHex(abi.methodID(name, this.inputTypes));
  }
  /**
   * @description Returns encoded methodId and inputs
   * @param inputs Object, examples {owner:'0x000...}
   * @returns {string}
   */


  var _proto = AbiFunction.prototype;

  _proto.encodeInputs = function encodeInputs(inputs) {
    var abiInputs = this.parseInputs(inputs);
    return this.methodAbiHash + clearHexPrefix(toHex(abi.rawEncode(this.inputTypes, abiInputs)));
  }
  /**
   * @description decode ethereum jsonrpc response result
   * @param outputs
   * @returns {*}
   */
  ;

  _proto.decodeOutputs = function decodeOutputs(outputs) {
    return this.parseOutputs(abi.rawDecode(this.outputTypes, toBuffer(outputs)));
  }
  /**
   * @description decode encoded inputs
   * @param encoded
   * @returns {*}
   */
  ;

  _proto.decodeEncodedInputs = function decodeEncodedInputs(encoded) {
    return this.parseOutputs(abi.rawDecode(this.inputTypes, toBuffer(addHexPrefix(encoded))));
  };

  _proto.parseInputs = function parseInputs(inputs) {
    if (inputs === void 0) {
      inputs = {};
    }

    return this.inputs.map(function (_ref4) {
      var name = _ref4.name,
          type = _ref4.type;

      if (inputs[name] === undefined) {
        throw new Error("Parameter " + name + " of type " + type + " is required!");
      }

      return inputs[name];
    });
  };

  _proto.parseOutputs = function parseOutputs(outputs) {
    return outputs.map(function (output) {
      if (output instanceof BN) {
        return toHex(output);
      }

      return output;
    });
  };

  return AbiFunction;
}();

var Contract = /*#__PURE__*/function () {
  function Contract(abi$1) {
    var funAbi = abi$1.filter(function (_ref) {
      var type = _ref.type;
      return type === "function";
    });
    this.abiFunctions = funAbi.reduce(function (acc, item) {
      var _extends2;

      var inputTypes = item.inputs.map(function (_ref2) {
        var type = _ref2.type;
        return type;
      });
      var key = item.name + "(" + inputTypes.toString() + ")";
      var methodHash = abi.methodID(item.name, inputTypes);
      return _extends({}, acc, (_extends2 = {}, _extends2[item.name] = new AbiFunction(item), _extends2[key] = new AbiFunction(item), _extends2[methodHash] = new AbiFunction(item), _extends2));
    }, {});
  }
  /**
   * @description Encodes inputs data according to  ethereum abi
   * @param method string can be full method or just method name, examples: 'balanceOf' or balanceOf(address)
   * @param inputs array
   * @returns {*|string}
   */


  var _proto = Contract.prototype;

  _proto.encodeInputs = function encodeInputs(method, inputs) {
    var abiFunction = this.abiFunctions[method];

    if (abiFunction) {
      return abiFunction.encodeInputs(inputs);
    } else {
      throw new Error("No  " + method + " method according to abi ");
    }
  }
  /**
   * @description Decodes outputs
   * @param method string can be full method or just method name, examples: 'balanceOf' or balanceOf(address)
   * @param outputs string
   * @returns {*}
   */
  ;

  _proto.decodeOutputs = function decodeOutputs(method, outputs) {
    var abiFunction = this.abiFunctions[method];

    if (abiFunction) {
      return abiFunction.decodeOutputs(outputs);
    } else {
      throw new Error("No  " + method + " method according to abi ");
    }
  }
  /**
   * @description Decode encoded method and inputs
   * @param encode string | Buffer
   * @returns {*}
   */
  ;

  _proto.decodeEncodeInputs = function decodeEncodeInputs(encode) {
    encode = toHex(encode);
    var methodId = encode.slice(0, 10);
    var abiFunction = this.abiFunctions[methodId];

    if (abiFunction) {
      return abiFunction.decodeEncodedInputs(encode.slice(10));
    } else {
      throw new Error("No corresponding method according to abi ");
    }
  };

  return Contract;
}();

var erc20 = [
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_spender",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_from",
				type: "address"
			},
			{
				name: "_to",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_owner",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				name: "balance",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_to",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_owner",
				type: "address"
			},
			{
				name: "_spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	}
];

var erc20$1 = {
  __proto__: null,
  'default': erc20
};

var exchange_3_6 = [
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "tokenAddress",
				type: "address"
			},
			{
				internalType: "uint32",
				name: "accountID",
				type: "uint32"
			}
		],
		name: "forceWithdraw",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "address",
				name: "tokenAddress",
				type: "address"
			},
			{
				internalType: "uint96",
				name: "amount",
				type: "uint96"
			},
			{
				internalType: "bytes",
				name: "extraData",
				type: "bytes"
			}
		],
		name: "deposit",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "enum ExchangeData.NftType",
				name: "nftType",
				type: "uint8"
			},
			{
				internalType: "address",
				name: "tokenAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "nftId",
				type: "uint256"
			},
			{
				internalType: "uint96",
				name: "amount",
				type: "uint96"
			},
			{
				internalType: "bytes",
				name: "extraData",
				type: "bytes"
			}
		],
		name: "depositNFT",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "token",
				type: "address"
			}
		],
		name: "withdrawFromDepositRequest",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "owners",
				type: "address[]"
			},
			{
				internalType: "address[]",
				name: "tokens",
				type: "address[]"
			}
		],
		name: "withdrawFromApprovedWithdrawals",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "token",
				type: "address"
			}
		],
		name: "getAmountWithdrawable",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "txHash",
				type: "bytes32"
			}
		],
		name: "approveTransaction",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var exchange_3_6$1 = {
  __proto__: null,
  'default': exchange_3_6
};

var contractWallet = [
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "magicValue",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "_signature",
				type: "bytes"
			}
		],
		name: "isValidSignature",
		outputs: [
			{
				internalType: "bytes4",
				name: "magicValue",
				type: "bytes4"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_account",
				type: "address"
			},
			{
				name: "_index",
				type: "uint256"
			}
		],
		name: "getKeyData",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

var contractWallet$1 = {
  __proto__: null,
  'default': contractWallet
};

var erc721 = [
	{
		inputs: [
			{
				internalType: "string",
				name: "name_",
				type: "string"
			},
			{
				internalType: "string",
				name: "symbol_",
				type: "string"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "approved",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "ApprovalForAll",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "getApproved",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "operator",
				type: "address"
			}
		],
		name: "isApprovedForAll",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "ownerOf",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "setApprovalForAll",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "tokenURI",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var erc721$1 = {
  __proto__: null,
  'default': erc721
};

var erc1155 = [
	{
		inputs: [
			{
				internalType: "string",
				name: "uri_",
				type: "string"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "ApprovalForAll",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			},
			{
				indexed: false,
				internalType: "uint256[]",
				name: "values",
				type: "uint256[]"
			}
		],
		name: "TransferBatch",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "id",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "TransferSingle",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "string",
				name: "value",
				type: "string"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "id",
				type: "uint256"
			}
		],
		name: "URI",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "uri",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "id",
				type: "uint256"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "accounts",
				type: "address[]"
			},
			{
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			}
		],
		name: "balanceOfBatch",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "setApprovalForAll",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "address",
				name: "operator",
				type: "address"
			}
		],
		name: "isApprovedForAll",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "id",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "safeBatchTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var erc1155$1 = {
  __proto__: null,
  'default': erc1155
};

var hebao = [
	{
		inputs: [
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			}
		],
		name: "lock",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "address",
				name: "guardian",
				type: "address"
			}
		],
		name: "unlock",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var hebao$1 = {
  __proto__: null,
  'default': hebao
};

var erc20Abi = getCjsExportFromNamespace(erc20$1);

var exchange36Abi = getCjsExportFromNamespace(exchange_3_6$1);

var contractWalletAbi = getCjsExportFromNamespace(contractWallet$1);

var erc721Abi = getCjsExportFromNamespace(erc721$1);

var erc1155Abi = getCjsExportFromNamespace(erc1155$1);

var hebao$2 = getCjsExportFromNamespace(hebao$1);

var ERC20Token = /*#__PURE__*/new Contract(erc20Abi);
var ExchangeContract = /*#__PURE__*/new Contract(exchange36Abi);
var ContractWallet = /*#__PURE__*/new Contract(contractWalletAbi);
var ERC1155 = /*#__PURE__*/new Contract(erc1155Abi);
var ERC721 = /*#__PURE__*/new Contract(erc721Abi);
var HeBao = /*#__PURE__*/new Contract(hebao$2);
var Contracts = {
  ERC20Token: ERC20Token,
  ERC1155: ERC1155,
  ERC721: ERC721,
  ExchangeContract: ExchangeContract,
  ContractWallet: ContractWallet,
  erc721Abi: erc721Abi,
  erc1155Abi: erc1155Abi,
  HeBao: HeBao
};

var contracts = {
  AbiFunction: AbiFunction,
  Contract: Contract,
  Contracts: Contracts
};

var KEY_MESSAGE = "Sign this message to access Loopring Exchange: " + "${exchangeAddress}" + " with key nonce: " + "${nonce}";
var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI(param, timeout, baseUrlMap) {
    if (timeout === void 0) {
      timeout = 6000;
    }

    if (baseUrlMap === void 0) {
      var _baseUrlMap;

      baseUrlMap = (_baseUrlMap = {}, _baseUrlMap[exports.ChainId.MAINNET] = "https://api3.loopring.io", _baseUrlMap[exports.ChainId.GOERLI] = "https://uat2.loopring.io", _baseUrlMap);
    }

    this.baseUrl = "";
    this.chainId = exports.ChainId.MAINNET;

    if (param.baseUrl) {
      this.baseUrl = param.baseUrl;
    } else if (param.chainId !== undefined) {
      this.setChainId(param.chainId);
    } else {
      this.setChainId(exports.ChainId.GOERLI);
    }

    this.baseUrlMap = baseUrlMap;
    this.timeout = timeout;
  }

  var _proto = BaseAPI.prototype;

  _proto.genErr = function genErr(err) {
    if (err.hasOwnProperty("request")) {
      // const axiosError = errorInfo as AxiosResponse;
      return _extends({
        // @ts-ignore;
        message: exports.ConnectorError.HTTP_ERROR
      }, err, {
        msg: exports.ConnectorError.HTTP_ERROR,
        code: exports.LoopringErrorCode.HTTP_ERROR
      });
    } else if (!err || !(err != null && err.message)) {
      return {
        message: "unKnown",
        code: exports.LoopringErrorCode.SKD_UNKNOW
      };
    } else {
      var key = Reflect.ownKeys(exports.ConnectorError).find(function (key) {
        return (err == null ? void 0 : err.message.search(exports.ConnectorError[key])) !== -1;
      });

      if (key) {
        return _extends({}, err, {
          message: key,
          code: exports.LoopringErrorCode[key]
        });
      }

      return _extends({}, err instanceof Error ? Reflect.ownKeys(err).reduce(function (prev, item) {
        var _extends2;

        // @ts-ignore
        return _extends({}, prev, (_extends2 = {}, _extends2[item] = err[item.toString()], _extends2));
      }, {}) : err, {
        code: exports.LoopringErrorCode.SKD_UNKNOW
      });
    }
  };

  _proto.returnTxHash = function returnTxHash(raw_data) {
    if (raw_data != null && raw_data.resultInfo) {
      var _raw_data$resultInfo, _raw_data$resultInfo2;

      return _extends({}, raw_data.resultInfo, {
        message: (_raw_data$resultInfo = raw_data.resultInfo) != null && _raw_data$resultInfo.msg ? (_raw_data$resultInfo2 = raw_data.resultInfo) == null ? void 0 : _raw_data$resultInfo2.msg : raw_data == null ? void 0 : raw_data.resultInfo.message
      });
    }

    return _extends({}, raw_data, {
      raw_data: raw_data
    });
  };

  _proto.getAvailableBroker = /*#__PURE__*/function () {
    var _getAvailableBroker = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request) {
      var reqParams, result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AVAILABLE_BROKER,
                method: exports.ReqMethod.GET
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              result = _context.sent.data;
              return _context.abrupt("return", result);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAvailableBroker(_x) {
      return _getAvailableBroker.apply(this, arguments);
    }

    return getAvailableBroker;
  }();

  _proto.getCounterFactualInfo = /*#__PURE__*/function () {
    var _getCounterFactualInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request) {
      var reqParams, raw_data, counterFactualInfo, error;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.COUNTER_FACTUAL_INFO,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;
              error = undefined;

              if (raw_data && raw_data != null && raw_data.resultInfo) {
                error = raw_data == null ? void 0 : raw_data.resultInfo;
              } else {
                counterFactualInfo = _extends({}, raw_data);
              }

              return _context2.abrupt("return", {
                counterFactualInfo: counterFactualInfo,
                error: error,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getCounterFactualInfo(_x2) {
      return _getCounterFactualInfo.apply(this, arguments);
    }

    return getCounterFactualInfo;
  }();

  _proto.setChainId = function setChainId(chainId) {
    this.baseUrl = this.baseUrlMap && this.baseUrlMap[0] ? getBaseUrlByChainId(chainId, this.baseUrlMap) : getBaseUrlByChainId(chainId);
    this.chainId = chainId;
  };

  _proto.setBaseUrl = function setBaseUrl(baseUrl) {
    this.baseUrl = baseUrl;
  };

  _proto.makeReq = function makeReq() {
    return new Request(this.baseUrl, this.timeout);
  };

  return BaseAPI;
}();
BaseAPI.KEY_MESSAGE = KEY_MESSAGE;
function ecRecover(_x3, _x4, _x5, _x6) {
  return _ecRecover.apply(this, arguments);
}

function _ecRecover() {
  _ecRecover = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(web3, account, msg, sig) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", new Promise(function (resolve) {
              try {
                web3.eth.personal.ecRecover(msg, sig, function (err, address) {
                  if (!err && address) {
                    resolve({
                      result: address.toLowerCase() === account.toLowerCase()
                    });
                  } else {
                    resolve({
                      error: "ecRecover 1:" + err + "or no address:" + address
                    });
                    myLog("ecRecover error", err);
                  }
                });
              } catch (err) {
                myLog("ecRecover error", err);
                resolve({
                  error: "ecRecover 2:" + err
                });
              }
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _ecRecover.apply(this, arguments);
}

function contractWalletValidate32(_x7, _x8, _x9, _x10) {
  return _contractWalletValidate.apply(this, arguments);
}

function _contractWalletValidate() {
  _contractWalletValidate = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(web3, account, msg, sig) {
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", new Promise(function (resolve) {
              var hash = ethUtil.hashPersonalMessage(toBuffer(msg));
              var data = contracts.Contracts.ContractWallet.encodeInputs("isValidSignature(bytes32,bytes)", {
                _data: hash,
                _signature: toBuffer(sig)
              });
              web3.eth.call({
                to: account,
                data: data
              }, function (err, result) {
                if (!err) {
                  var valid = contracts.Contracts.ContractWallet.decodeOutputs("isValidSignature(bytes32,bytes)", result);
                  resolve({
                    result: toHex(toBuffer(valid[0])) === data.slice(0, 10)
                  });
                } else resolve({
                  error: err
                });
              });
            }));

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _contractWalletValidate.apply(this, arguments);
}

function mykeyWalletValid(_x11, _x12, _x13, _x14) {
  return _mykeyWalletValid.apply(this, arguments);
}

function _mykeyWalletValid() {
  _mykeyWalletValid = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(web3, account, msg, sig) {
    var myKeyContract;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            myKeyContract = "0xADc92d1fD878580579716d944eF3460E241604b7";
            return _context5.abrupt("return", new Promise(function (resolve) {
              web3.eth.call({
                to: myKeyContract,
                data: contracts.Contracts.ContractWallet.encodeInputs("getKeyData", {
                  _account: account,
                  _index: 3
                })
              }, function (err, res) {
                if (!err) {
                  var signature = ethUtil.fromRpcSig(sig);
                  var hash = ethUtil.hashPersonalMessage(ethUtil.keccak256(toBuffer(msg)));
                  var address = addHexPrefix(contracts.Contracts.ContractWallet.decodeOutputs("getKeyData", res)[0]);
                  var recAddress = toHex(ethUtil.pubToAddress(ethUtil.ecrecover(hash, signature.v, signature.r, signature.s)));
                  resolve({
                    result: recAddress.toLowerCase() === address.toLowerCase()
                  });
                } else {
                  resolve({
                    error: err
                  });
                }
              });
            }));

          case 2:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _mykeyWalletValid.apply(this, arguments);
}

function ecRecover2(_x15, _x16, _x17) {
  return _ecRecover2.apply(this, arguments);
}

function _ecRecover2() {
  _ecRecover2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(account, message, signature) {
    var messageBuffer, parts, totalHash, r, s, old_v, v, pub, recoveredAddress;
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            messageBuffer = Buffer.from(message, "utf8"); // myLog('message:', message)
            // myLog('signature raw:', signature)

            signature = signature.split("x")[1];
            parts = [Buffer.from("\x19Ethereum Signed Message:\n" + messageBuffer.length, "utf8"), messageBuffer];
            totalHash = ethUtil.keccak(Buffer.concat(parts));
            r = Buffer.from(signature.substring(0, 64), "hex");
            s = Buffer.from(signature.substring(64, 128), "hex");
            old_v = Number(addHexPrefix(signature.substring(128, 130)));
            v = old_v;
            if (v <= 1) v += 27;
            pub = ethUtil.ecrecover(totalHash, v, r, s);
            recoveredAddress = "0x" + ethUtil.pubToAddress(pub).toString("hex");

            if (account.toLowerCase() !== recoveredAddress.toLowerCase()) {
              myLog("v:", v, "old_v:", old_v, " recoveredAddress:", recoveredAddress);
            }

            return _context6.abrupt("return", new Promise(function (resolve) {
              return resolve({
                result: account.toLowerCase() === recoveredAddress.toLowerCase()
              });
            }));

          case 13:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _ecRecover2.apply(this, arguments);
}

var getBaseUrlByChainId = function getBaseUrlByChainId(id, baseUrlMap) {
  if (baseUrlMap === void 0) {
    var _baseUrlMap2;

    baseUrlMap = (_baseUrlMap2 = {}, _baseUrlMap2[exports.ChainId.MAINNET] = "https://api3.loopring.io", _baseUrlMap2[exports.ChainId.GOERLI] = "https://uat2.loopring.io", _baseUrlMap2);
  }

  var baseUrl = "";

  switch (id) {
    case exports.ChainId.MAINNET:
      baseUrl = baseUrlMap[exports.ChainId.MAINNET];
      break;

    default:
      baseUrl = baseUrlMap[exports.ChainId.GOERLI];
      break;
  }

  return baseUrl;
};

function formatSig(rpcSig) {
  var sig = ethUtil.fromRpcSig(rpcSig);
  return ethUtil.toRpcSig(sig.v, sig.r, sig.s);
}
function recoverSignType(web3, account, msg, sig) {
  var ethRecover = ecRecover(web3, account, msg, sig);

  if (ethRecover.result) {
    return "03";
  } else {
    return "";
  }
}
function personalSign(_x18, _x19, _x20, _x21, _x22, _x23, _x24, _x25, _x26) {
  return _personalSign.apply(this, arguments);
}

function _personalSign() {
  _personalSign = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(web3, account, pwd, msg, walletType, chainId, accountId, counterFactualInfo, isMobile) {
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (account) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt("return", {
              error: "personalSign got no account"
            });

          case 2:
            return _context8.abrupt("return", new Promise(function (resolve) {
              try {
                web3.eth.personal.sign(msg, account, pwd, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(err, result) {
                    var _window, _window$ethereum, _window2, _window2$ethereum, _web3$currentProvider, _web3$currentProvider2, fcValid, _window$ethereum2, address, _web3$currentProvider3, valid, walletValid2, _fcValid, myKeyValid;

                    return runtime_1.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            if (err) {
                              _context7.next = 47;
                              break;
                            }

                            // LOG: for signature
                            myLog("ecRecover before", "msg", msg, "result", result, counterFactualInfo); // Valid:1. counter Factual signature Valid

                            if (!(counterFactualInfo && accountId)) {
                              _context7.next = 10;
                              break;
                            }

                            myLog("fcWalletValid counterFactualInfo accountId:");
                            _context7.next = 6;
                            return fcWalletValid(web3, account, msg, result, accountId, chainId, counterFactualInfo);

                          case 6:
                            fcValid = _context7.sent;

                            if (!fcValid.result) {
                              _context7.next = 10;
                              break;
                            }

                            resolve({
                              sig: result,
                              counterFactualInfo: fcValid.counterFactualInfo
                            });
                            return _context7.abrupt("return");

                          case 10:
                            if (!(typeof window !== "undefined" && ((_window = window) != null && (_window$ethereum = _window.ethereum) != null && _window$ethereum.isImToken || (_window2 = window) != null && (_window2$ethereum = _window2.ethereum) != null && _window2$ethereum.isMetaMask) && isMobile && // Mobile directory connect will sign ConnectorNames as MetaMask only
                            walletType === exports.ConnectorNames.MetaMask)) {
                              _context7.next = 16;
                              break;
                            }

                            _context7.next = 13;
                            return (_window$ethereum2 = window.ethereum) == null ? void 0 : _window$ethereum2.request({
                              method: "eth_requestAccounts"
                            });

                          case 13:
                            address = _context7.sent;

                            if (!(address != null && address.find(function (item) {
                              return item.toLowerCase() === account.toLowerCase();
                            }))) {
                              _context7.next = 16;
                              break;
                            }

                            return _context7.abrupt("return", resolve({
                              sig: result
                            }));

                          case 16:
                            if (!(web3 != null && (_web3$currentProvider = web3.currentProvider) != null && _web3$currentProvider.isWalletLink && web3 != null && (_web3$currentProvider2 = web3.currentProvider) != null && _web3$currentProvider2.isConnected)) {
                              _context7.next = 21;
                              break;
                            }

                            account === ((_web3$currentProvider3 = web3.currentProvider) == null ? void 0 : _web3$currentProvider3.selectedAddress);
                            return _context7.abrupt("return", resolve({
                              sig: result
                            }));

                          case 21:
                            _context7.next = 23;
                            return ecRecover(web3, account, msg, result);

                          case 23:
                            valid = _context7.sent;
                            myLog("ecRecover after", valid.result);

                            if (!valid.result) {
                              _context7.next = 27;
                              break;
                            }

                            return _context7.abrupt("return", resolve({
                              sig: result
                            }));

                          case 27:
                            _context7.next = 29;
                            return contractWalletValidate32(web3, account, msg, result);

                          case 29:
                            walletValid2 = _context7.sent;

                            if (!walletValid2.result) {
                              _context7.next = 32;
                              break;
                            }

                            return _context7.abrupt("return", resolve({
                              sig: result
                            }));

                          case 32:
                            if (!accountId) {
                              _context7.next = 38;
                              break;
                            }

                            _context7.next = 35;
                            return fcWalletValid(web3, account, msg, result, accountId, chainId);

                          case 35:
                            _fcValid = _context7.sent;

                            if (!_fcValid.result) {
                              _context7.next = 38;
                              break;
                            }

                            return _context7.abrupt("return", resolve({
                              sig: result,
                              counterFactualInfo: _fcValid.counterFactualInfo
                            }));

                          case 38:
                            _context7.next = 40;
                            return mykeyWalletValid(web3, account, msg, result);

                          case 40:
                            myKeyValid = _context7.sent;

                            if (!myKeyValid.result) {
                              _context7.next = 43;
                              break;
                            }

                            return _context7.abrupt("return", resolve({
                              sig: result
                            }));

                          case 43:
                            // Valid: Error cannot pass personalSign Valid
                            // eslint-disable-next-line no-console
                            console.log("web3.eth.personal.sign Valid, valid 5 ways, all failed!");
                            return _context7.abrupt("return", resolve({
                              error: "web3.eth.personal.sign Valid, valid 5 ways, all failed!"
                            }));

                          case 47:
                            return _context7.abrupt("return", resolve({
                              error: "personalSign err before Validate:" + err
                            }));

                          case 48:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }));

                  return function (_x34, _x35) {
                    return _ref.apply(this, arguments);
                  };
                }());
              } catch (err) {
                resolve({
                  error: err
                });
              }
            }));

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _personalSign.apply(this, arguments);
}

function fcWalletValid(_x27, _x28, _x29, _x30, _x31, _x32, _x33) {
  return _fcWalletValid.apply(this, arguments);
}

function _fcWalletValid() {
  _fcWalletValid = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(web3, account, msg, result, accountId, chainId, counterFactualInfo) {
    var api, _result, valid;

    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            api = new BaseAPI({
              chainId: chainId
            });

            if (!(counterFactualInfo === undefined || !counterFactualInfo.walletOwner)) {
              _context9.next = 5;
              break;
            }

            _context9.next = 4;
            return api.getCounterFactualInfo({
              accountId: accountId
            });

          case 4:
            counterFactualInfo = _context9.sent.counterFactualInfo;

          case 5:
            if (!(counterFactualInfo && counterFactualInfo.walletOwner)) {
              _context9.next = 18;
              break;
            }

            if (result.startsWith("0x")) {
              _result = result.slice(0, 132);
            } else {
              _result = result;
            }

            _context9.next = 9;
            return ecRecover(web3, counterFactualInfo.walletOwner, msg, _result);

          case 9:
            valid = _context9.sent;

            if (!valid.result) {
              _context9.next = 15;
              break;
            }

            myLog("fcWalletValid e:", result, counterFactualInfo);
            return _context9.abrupt("return", {
              result: result,
              counterFactualInfo: counterFactualInfo
            });

          case 15:
            return _context9.abrupt("return", {
              error: "valid walletOwner failed"
            });

          case 16:
            _context9.next = 19;
            break;

          case 18:
            return _context9.abrupt("return", {
              error: "valid walletOwner failed"
            });

          case 19:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _fcWalletValid.apply(this, arguments);
}

var WsAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(WsAPI, _BaseAPI);

  function WsAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = WsAPI.prototype;

  /*
   * Get wsApiKey by access REST path "/v3/ws/key"
   */
  _proto.getWsKey =
  /*#__PURE__*/
  function () {
    var _getWsKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var reqParams, raw_data, wsKey;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_WS_KEY,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              wsKey = raw_data.key;
              return _context.abrupt("return", {
                wsKey: wsKey,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getWsKey() {
      return _getWsKey.apply(this, arguments);
    }

    return getWsKey;
  }();

  return WsAPI;
}(BaseAPI);

var checkAmt = function checkAmt(rawStr) {
  if (rawStr.trim() === "") {
    return "0";
  }

  return rawStr;
};

function getFeeMap(feeArr, type) {
  if (type === void 0) {
    type = 0;
  }

  var feesMap = {};

  if (feeArr instanceof Array) {
    feeArr.forEach(function (item, index, array) {
      var key = "";

      switch (type) {
        case 1:
          key = item.type;
          break;

        default:
          key = item.token;
      } // feesMap[key] = new BigNumber(item.fee)


      feesMap[key] = item.fee;
    });
  }

  return feesMap;
}

function genAB(data, isReverse) {
  if (isReverse === void 0) {
    isReverse = false;
  }

  var ab_arr = [];
  var amtTotal = new BigNumber(0);
  var volTotal = new BigNumber(0);
  var ab_prices = [];
  var ab_amtTotals = [];
  var ab_volTotals = [];
  var best = 0;

  if (data instanceof Array) {
    data.forEach(function (item) {
      var price = parseFloat(item[0]);
      var amt = new BigNumber(item[1]); // base amt

      var vol = new BigNumber(item[2]); // quote vol

      amtTotal = amtTotal.plus(amt);
      volTotal = volTotal.plus(vol);
      ab_arr.push({
        price: price,
        amt: amt.toString(),
        vol: vol.toString(),
        amtTotal: amtTotal.toString(),
        volTotal: volTotal.toString()
      });
      ab_prices.push(price);
      ab_amtTotals.push(amtTotal.toString());
      ab_volTotals.push(volTotal.toString());
    });
  }

  if (isReverse) {
    ab_arr.reverse();
    ab_prices.reverse();
    ab_amtTotals.reverse();
    ab_volTotals.reverse();
  }

  return {
    ab_arr: ab_arr,
    ab_prices: ab_prices,
    amtTotal: amtTotal,
    volTotal: volTotal,
    ab_amtTotals: ab_amtTotals,
    ab_volTotals: ab_volTotals,
    best: best
  };
}

function getMidPrice(_ref) {
  var _asks = _ref._asks,
      askReverse = _ref.askReverse,
      _bids = _ref._bids,
      bidReverse = _ref.bidReverse;

  if (askReverse === undefined) {
    askReverse = false;
  }

  if (bidReverse === undefined) {
    bidReverse = true;
  }

  var bids = genAB(_bids, bidReverse);
  var asks = genAB(_asks, askReverse);
  var mid_price = (bids.ab_prices[bids.ab_prices.length - 1] + asks.ab_prices[0]) / 2;
  return {
    bids: bids,
    asks: asks,
    mid_price: mid_price
  };
}
var ExchangeAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(ExchangeAPI, _BaseAPI);

  function ExchangeAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = ExchangeAPI.prototype;

  /*
   * Returns the relayer's current time in millisecond
   */
  _proto.getRelayerCurrentTime =
  /*#__PURE__*/
  function () {
    var _getRelayerCurrentTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_RELAYER_CURRENT_TIME,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context.abrupt("return", _extends({}, raw_data, {
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getRelayerCurrentTime() {
      return _getRelayerCurrentTime.apply(this, arguments);
    }

    return getRelayerCurrentTime;
  }()
  /*
   * Returns Protocol Portrait
   */
  ;

  _proto.getProtocolPortrait =
  /*#__PURE__*/
  function () {
    var _getProtocolPortrait = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_PROTOCOL_PORTRAIT,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context2.abrupt("return", _extends({}, raw_data, {
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getProtocolPortrait() {
      return _getProtocolPortrait.apply(this, arguments);
    }

    return getProtocolPortrait;
  }()
  /*
   * Returns exchange fee info
   */
  ;

  _proto.getExchangeFeeInfo =
  /*#__PURE__*/
  function () {
    var _getExchangeFeeInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_EXCHANGE_FEEINFO,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context3.abrupt("return", {
                orderbookTradingFeesStablecoin: raw_data[exports.VipCatergory.ORDERBOOK_TRADING_FEES_STABLECOIN],
                orderbookTradingFees: raw_data[exports.VipCatergory.ORDERBOOK_TRADING_FEES],
                ammTradingFees: raw_data[exports.VipCatergory.AMM_TRADING_FEES],
                otherFees: raw_data[exports.VipCatergory.OTHER_FEES],
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getExchangeFeeInfo() {
      return _getExchangeFeeInfo.apply(this, arguments);
    }

    return getExchangeFeeInfo;
  }();

  _proto.getWithdrawalAgents = /*#__PURE__*/function () {
    var _getWithdrawalAgents = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request) {
      var reqParams, raw_data, supportTokenMap;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_WITHDRAWAL_AGENTS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              supportTokenMap = {};

              if (raw_data && raw_data.length > 0) {
                raw_data.forEach(function (item) {
                  if (item.symbol) {
                    supportTokenMap[item.symbol] = item;
                  }
                });
              }

              return _context4.abrupt("return", {
                supportTokenMap: supportTokenMap,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getWithdrawalAgents(_x) {
      return _getWithdrawalAgents.apply(this, arguments);
    }

    return getWithdrawalAgents;
  }();

  _proto.getRecommendedMarkets = /*#__PURE__*/function () {
    var _getRecommendedMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var reqParams, raw_data, recommended;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_RECOMENDED_MARKETS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context5.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context5.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              recommended = [];

              if (raw_data != null && raw_data.recommended) {
                if (typeof raw_data.recommended === "string") {
                  recommended = raw_data.recommended.split(",");
                } else {
                  recommended = raw_data.recommended;
                }
              }

              return _context5.abrupt("return", {
                recommended: recommended,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getRecommendedMarkets() {
      return _getRecommendedMarkets.apply(this, arguments);
    }

    return getRecommendedMarkets;
  }()
  /*
   * Returns the configurations of all supported markets (trading pairs)
   */
  ;

  _proto.getMarkets =
  /*#__PURE__*/
  function () {
    var _getMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(url) {
      var reqParams, raw_data, _makeMarkets, markets, pairs, tokenArr, tokenArrStr, marketArr, marketArrStr;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (url === void 0) {
                url = exports.LOOPRING_URLs.GET_MARKETS;
              }

              reqParams = {
                url: url,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context6.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context6.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context6.next = 7;
                break;
              }

              return _context6.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              _makeMarkets = makeMarkets(raw_data, url), markets = _makeMarkets.markets, pairs = _makeMarkets.pairs, tokenArr = _makeMarkets.tokenArr, tokenArrStr = _makeMarkets.tokenArrStr, marketArr = _makeMarkets.marketArr, marketArrStr = _makeMarkets.marketArrStr;
              return _context6.abrupt("return", {
                markets: markets,
                pairs: pairs,
                tokenArr: tokenArr,
                tokenArrStr: tokenArrStr,
                // tokenArrStr: tokenArr.join(SEP),
                marketArr: marketArr,
                marketArrStr: marketArrStr,
                // marketArrStr: marketArr.join(SEP),
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getMarkets(_x2) {
      return _getMarkets.apply(this, arguments);
    }

    return getMarkets;
  }()
  /*
   * Returns the configurations of all supported markets (trading pairs)
   */
  ;

  _proto.getMixMarkets =
  /*#__PURE__*/
  function () {
    var _getMixMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.getMarkets(exports.LOOPRING_URLs.GET_MIX_MARKETS);

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getMixMarkets() {
      return _getMixMarkets.apply(this, arguments);
    }

    return getMixMarkets;
  }()
  /*
   * Returns the configurations of all supported tokens, including Ether.
   */
  ;

  _proto.getTokens =
  /*#__PURE__*/
  function () {
    var _getTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_TOKENS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context8.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context8.next = 6;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context8.abrupt("return", _extends({}, makeMarket(raw_data), {
                // tokensMap,
                // coinMap,
                // totalCoinMap,
                // idIndex,
                // addressIndex,
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getTokens() {
      return _getTokens.apply(this, arguments);
    }

    return getTokens;
  }() // private splitTokens(token: string, tokens: LoopringMap<TokenInfo>) {
  //   let tokenArray: any = [];
  //   const tokenAddrArr: string[] = [];
  //
  //   if (tokens) {
  //     if (token) {
  //       tokenArray = token.split(SEP);
  //     }
  //
  //     if (
  //       tokenArray.length <= 0 ||
  //       (tokenArray.length === 1 && tokenArray[0] === "")
  //     ) {
  //       tokenArray = Reflect.ownKeys(tokens);
  //     }
  //
  //     tokenArray.forEach((item: string) => {
  //       tokenAddrArr.push(tokens[item].address);
  //     });
  //
  //     token = tokenAddrArr.join(SEP);
  //   }
  //
  //   return {
  //     tokenArray,
  //     token,
  //   };
  // }

  /*
   * Returns the balances of all supported tokens, including Ether.
   */
  ;

  _proto.getEthBalances =
  /*#__PURE__*/
  function () {
    var _getEthBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request) {
      var reqParams, raw_data, ethBalance;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_ETH_BALANCES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              ethBalance = raw_data.amount;
              return _context9.abrupt("return", {
                ethBalance: ethBalance,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getEthBalances(_x3) {
      return _getEthBalances.apply(this, arguments);
    }

    return getEthBalances;
  }()
  /*
   * Returns the balances of all supported tokens, including Ether.
   */
  ;

  _proto.getTokenBalances =
  /*#__PURE__*/
  function () {
    var _getTokenBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request) {
      var reqParams, raw_data, tokenBalances;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                queryParams: _extends({}, request, {
                  token: request.token.join(SEP)
                }),
                url: exports.LOOPRING_URLs.GET_TOKEN_BALANCES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              tokenBalances = new Map();

              if ((raw_data == null ? void 0 : raw_data.amount) instanceof Array) {
                raw_data.amount.forEach(function (value, index) {
                  // tokenBalances[tokenArray[index]] = raw_data.amount[index];
                  tokenBalances.set(request.token[index], value);
                });
              }

              return _context10.abrupt("return", {
                tokenBalances: tokenBalances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getTokenBalances(_x4) {
      return _getTokenBalances.apply(this, arguments);
    }

    return getTokenBalances;
  }();

  _proto.getAllTokenBalances = /*#__PURE__*/function () {
    var _getAllTokenBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              reqParams = {
                queryParams: _extends({}, request),
                url: exports.LOOPRING_URLs.GET_AKK_TOKEN_BALANCES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context11.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context11.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context11.next = 6;
                break;
              }

              return _context11.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context11.abrupt("return", {
                tokenBalances: raw_data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function getAllTokenBalances(_x5) {
      return _getAllTokenBalances.apply(this, arguments);
    }

    return getAllTokenBalances;
  }()
  /*
   * Returns the allowances of all supported tokens
   */
  ;

  _proto.getAllowances =
  /*#__PURE__*/
  function () {
    var _getAllowances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(request // tokens: any
    ) {
      var reqParams, raw_data, tokenAllowances;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              reqParams = {
                queryParams: _extends({}, request, {
                  token: request.token.join(SEP)
                }),
                url: exports.LOOPRING_URLs.GET_ALLOWANCES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context12.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context12.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context12.next = 6;
                break;
              }

              return _context12.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              tokenAllowances = new Map();

              if ((raw_data == null ? void 0 : raw_data.allowances) instanceof Array) {
                raw_data.allowances.forEach(function (value, index) {
                  tokenAllowances.set(request.token[index], value);
                });
              }

              return _context12.abrupt("return", {
                tokenAllowances: tokenAllowances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function getAllowances(_x6) {
      return _getAllowances.apply(this, arguments);
    }

    return getAllowances;
  }()
  /*
   * Return various configurations of Loopring.io
   */
  ;

  _proto.getExchangeInfo =
  /*#__PURE__*/
  function () {
    var _getExchangeInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
      var reqParams, raw_data, exchangeInfo;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_EXCHANGE_INFO,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context13.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context13.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context13.next = 6;
                break;
              }

              return _context13.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              exchangeInfo = {
                ammExitFees: getFeeMap(raw_data.ammExitFees),
                chainId: raw_data.chainId,
                depositAddress: raw_data.depositAddress,
                exchangeAddress: raw_data.exchangeAddress,
                fastWithdrawalFees: getFeeMap(raw_data.fastWithdrawalFees),
                onchainFees: getFeeMap(raw_data.onchainFees, 1),
                openAccountFees: getFeeMap(raw_data.openAccountFees),
                transferFees: getFeeMap(raw_data.transferFees),
                updateFees: getFeeMap(raw_data.updateFees),
                withdrawalFees: getFeeMap(raw_data.withdrawalFees)
              };
              return _context13.abrupt("return", {
                exchangeInfo: exchangeInfo,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function getExchangeInfo() {
      return _getExchangeInfo.apply(this, arguments);
    }

    return getExchangeInfo;
  }();

  _proto.getMixDepth = /*#__PURE__*/function () {
    var _getMixDepth = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(request) {
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.getDepth(request, exports.LOOPRING_URLs.GET_MIX_DEPTH);

            case 2:
              return _context14.abrupt("return", _context14.sent);

            case 3:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function getMixDepth(_x7) {
      return _getMixDepth.apply(this, arguments);
    }

    return getMixDepth;
  }()
  /*
   * Returns the order book of a given trading pair.
   */
  ;

  _proto.getDepth =
  /*#__PURE__*/
  function () {
    var _getDepth = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(request, url) {
      var reqParams, raw_data, timestamp, _getMidPrice, asks, bids, mid_price, depth;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (url === void 0) {
                url = exports.LOOPRING_URLs.GET_DEPTH;
              }

              if ((request == null ? void 0 : request.level) === undefined) {
                request.level = 0;
              }

              if ((request == null ? void 0 : request.limit) === undefined) {
                request.limit = 50;
              }

              reqParams = {
                queryParams: request,
                url: url,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context15.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context15.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context15.next = 9;
                break;
              }

              return _context15.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              timestamp = raw_data["timestamp"];
              _getMidPrice = getMidPrice({
                _asks: raw_data["asks"],
                _bids: raw_data["bids"]
              }), asks = _getMidPrice.asks, bids = _getMidPrice.bids, mid_price = _getMidPrice.mid_price;
              depth = {
                symbol: raw_data.market,
                version: parseInt(raw_data.version),
                timestamp: timestamp,
                mid_price: mid_price,
                bids: bids.ab_arr,
                bids_prices: bids.ab_prices,
                bids_amtTotals: bids.ab_amtTotals,
                bids_volTotals: bids.ab_volTotals,
                bids_amtTotal: bids.amtTotal.toString(),
                bids_volTotal: bids.volTotal.toString(),
                asks: asks.ab_arr,
                asks_prices: asks.ab_prices,
                asks_amtTotals: asks.ab_amtTotals,
                asks_volTotals: asks.ab_volTotals,
                asks_amtTotal: asks.amtTotal.toString(),
                asks_volTotal: asks.volTotal.toString()
              };
              return _context15.abrupt("return", {
                depth: depth,
                raw_data: raw_data
              });

            case 13:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function getDepth(_x8, _x9) {
      return _getDepth.apply(this, arguments);
    }

    return getDepth;
  }();

  _proto.getMixTicker = /*#__PURE__*/function () {
    var _getMixTicker = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request) {
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.getTicker(request, exports.LOOPRING_URLs.GET_MIX_TICKER);

            case 2:
              return _context16.abrupt("return", _context16.sent);

            case 3:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function getMixTicker(_x10) {
      return _getMixTicker.apply(this, arguments);
    }

    return getMixTicker;
  }()
  /*
   * Gets a markets ticker.
   * Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.
   */
  ;

  _proto.getTicker =
  /*#__PURE__*/
  function () {
    var _getTicker = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(request, url) {
      var reqParams, raw_data, tickers, tickMap, tickList;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (url === void 0) {
                url = exports.LOOPRING_URLs.GET_TICKER;
              }

              reqParams = {
                url: url,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context17.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context17.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context17.next = 7;
                break;
              }

              return _context17.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              tickers = raw_data.tickers;
              tickMap = {};
              tickList = [];

              if (tickers && tickers.length) {
                tickers.forEach(function (item, ind, arr) {
                  var open = parseFloat(item[4]);
                  var close = parseFloat(item[7]);
                  var symbol = item[0].replace("COMBINE-", "");

                  var _getBaseQuote = getBaseQuote(symbol),
                      base = _getBaseQuote.base,
                      quote = _getBaseQuote.quote;

                  var change = 0;

                  if (!isNaN(open) && !isNaN(close)) {
                    change = (close - open) / open;
                  }

                  var timestamp = parseInt(item[1]);
                  var tick = {
                    symbol: symbol,
                    base: base,
                    quote: quote,
                    timestamp: timestamp,
                    base_token_volume: item[2],
                    quote_token_volume: item[3],
                    open: open,
                    high: parseFloat(item[5]),
                    low: parseFloat(item[6]),
                    close: close,
                    count: parseInt(item[8]),
                    bid: parseFloat(item[9]),
                    ask: parseFloat(item[10]),
                    base_fee_amt: checkAmt(item[11]),
                    quote_fee_amt: checkAmt(item[12]),
                    change: change
                  };
                  tickMap[symbol] = tick;
                  tickList.push(tick);
                });
              }

              return _context17.abrupt("return", {
                tickMap: tickMap,
                tickList: tickList,
                raw_data: raw_data
              });

            case 12:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function getTicker(_x11, _x12) {
      return _getTicker.apply(this, arguments);
    }

    return getTicker;
  }();

  _proto.getAllMixTickers = /*#__PURE__*/function () {
    var _getAllMixTickers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(markets) {
      var request, result;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (markets === void 0) {
                markets = undefined;
              }

              if (markets) {
                _context18.next = 12;
                break;
              }

              _context18.next = 4;
              return this.getMixMarkets();

            case 4:
              result = _context18.sent;

              if (!result.marketArrStr) {
                _context18.next = 9;
                break;
              }

              request = {
                market: result.marketArrStr
              };
              _context18.next = 10;
              break;

            case 9:
              return _context18.abrupt("return", result);

            case 10:
              _context18.next = 13;
              break;

            case 12:
              request = {
                market: markets
              };

            case 13:
              _context18.next = 15;
              return this.getMixTicker(request);

            case 15:
              return _context18.abrupt("return", _context18.sent);

            case 16:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function getAllMixTickers(_x13) {
      return _getAllMixTickers.apply(this, arguments);
    }

    return getAllMixTickers;
  }();

  _proto.getAllTickers = /*#__PURE__*/function () {
    var _getAllTickers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(markets) {
      var request, result;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              if (markets === void 0) {
                markets = undefined;
              }

              if (markets) {
                _context19.next = 12;
                break;
              }

              _context19.next = 4;
              return this.getMarkets();

            case 4:
              result = _context19.sent;

              if (!result.marketArrStr) {
                _context19.next = 9;
                break;
              }

              request = {
                market: result.marketArrStr
              };
              _context19.next = 10;
              break;

            case 9:
              return _context19.abrupt("return", result);

            case 10:
              _context19.next = 13;
              break;

            case 12:
              request = {
                market: markets
              };

            case 13:
              _context19.next = 15;
              return this.getTicker(request);

            case 15:
              return _context19.abrupt("return", _context19.sent);

            case 16:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function getAllTickers(_x14) {
      return _getAllTickers.apply(this, arguments);
    }

    return getAllTickers;
  }();

  _proto.getMixCandlestick = /*#__PURE__*/function () {
    var _getMixCandlestick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(request) {
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.getCandlestick(request, exports.LOOPRING_URLs.GET_MIX_CANDLESTICK);

            case 2:
              return _context20.abrupt("return", _context20.sent);

            case 3:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getMixCandlestick(_x15) {
      return _getMixCandlestick.apply(this, arguments);
    }

    return getMixCandlestick;
  }()
  /*
   * Gets candlesticks.
   */
  ;

  _proto.getCandlestick =
  /*#__PURE__*/
  function () {
    var _getCandlestick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(request, url) {
      var reqParams, raw_data, tsStep, candlesticks, rawCandlesticks, lastCandlestick, lastTs;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              if (url === void 0) {
                url = exports.LOOPRING_URLs.GET_CANDLESTICK;
              }

              reqParams = {
                url: url,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context21.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context21.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context21.next = 7;
                break;
              }

              return _context21.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              tsStep = 60000;
              _context21.t0 = request.interval;
              _context21.next = _context21.t0 === exports.TradingInterval.min1 ? 11 : _context21.t0 === exports.TradingInterval.min5 ? 12 : _context21.t0 === exports.TradingInterval.min15 ? 14 : _context21.t0 === exports.TradingInterval.min30 ? 16 : _context21.t0 === exports.TradingInterval.hr1 ? 18 : _context21.t0 === exports.TradingInterval.hr2 ? 20 : _context21.t0 === exports.TradingInterval.hr4 ? 22 : _context21.t0 === exports.TradingInterval.hr12 ? 24 : _context21.t0 === exports.TradingInterval.d1 ? 26 : _context21.t0 === exports.TradingInterval.w1 ? 28 : 30;
              break;

            case 11:
              return _context21.abrupt("break", 31);

            case 12:
              tsStep = 300000;
              return _context21.abrupt("break", 31);

            case 14:
              tsStep = 900000;
              return _context21.abrupt("break", 31);

            case 16:
              tsStep = 1800000;
              return _context21.abrupt("break", 31);

            case 18:
              tsStep = 3600000;
              return _context21.abrupt("break", 31);

            case 20:
              tsStep = 7200000;
              return _context21.abrupt("break", 31);

            case 22:
              tsStep = 14400000;
              return _context21.abrupt("break", 31);

            case 24:
              tsStep = 43200000;
              return _context21.abrupt("break", 31);

            case 26:
              tsStep = 86400000;
              return _context21.abrupt("break", 31);

            case 28:
              tsStep = 604800000;
              return _context21.abrupt("break", 31);

            case 30:
              return _context21.abrupt("break", 31);

            case 31:
              candlesticks = [];

              if ((raw_data == null ? void 0 : raw_data.candlesticks) instanceof Array) {
                rawCandlesticks = raw_data.candlesticks.reverse();
                lastCandlestick = undefined;
                lastTs = -1;
                rawCandlesticks.forEach(function (item) {
                  var curTs = parseInt(item[0]);

                  if (lastCandlestick === undefined) {
                    lastTs = curTs;
                    var candlestick = {
                      timestamp: curTs,
                      txs: parseInt(item[1]),
                      open: parseFloat(item[2]),
                      close: parseFloat(item[3]),
                      high: parseFloat(item[4]),
                      low: parseFloat(item[5]),
                      baseVol: item[6],
                      quoteVol: item[7]
                    };
                    lastCandlestick = candlestick;
                    candlesticks.push(candlestick);
                  } else {
                    var counter = (curTs - lastTs) / tsStep; // myLog('counter:', curTs, lastTs, counter)

                    for (var i = 1; i <= counter; i++) {
                      var _candlestick = void 0;

                      if (i === counter) {
                        _candlestick = {
                          timestamp: lastTs + i * tsStep,
                          txs: parseInt(item[1]),
                          open: parseFloat(item[2]),
                          close: parseFloat(item[3]),
                          high: parseFloat(item[4]),
                          low: parseFloat(item[5]),
                          baseVol: item[6],
                          quoteVol: item[7]
                        };
                        lastTs = curTs;
                        lastCandlestick = _candlestick;
                      } else {
                        _candlestick = {
                          timestamp: lastTs + i * tsStep,
                          txs: 0,
                          open: lastCandlestick.close,
                          close: lastCandlestick.close,
                          high: lastCandlestick.close,
                          low: lastCandlestick.close,
                          baseVol: "0",
                          quoteVol: "0"
                        };
                      }

                      candlesticks.push(_candlestick);
                    }
                  }
                });
              }

              candlesticks = candlesticks.reverse();
              return _context21.abrupt("return", {
                candlesticks: candlesticks,
                raw_data: raw_data
              });

            case 35:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function getCandlestick(_x16, _x17) {
      return _getCandlestick.apply(this, arguments);
    }

    return getCandlestick;
  }()
  /*
   * Fetches, for all the tokens supported by Loopring, their fiat price.
   */
  ;

  _proto.getFiatPrice =
  /*#__PURE__*/
  function () {
    var _getFiatPrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(request) {
      var reqParams, raw_data, fiatPrices;
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_FIAT_PRICE,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context22.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context22.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context22.next = 6;
                break;
              }

              return _context22.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              fiatPrices = {};

              if ((raw_data == null ? void 0 : raw_data.prices) instanceof Array) {
                raw_data.prices.forEach(function (item) {
                  fiatPrices[item.symbol] = item;
                });
              }

              return _context22.abrupt("return", {
                fiatPrices: fiatPrices,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function getFiatPrice(_x18) {
      return _getFiatPrice.apply(this, arguments);
    }

    return getFiatPrice;
  }()
  /*
   * Fetches, for all the tokens supported by Loopring, their fiat price.
   */
  ;

  _proto.disableWithdrawTokenList =
  /*#__PURE__*/
  function () {
    var _disableWithdrawTokenList = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23() {
      var reqParams, raw_data, disableWithdrawTokenList;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_IGNORE_WITHDRAW,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context23.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context23.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context23.next = 6;
                break;
              }

              return _context23.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              disableWithdrawTokenList = [].concat(raw_data);
              return _context23.abrupt("return", {
                disableWithdrawTokenList: disableWithdrawTokenList,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function disableWithdrawTokenList() {
      return _disableWithdrawTokenList.apply(this, arguments);
    }

    return disableWithdrawTokenList;
  }()
  /*
   * Query trades with specified market
   */
  ;

  _proto.getMarketTrades =
  /*#__PURE__*/
  function () {
    var _getMarketTrades = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(request) {
      var reqParams, raw_data, marketTrades;
      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              if (request.limit === undefined) {
                request.limit = 20;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.GET_TRADES,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context24.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context24.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context24.next = 7;
                break;
              }

              return _context24.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              marketTrades = [];

              if ((raw_data == null ? void 0 : raw_data.trades) instanceof Array) {
                raw_data.trades.forEach(function (item) {
                  marketTrades.push({
                    tradeTime: parseInt(item[0]),
                    tradeId: item[1],
                    side: item[2],
                    volume: item[3],
                    price: item[4],
                    market: item[5],
                    fee: item[6],
                    type: item[13]
                  });
                });
              }

              return _context24.abrupt("return", {
                totalNum: raw_data.totalNum,
                marketTrades: marketTrades,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function getMarketTrades(_x19) {
      return _getMarketTrades.apply(this, arguments);
    }

    return getMarketTrades;
  }()
  /*
   * Returns data associated with the user's exchange account.
   */
  ;

  _proto.getAccount =
  /*#__PURE__*/
  function () {
    var _getAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(request) {
      var reqParams, raw_data, accInfo;
      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.ACCOUNT_ACTION,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context25.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context25.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context25.next = 6;
                break;
              }

              return _context25.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              accInfo = raw_data;
              return _context25.abrupt("return", {
                accInfo: accInfo,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function getAccount(_x20) {
      return _getAccount.apply(this, arguments);
    }

    return getAccount;
  }()
  /*
   */
  ;

  _proto.getEthNonce =
  /*#__PURE__*/
  function () {
    var _getEthNonce = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_ETH_NONCE,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context26.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context26.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context26.next = 6;
                break;
              }

              return _context26.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context26.abrupt("return", {
                nonce: raw_data == null ? void 0 : raw_data.nonce,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function getEthNonce(_x21) {
      return _getEthNonce.apply(this, arguments);
    }

    return getEthNonce;
  }()
  /*
   */
  ;

  _proto.getGasPrice =
  /*#__PURE__*/
  function () {
    var _getGasPrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27() {
      var reqParams, raw_data, gasPrice;
      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_GAS_PRICE,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context27.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context27.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context27.next = 6;
                break;
              }

              return _context27.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              gasPrice = raw_data == null ? void 0 : raw_data.price;
              return _context27.abrupt("return", {
                gasPrice: gasPrice,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function getGasPrice() {
      return _getGasPrice.apply(this, arguments);
    }

    return getGasPrice;
  }()
  /*
   */
  ;

  _proto.getGasPriceRange =
  /*#__PURE__*/
  function () {
    var _getGasPriceRange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28() {
      var reqParams, raw_data, gasPriceRanges;
      return runtime_1.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_GAS_PRICE_RANGE,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context28.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context28.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context28.next = 6;
                break;
              }

              return _context28.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              gasPriceRanges = raw_data == null ? void 0 : raw_data.ranges;
              return _context28.abrupt("return", {
                gasPriceRanges: gasPriceRanges,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function getGasPriceRange() {
      return _getGasPriceRange.apply(this, arguments);
    }

    return getGasPriceRange;
  }();

  _proto.getAccountServices = /*#__PURE__*/function () {
    var _getAccountServices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_ACCOUNT_SERVICES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context29.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context29.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context29.next = 6;
                break;
              }

              return _context29.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context29.abrupt("return", _extends({}, raw_data, {
                register: raw_data == null ? void 0 : raw_data.register,
                order: raw_data == null ? void 0 : raw_data.order,
                joinAmm: raw_data == null ? void 0 : raw_data.joinAmm,
                dAppTrade: raw_data == null ? void 0 : raw_data.dAppTrade,
                legal: raw_data == null ? void 0 : raw_data.dAppTrade,
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function getAccountServices(_x22) {
      return _getAccountServices.apply(this, arguments);
    }

    return getAccountServices;
  }();

  return ExchangeAPI;
}(BaseAPI);

var AmmpoolAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(AmmpoolAPI, _BaseAPI);

  function AmmpoolAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = AmmpoolAPI.prototype;

  /*
   * Returns the fee rate of users placing orders in specific markets
   */
  _proto.getAmmPoolConf =
  /*#__PURE__*/
  function () {
    var _getAmmPoolConf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var reqParams, raw_data, _makeAmmPool, ammpools, pairs;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMM_POOLS_CONF,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              _makeAmmPool = makeAmmPool(raw_data), ammpools = _makeAmmPool.ammpools, pairs = _makeAmmPool.pairs; // if (raw_data.code) {
              //   return {
              //     ...raw_data,
              //   };
              // }

              return _context.abrupt("return", {
                ammpools: ammpools,
                pairs: pairs,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAmmPoolConf() {
      return _getAmmPoolConf.apply(this, arguments);
    }

    return getAmmPoolConf;
  }()
  /*
   */
  ;

  _proto.getAmmPoolUserRewards =
  /*#__PURE__*/
  function () {
    var _getAmmPoolUserRewards = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request) {
      var reqParams, raw_data, ammUserRewardMap;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AMMPOOL_REWARDS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              ammUserRewardMap = {};

              if (raw_data != null && raw_data.current) {
                raw_data == null ? void 0 : raw_data.current.forEach(function (item) {
                  ammUserRewardMap[item.market] = {
                    current: item,
                    lastDay: undefined
                  };
                });
              }

              if (raw_data != null && raw_data.lastDay) {
                raw_data == null ? void 0 : raw_data.lastDay.forEach(function (item) {
                  ammUserRewardMap[item.market] = _extends({}, ammUserRewardMap[item.market], {
                    lastDay: item
                  });
                });
              }

              return _context2.abrupt("return", {
                ammUserRewardMap: ammUserRewardMap,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getAmmPoolUserRewards(_x) {
      return _getAmmPoolUserRewards.apply(this, arguments);
    }

    return getAmmPoolUserRewards;
  }()
  /*
   */
  ;

  _proto.getAmmPoolGameRank =
  /*#__PURE__*/
  function () {
    var _getAmmPoolGameRank = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request) {
      var reqParams, raw_data, totalRewards, userRankList;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AMMPOOL_GAME_RANK,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              totalRewards = raw_data != null && raw_data.totalRewards ? raw_data.totalRewards : [];
              userRankList = raw_data != null && raw_data.userRankList ? raw_data.userRankList : [];
              return _context3.abrupt("return", {
                totalRewards: totalRewards,
                userRankList: userRankList,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getAmmPoolGameRank(_x2) {
      return _getAmmPoolGameRank.apply(this, arguments);
    }

    return getAmmPoolGameRank;
  }()
  /*
   */
  ;

  _proto.getAmmPoolGameUserRank =
  /*#__PURE__*/
  function () {
    var _getAmmPoolGameUserRank = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request, apiKey) {
      var reqParams, raw_data, userRank;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                queryParams: request,
                apiKey: apiKey,
                url: exports.LOOPRING_URLs.GET_AMMPOOL_GAME_USER_RANK,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              userRank = raw_data.data;
              return _context4.abrupt("return", {
                userRank: userRank,
                raw_data: raw_data.data
              });

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getAmmPoolGameUserRank(_x3, _x4) {
      return _getAmmPoolGameUserRank.apply(this, arguments);
    }

    return getAmmPoolGameUserRank;
  }();

  _proto.getOrderList = function getOrderList(lst, order) {
    return lst.sort(function (a, b) {
      if (order === exports.SortOrder.ASC) {
        return a.rangeFrom < b.rangeFrom ? 1 : 0;
      }

      return a.rangeFrom > b.rangeFrom ? 1 : 0;
    });
  }
  /*
   */
  ;

  _proto.getAmmPoolActivityRules =
  /*#__PURE__*/
  function () {
    var _getAmmPoolActivityRules = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var reqParams, raw_data, activityInProgressRules, activityDateMap, groupByRuleType, groupByRuleTypeAndStatus, groupByActivityStatus, currentTs;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMM_ACTIVITY_RULES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context5.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context5.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              activityInProgressRules = {};
              activityDateMap = {}; //{AMM_MINING:{},ORDERBOOK_MINING:{},SWAP_VOLUME_RANKING:{}}

              groupByRuleType = {};
              groupByRuleTypeAndStatus = {};
              groupByActivityStatus = {};
              currentTs = new Date().getTime();

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  var _extends3, _extends4, _extends5, _extends6;

                  var status = currentTs < item.rangeFrom ? exports.AmmPoolActivityStatus.NotStarted : currentTs >= item.rangeFrom && currentTs <= item.rangeTo ? exports.AmmPoolActivityStatus.InProgress : exports.AmmPoolActivityStatus.EndOfGame;
                  item.status = status;

                  if (status === exports.AmmPoolActivityStatus.InProgress) {
                    var _extends2;

                    var ruleType = activityInProgressRules[item.market] ? [].concat(activityInProgressRules[item.market].ruleType, [item.ruleType]) : [item.ruleType];
                    activityInProgressRules = _extends({}, activityInProgressRules, (_extends2 = {}, _extends2[item.market] = _extends({}, item, {
                      ruleType: ruleType
                    }), _extends2));
                  }

                  groupByRuleType[item.ruleType] = [].concat(groupByRuleType[item.ruleType] ? groupByRuleType[item.ruleType] : [], [item]);
                  groupByActivityStatus[status] = [].concat(groupByActivityStatus[status] ? groupByActivityStatus[status] : [], [item]);
                  activityDateMap[item.rangeFrom] = _extends({}, activityDateMap[item.rangeFrom] ? activityDateMap[item.rangeFrom] : {}, (_extends4 = {}, _extends4[item.ruleType] = _extends({}, activityDateMap[item.rangeFrom] ? activityDateMap[item.rangeFrom][item.ruleType] ? activityDateMap[item.rangeFrom][item.ruleType] : {} : {}, (_extends3 = {}, _extends3[item.market] = item, _extends3)), _extends4));
                  groupByRuleTypeAndStatus = _extends({}, groupByRuleTypeAndStatus, (_extends6 = {}, _extends6[item.ruleType] = _extends({}, groupByRuleTypeAndStatus[item.ruleType] ? groupByRuleTypeAndStatus[item.ruleType] : {}, (_extends5 = {}, _extends5[status] = [].concat(groupByRuleTypeAndStatus[item.ruleType] ? groupByRuleTypeAndStatus[item.ruleType][status] ? groupByRuleTypeAndStatus[item.ruleType][status] : [] : [], [item]), _extends5)), _extends6));
                });
              }

              return _context5.abrupt("return", {
                activityInProgressRules: activityInProgressRules,
                activityDateMap: activityDateMap,
                groupByRuleType: groupByRuleType,
                groupByActivityStatus: groupByActivityStatus,
                groupByRuleTypeAndStatus: groupByRuleTypeAndStatus,
                raw_data: raw_data
              });

            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getAmmPoolActivityRules() {
      return _getAmmPoolActivityRules.apply(this, arguments);
    }

    return getAmmPoolActivityRules;
  }()
  /*
   */
  ;

  _proto.getAmmAssetHistory =
  /*#__PURE__*/
  function () {
    var _getAmmAssetHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(request) {
      var reqParams, raw_data, poolAddress, market, dataSeries;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AMM_ASSET_HISTORY,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context6.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context6.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context6.next = 6;
                break;
              }

              return _context6.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              poolAddress = raw_data.poolAddress;
              market = raw_data.market;
              dataSeries = raw_data.data;
              return _context6.abrupt("return", {
                poolAddress: poolAddress,
                market: market,
                dataSeries: dataSeries,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getAmmAssetHistory(_x5) {
      return _getAmmAssetHistory.apply(this, arguments);
    }

    return getAmmAssetHistory;
  }()
  /*
   */
  ;

  _proto.getAmmPoolStats =
  /*#__PURE__*/
  function () {
    var _getAmmPoolStats = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      var reqParams, raw_data, ammPoolStats;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMM_POOL_STATS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context7.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context7.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context7.next = 6;
                break;
              }

              return _context7.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              ammPoolStats = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  ammPoolStats[item.market] = item;
                });
              }

              return _context7.abrupt("return", {
                ammPoolStats: ammPoolStats,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getAmmPoolStats() {
      return _getAmmPoolStats.apply(this, arguments);
    }

    return getAmmPoolStats;
  }()
  /*
   */
  ;

  _proto.getAmmPoolSnapshot =
  /*#__PURE__*/
  function () {
    var _getAmmPoolSnapshot = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(request) {
      var reqParams, raw_data, ammPoolSnapshot;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMM_POOLS_SNAPSHOT,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context8.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context8.next = 6;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              ammPoolSnapshot = raw_data;
              return _context8.abrupt("return", {
                ammPoolSnapshot: ammPoolSnapshot,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getAmmPoolSnapshot(_x6) {
      return _getAmmPoolSnapshot.apply(this, arguments);
    }

    return getAmmPoolSnapshot;
  }()
  /*
   */
  ;

  _proto.getAmmPoolBalances =
  /*#__PURE__*/
  function () {
    var _getAmmPoolBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9() {
      var reqParams, raw_data, ammpoolsbalances;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMM_POOLS_BALANCES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              ammpoolsbalances = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  var tempPooled = {};

                  if ((item == null ? void 0 : item.pooled) instanceof Array) {
                    item.pooled.forEach(function (item2) {
                      tempPooled[item2.tokenId] = item2;
                    });
                  }

                  item.pooledMap = tempPooled;
                  var poolName = item.poolName;

                  if (poolName.indexOf("LRCETH") >= 0) {
                    poolName = "AMM-LRC-ETH";
                  }

                  ammpoolsbalances[poolName] = item;
                });
              }

              return _context9.abrupt("return", {
                ammpoolsbalances: ammpoolsbalances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getAmmPoolBalances() {
      return _getAmmPoolBalances.apply(this, arguments);
    }

    return getAmmPoolBalances;
  }()
  /*
   */
  ;

  _proto.getLiquidityMining =
  /*#__PURE__*/
  function () {
    var _getLiquidityMining = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                queryParams: request,
                apiKey: apiKey,
                url: exports.LOOPRING_URLs.GET_LIQUIDITY_MINING,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context10.abrupt("return", {
                rewards: raw_data != null && raw_data.data ? raw_data.data : [],
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getLiquidityMining(_x7, _x8) {
      return _getLiquidityMining.apply(this, arguments);
    }

    return getLiquidityMining;
  }()
  /*
   */
  ;

  _proto.getLiquidityMiningUserHistory =
  /*#__PURE__*/
  function () {
    var _getLiquidityMiningUserHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_LIQUIDITY_MINING_USER_HISTORY,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context11.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context11.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context11.next = 6;
                break;
              }

              return _context11.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context11.abrupt("return", {
                userMiningInfos: raw_data.data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function getLiquidityMiningUserHistory(_x9) {
      return _getLiquidityMiningUserHistory.apply(this, arguments);
    }

    return getLiquidityMiningUserHistory;
  }()
  /*
   */
  ;

  _proto.getUserAmmPoolTxs =
  /*#__PURE__*/
  function () {
    var _getUserAmmPoolTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              reqParams = {
                queryParams: request,
                apiKey: apiKey,
                url: exports.LOOPRING_URLs.GET_USER_AMM_POOL_TXS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context12.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context12.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context12.next = 6;
                break;
              }

              return _context12.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context12.abrupt("return", {
                totalNum: raw_data.totalNum,
                userAmmPoolTxs: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function getUserAmmPoolTxs(_x10, _x11) {
      return _getUserAmmPoolTxs.apply(this, arguments);
    }

    return getUserAmmPoolTxs;
  }()
  /*
   */
  ;

  _proto.getAmmPoolTxs =
  /*#__PURE__*/
  function () {
    var _getAmmPoolTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(request) {
      var reqParams, raw_data, transactions;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AMM_POOL_TXS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context13.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context13.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context13.next = 6;
                break;
              }

              return _context13.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              transactions = undefined;

              if (raw_data != null && raw_data.transactions) {
                transactions = raw_data == null ? void 0 : raw_data.transactions;
              }

              return _context13.abrupt("return", {
                totalNum: raw_data.totalNum,
                transactions: transactions,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function getAmmPoolTxs(_x12) {
      return _getAmmPoolTxs.apply(this, arguments);
    }

    return getAmmPoolTxs;
  }()
  /*
   */
  ;

  _proto.getAmmPoolTrades =
  /*#__PURE__*/
  function () {
    var _getAmmPoolTrades = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_AMM_POOL_TRADE_TXS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context14.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context14.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context14.next = 6;
                break;
              }

              return _context14.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context14.abrupt("return", {
                totalNum: raw_data.totalNum,
                ammPoolTrades: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function getAmmPoolTrades(_x13) {
      return _getAmmPoolTrades.apply(this, arguments);
    }

    return getAmmPoolTrades;
  }()
  /*
   */
  ;

  _proto.joinAmmPool =
  /*#__PURE__*/
  function () {
    var _joinAmmPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(request, patch, apiKey) {
      var reqParams, _sign_tools$get_Eddsa, eddsaSig, raw_data;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (!(request != null && request.validUntil)) request.validUntil = Date.now();
              reqParams = {
                bodyParams: request,
                apiKey: apiKey,
                url: exports.LOOPRING_URLs.POST_JOIN_AMM_POOL,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _sign_tools$get_Eddsa = get_EddsaSig_JoinAmmPool(request, patch), eddsaSig = _sign_tools$get_Eddsa.eddsaSig;
              request.eddsaSignature = eddsaSig;
              _context15.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context15.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context15.next = 9;
                break;
              }

              return _context15.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              return _context15.abrupt("return", {
                joinAmmPoolResult: raw_data,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function joinAmmPool(_x14, _x15, _x16) {
      return _joinAmmPool.apply(this, arguments);
    }

    return joinAmmPool;
  }()
  /*
   */
  ;

  _proto.exitAmmPool =
  /*#__PURE__*/
  function () {
    var _exitAmmPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request, patch, apiKey) {
      var reqParams, _sign_tools$get_Eddsa2, eddsaSig, raw_data;

      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (!(request != null && request.validUntil)) request.validUntil = Date.now();
              reqParams = {
                bodyParams: request,
                apiKey: apiKey,
                url: exports.LOOPRING_URLs.POST_EXIT_AMM_POOL,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _sign_tools$get_Eddsa2 = get_EddsaSig_ExitAmmPool(request, patch), eddsaSig = _sign_tools$get_Eddsa2.eddsaSig;
              request.eddsaSignature = eddsaSig;
              _context16.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context16.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context16.next = 9;
                break;
              }

              return _context16.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              return _context16.abrupt("return", {
                exitAmmPoolResult: raw_data,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function exitAmmPool(_x17, _x18, _x19) {
      return _exitAmmPool.apply(this, arguments);
    }

    return exitAmmPool;
  }();

  return AmmpoolAPI;
}(BaseAPI);

(function (ERC20Method) {
  ERC20Method["Approve"] = "approve";
  ERC20Method["Deposit"] = "deposit";
  ERC20Method["ForceWithdraw"] = "forceWithdraw";
})(exports.ERC20Method || (exports.ERC20Method = {}));

var ApproveVal = {
  Zero: "0x0",
  Max: "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
};

function checkWeb3(web3) {
  if (!web3) throw new Error("got undefined web3");
}
/**
 * @description sign hash
 * @param web3
 * @param account
 * @param hash
 * @returns {Promise.<*>}
 */


function sign(_x, _x2, _x3, _x4) {
  return _sign.apply(this, arguments);
}
/**
 * @description Signs ethereum tx
 * @param web3
 * @param account
 * @param rawTx
 * @returns {Promise.<*>}
 */

function _sign() {
  _sign = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(web3, account, pwd, hash) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            checkWeb3(web3);
            return _context.abrupt("return", new Promise(function (resolve) {
              web3.eth.sign(hash, account, pwd, function (err, result) {
                if (!err) {
                  var r = result.slice(0, 66);
                  var s = addHexPrefix(result.slice(66, 130));
                  var v = toNumber(addHexPrefix(result.slice(130, 132)));
                  if (v === 0 || v === 1) v = v + 27; // 修复ledger的签名

                  // 修复ledger的签名
                  resolve({
                    result: {
                      r: r,
                      s: s,
                      v: v
                    }
                  });
                } else {
                  var errorMsg = err.message.substring(0, err.message.indexOf(" at "));
                  resolve({
                    error: {
                      message: errorMsg
                    }
                  });
                }
              });
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sign.apply(this, arguments);
}

function signEthereumTx(_x5, _x6, _x7, _x8) {
  return _signEthereumTx.apply(this, arguments);
}

function _signEthereumTx() {
  _signEthereumTx = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(web3, account, rawTx, chainId) {
    var ethTx, hash, response, signature, jsonTx;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            ethTx = tx.Transaction.fromSerializedTx(rawTx);
            hash = toHex(ethTx.hash());
            _context2.prev = 2;
            _context2.next = 5;
            return sign(web3, account, "", hash);

          case 5:
            response = _context2.sent;

            if (response.error) {
              _context2.next = 14;
              break;
            }

            signature = response["result"];
            signature.v += chainId * 2 + 8;
            jsonTx = Object.assign(ethTx.toJSON(), signature);
            jsonTx.from = rawTx.from;
            return _context2.abrupt("return", {
              result: toHex(JSON.stringify(jsonTx)),
              rawTx: jsonTx
            });

          case 14:
            return _context2.abrupt("return", {
              error: response.error
            });

          case 15:
            _context2.next = 20;
            break;

          case 17:
            _context2.prev = 17;
            _context2.t0 = _context2["catch"](2);
            return _context2.abrupt("return", {
              error: _context2.t0
            });

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 17]]);
  }));
  return _signEthereumTx.apply(this, arguments);
}

function getNonce(_x9, _x10) {
  return _getNonce.apply(this, arguments);
}

function _getNonce() {
  _getNonce = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(web3, addr) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!web3) {
              _context3.next = 4;
              break;
            }

            _context3.next = 3;
            return web3.eth.getTransactionCount(addr);

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
            return _context3.abrupt("return", -1);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getNonce.apply(this, arguments);
}

function sendRawTx(_x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19, _x20) {
  return _sendRawTx.apply(this, arguments);
}

function _sendRawTx() {
  _sendRawTx = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(web3, from, to, value, data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask) {
    var rawTx, res;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (sendByMetaMask === void 0) {
              sendByMetaMask = true;
            }

            checkWeb3(web3);
            gasPrice = fromGWEI(gasPrice).toNumber();
            rawTx = {
              from: from,
              to: to,
              value: value,
              data: data,
              chainId: chainId,
              nonce: nonce,
              gasPrice: gasPrice,
              gasLimit: gasLimit
            };

            if (!sendByMetaMask) {
              _context4.next = 8;
              break;
            }

            _context4.next = 7;
            return sendTransaction(web3, rawTx);

          case 7:
            return _context4.abrupt("return", _context4.sent);

          case 8:
            _context4.next = 10;
            return signEthereumTx(web3, from, rawTx, chainId);

          case 10:
            res = _context4.sent;

            if (!(res != null && res.rawTx)) {
              _context4.next = 15;
              break;
            }

            _context4.next = 14;
            return sendTransaction(web3, res.rawTx);

          case 14:
            return _context4.abrupt("return", _context4.sent);

          case 15:
            return _context4.abrupt("return", res);

          case 16:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _sendRawTx.apply(this, arguments);
}

function _genContractData(Contract, method, data) {
  return Contract.encodeInputs(method, data);
}

function genERC20Data(method, data) {
  return _genContractData(Contracts.ERC20Token, method, data);
}

function genExchangeData(method, data) {
  return _genContractData(Contracts.ExchangeContract, method, data);
}
function approve(_x21, _x22, _x23, _x24, _x25, _x26, _x27, _x28, _x29, _x30) {
  return _approve.apply(this, arguments);
} // 3.6

/**
 * Approve Zero
 * @param tokenAddress: approve token symbol to zero
 * @param nonce: Ethereum nonce of this address
 * @param gasPrice: gas price in gwei
 * @param sendByMetaMask
 */

function _approve() {
  _approve = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(web3, from, to, depositAddress, _value, chainId, nonce, gasPrice, gasLimit, sendByMetaMask) {
    var data;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            data = genERC20Data(exports.ERC20Method.Approve, {
              _spender: depositAddress,
              _value: _value
            });
            _context5.next = 3;
            return sendRawTx(web3, from, to, "0", data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

          case 3:
            return _context5.abrupt("return", _context5.sent);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _approve.apply(this, arguments);
}

function approveZero(_x31, _x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39) {
  return _approveZero.apply(this, arguments);
} // 3.6

/**
 * Approve Max
 * @param tokenAddress: approve token symbol to max
 * @param nonce: Ethereum nonce of this address
 * @param gasPrice: gas price in gwei
 * @param sendByMetaMask
 */

function _approveZero() {
  _approveZero = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(web3, owner, tokenAddress, depositAddress, gasPrice, gasLimit, chainId, nonce, sendByMetaMask) {
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (chainId === void 0) {
              chainId = exports.ChainId.GOERLI;
            }

            if (sendByMetaMask === void 0) {
              sendByMetaMask = false;
            }

            _context6.next = 4;
            return approve(web3, owner, tokenAddress, depositAddress, ApproveVal.Zero, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

          case 4:
            return _context6.abrupt("return", _context6.sent);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _approveZero.apply(this, arguments);
}

function approveMax(_x40, _x41, _x42, _x43, _x44, _x45, _x46, _x47, _x48) {
  return _approveMax.apply(this, arguments);
} // 3.6

/**
 * deposit
 */

function _approveMax() {
  _approveMax = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(web3, owner, tokenAddress, depositAddress, gasPrice, gasLimit, chainId, nonce, sendByMetaMask) {
    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (chainId === void 0) {
              chainId = exports.ChainId.GOERLI;
            }

            if (sendByMetaMask === void 0) {
              sendByMetaMask = false;
            }

            _context7.next = 4;
            return approve(web3, owner, tokenAddress, depositAddress, ApproveVal.Max, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

          case 4:
            return _context7.abrupt("return", _context7.sent);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _approveMax.apply(this, arguments);
}

function deposit(_x49, _x50, _x51, _x52, _x53, _x54, _x55, _x56, _x57, _x58, _x59, _x60) {
  return _deposit.apply(this, arguments);
}
/**
 * forceWithdrawal
 */

function _deposit() {
  _deposit = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(web3, from, exchangeAddress, token, value, fee, gasPrice, gasLimit, chainId, nonce, sendByMetaMask, to) {
    var valueC, amount, data;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (chainId === void 0) {
              chainId = exports.ChainId.GOERLI;
            }

            if (sendByMetaMask === void 0) {
              sendByMetaMask = true;
            }

            valueC = toBig(value).times("1e" + token.decimals);
            amount = toHex(valueC);
            data = genExchangeData(exports.ERC20Method.Deposit, {
              tokenAddress: token.address,
              amount: amount,
              from: from,
              to: to ? to : from,
              extraData: ""
            });

            if (token.type === "ETH") {
              valueC = valueC.plus(fee);
            } else {
              valueC = toBig(fee);
            }

            _context8.next = 8;
            return sendRawTx(web3, from, exchangeAddress, valueC.toFixed(), data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

          case 8:
            return _context8.abrupt("return", _context8.sent);

          case 9:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _deposit.apply(this, arguments);
}

function forceWithdrawal(_x61, _x62, _x63, _x64, _x65, _x66, _x67, _x68, _x69, _x70, _x71) {
  return _forceWithdrawal.apply(this, arguments);
}
/**
 * @description Sends ethereum tx through MetaMask
 * @param web3
 * @param tx
 * @returns {*}
 */

function _forceWithdrawal() {
  _forceWithdrawal = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(web3, from, accountID, exchangeAddress, token, fee, gasPrice, gasLimit, chainId, nonce, sendByMetaMask) {
    var valueC, data;
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (chainId === void 0) {
              chainId = exports.ChainId.GOERLI;
            }

            if (sendByMetaMask === void 0) {
              sendByMetaMask = false;
            }

            valueC = toBig(fee);
            data = genExchangeData(exports.ERC20Method.ForceWithdraw, {
              owner: from,
              tokenAddress: token.address,
              accountID: accountID
            });
            _context9.next = 6;
            return sendRawTx(web3, from, exchangeAddress, valueC.toFixed(), data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

          case 6:
            return _context9.abrupt("return", _context9.sent);

          case 7:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _forceWithdrawal.apply(this, arguments);
}

function sendTransaction(_x72, _x73) {
  return _sendTransaction.apply(this, arguments);
}

function _sendTransaction() {
  _sendTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(web3, tx) {
    var response;
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            delete tx.gasPrice; // delete tx.gas;

            _context10.next = 3;
            return new Promise(function (resolve) {
              web3.eth.sendTransaction(tx, function (err, transactionHash) {
                if (!err) {
                  resolve({
                    result: transactionHash
                  });
                } else {
                  resolve({
                    error: {
                      message: err.message
                    }
                  });
                }
              });
            });

          case 3:
            response = _context10.sent;

            if (!response["result"]) {
              _context10.next = 8;
              break;
            }

            return _context10.abrupt("return", response);

          case 8:
            throw new Error(response["error"]["message"]);

          case 9:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _sendTransaction.apply(this, arguments);
}

function isContract(_x74, _x75) {
  return _isContract.apply(this, arguments);
}

function _isContract() {
  _isContract = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(web3, address) {
    var code;
    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return web3.eth.getCode(address);

          case 2:
            code = _context11.sent;
            return _context11.abrupt("return", code && code.length > 2);

          case 4:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _isContract.apply(this, arguments);
}

var _excluded$1 = ["collection"],
    _excluded2$1 = ["collection"],
    _excluded3 = ["collection"];
var UserAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(UserAPI, _BaseAPI);

  function UserAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = UserAPI.prototype;

  /*
   * Change the ApiKey associated with the user's account.
   * The current ApiKey must be provided as the value of the X-API-KEY HTTP header.
   */
  _proto.updateUserApiKey =
  /*#__PURE__*/
  function () {
    var _updateUserApiKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request, apiKey, eddsaKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("accountId", request.accountId);
              reqParams = {
                url: exports.LOOPRING_URLs.API_KEY_ACTION,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              return _context.abrupt("return", {
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function updateUserApiKey(_x, _x2, _x3) {
      return _updateUserApiKey.apply(this, arguments);
    }

    return updateUserApiKey;
  }()
  /*
   * Fetches the next order id for a given sold token.
   * If the need arises to repeatedly place orders in a short span of time,
   * the order id can be initially fetched through the API and then managed locally.
   * Each new order id can be derived from adding 2 to the last one
   */
  ;

  _proto.getNextStorageId =
  /*#__PURE__*/
  function () {
    var _getNextStorageId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request, apiKey) {
      var reqParams, raw_data, orderId, offchainId;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NEXT_STORAGE_ID,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              orderId = raw_data.orderId, offchainId = raw_data.offchainId;
              return _context2.abrupt("return", {
                orderId: orderId,
                offchainId: offchainId,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getNextStorageId(_x4, _x5) {
      return _getNextStorageId.apply(this, arguments);
    }

    return getNextStorageId;
  }()
  /*
   * Get the details of an order based on order hash.
   */
  ;

  _proto.getOrderDetails =
  /*#__PURE__*/
  function () {
    var _getOrderDetails = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.ORDER_ACTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context3.abrupt("return", {
                orderDetail: raw_data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getOrderDetails(_x6, _x7) {
      return _getOrderDetails.apply(this, arguments);
    }

    return getOrderDetails;
  }();

  _proto.getOrders = /*#__PURE__*/function () {
    var _getOrders = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request, apiKey) {
      var reqParams, raw_data, totalNum, orders;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_MULTI_ORDERS,
                queryParams: _extends({}, request, {
                  status: request.status ? request.status.join(",") : ""
                }),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              totalNum = raw_data.totalNum;
              orders = raw_data.orders;
              return _context4.abrupt("return", {
                totalNum: totalNum,
                orders: orders,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getOrders(_x8, _x9) {
      return _getOrders.apply(this, arguments);
    }

    return getOrders;
  }()
  /*
   * Submit an order
   */
  ;

  _proto.submitOrder =
  /*#__PURE__*/
  function () {
    var _submitOrder = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(orderRequest, privateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!orderRequest.tradeChannel) {
                orderRequest.tradeChannel = exports.TradeChannel.MIXED;
              }

              dataToSig = [orderRequest.exchange, orderRequest.storageId, orderRequest.accountId, orderRequest.sellToken.tokenId, orderRequest.buyToken.tokenId, orderRequest.sellToken.volume, orderRequest.buyToken.volume, orderRequest.validUntil, orderRequest.maxFeeBips, orderRequest.fillAmountBOrS ? 1 : 0, 0];
              reqParams = {
                url: exports.LOOPRING_URLs.ORDER_ACTION,
                bodyParams: orderRequest,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG_POSEIDON,
                sigObj: {
                  dataToSig: dataToSig,
                  sigPatch: exports.SigPatchField.EddsaSignature,
                  PrivateKey: privateKey
                }
              };
              _context5.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context5.sent.data;
              return _context5.abrupt("return", this.returnTxHash(raw_data));

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function submitOrder(_x10, _x11, _x12) {
      return _submitOrder.apply(this, arguments);
    }

    return submitOrder;
  }()
  /*
   * Cancel order using order hash or client-side ID.
   */
  ;

  _proto.cancelOrder =
  /*#__PURE__*/
  function () {
    var _cancelOrder = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(request, PrivateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("accountId", request.accountId);
              if (request.orderHash) dataToSig.set("orderHash", request.orderHash);
              if (request.clientOrderId) dataToSig.set("clientOrderId", request.clientOrderId);
              reqParams = {
                url: exports.LOOPRING_URLs.ORDER_ACTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.DELETE,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: PrivateKey
                }
              };
              _context6.next = 7;
              return this.makeReq().request(reqParams);

            case 7:
              raw_data = _context6.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context6.next = 10;
                break;
              }

              return _context6.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 10:
              return _context6.abrupt("return", {
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function cancelOrder(_x13, _x14, _x15) {
      return _cancelOrder.apply(this, arguments);
    }

    return cancelOrder;
  }()
  /*
   * Cancel multiple orders using order hashes
   */
  ;

  _proto.cancelMultiOrdersByHash =
  /*#__PURE__*/
  function () {
    var _cancelMultiOrdersByHash = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(request, PrivateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("accountId", request.accountId);
              dataToSig.set("orderHash", request.orderHash);
              reqParams = {
                url: exports.LOOPRING_URLs.ORDER_CANCEL_HASH_LIST,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.DELETE,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: PrivateKey
                }
              };
              _context7.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context7.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context7.next = 9;
                break;
              }

              return _context7.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              return _context7.abrupt("return", {
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function cancelMultiOrdersByHash(_x16, _x17, _x18) {
      return _cancelMultiOrdersByHash.apply(this, arguments);
    }

    return cancelMultiOrdersByHash;
  }()
  /*
   * Cancel multiple orders using clientOrderIds
   */
  ;

  _proto.cancelMultiOrdersByCreditOrderId =
  /*#__PURE__*/
  function () {
    var _cancelMultiOrdersByCreditOrderId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(request, PrivateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("accountId", request.accountId);
              dataToSig.set("clientOrderId", request.clientOrderId);
              reqParams = {
                url: exports.LOOPRING_URLs.ORDER_CANCEL_CLIENT_ORDER_ID_LIST,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.DELETE,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: PrivateKey
                }
              };
              _context8.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context8.next = 9;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              return _context8.abrupt("return", {
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function cancelMultiOrdersByCreditOrderId(_x19, _x20, _x21) {
      return _cancelMultiOrdersByCreditOrderId.apply(this, arguments);
    }

    return cancelMultiOrdersByCreditOrderId;
  }()
  /*
   * Returns a list Ethereum transactions from users for exchange account registration.
   */
  ;

  _proto.getUserRegTxs =
  /*#__PURE__*/
  function () {
    var _getUserRegTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request, apiKey) {
      var reqParams, raw_data, userRegTxs;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_REG_TXS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userRegTxs = raw_data.transactions;
              return _context9.abrupt("return", {
                totalNum: raw_data.totalNum,
                userRegTxs: userRegTxs,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getUserRegTxs(_x22, _x23) {
      return _getUserRegTxs.apply(this, arguments);
    }

    return getUserRegTxs;
  }()
  /*
   * Returns a list Ethereum transactions from users for resetting exchange passwords.
   */
  ;

  _proto.getUserPwdResetTxs =
  /*#__PURE__*/
  function () {
    var _getUserPwdResetTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request, apiKey) {
      var reqParams, raw_data, userPwdResetTxs;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_PWD_RESET_TXS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userPwdResetTxs = raw_data.transactions;
              return _context10.abrupt("return", {
                totalNum: raw_data.totalNum,
                userPwdResetTxs: userPwdResetTxs,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getUserPwdResetTxs(_x24, _x25) {
      return _getUserPwdResetTxs.apply(this, arguments);
    }

    return getUserPwdResetTxs;
  }()
  /*
   * Returns user's Ether and token balances on exchange.
   */
  ;

  _proto.getUserBalances =
  /*#__PURE__*/
  function () {
    var _getUserBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(request, apiKey) {
      var reqParams, raw_data, userBalances;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_EXCHANGE_BALANCES,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context11.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context11.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context11.next = 6;
                break;
              }

              return _context11.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userBalances = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  userBalances[item.tokenId] = item;
                });
              }

              return _context11.abrupt("return", {
                userBalances: userBalances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function getUserBalances(_x26, _x27) {
      return _getUserBalances.apply(this, arguments);
    }

    return getUserBalances;
  }();

  _proto.getAssetLookRecords = /*#__PURE__*/function () {
    var _getAssetLookRecords = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(request, apiKey) {
      var reqParams, raw_data, userBalances;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_ASSET_LOCK_RECORDS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context12.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context12.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context12.next = 6;
                break;
              }

              return _context12.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userBalances = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  userBalances[item.tokenId] = item;
                });
              }

              return _context12.abrupt("return", {
                userBalances: userBalances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function getAssetLookRecords(_x28, _x29) {
      return _getAssetLookRecords.apply(this, arguments);
    }

    return getAssetLookRecords;
  }()
  /*
   * Returns user's deposit records.
   */
  ;

  _proto.getUserDepositHistory =
  /*#__PURE__*/
  function () {
    var _getUserDepositHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_DEPOSITS_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context13.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context13.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context13.next = 6;
                break;
              }

              return _context13.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context13.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userDepositHistory: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function getUserDepositHistory(_x30, _x31) {
      return _getUserDepositHistory.apply(this, arguments);
    }

    return getUserDepositHistory;
  }()
  /*
   * Get user onchain withdrawal history.
   */
  ;

  _proto.getUserOnchainWithdrawalHistory =
  /*#__PURE__*/
  function () {
    var _getUserOnchainWithdrawalHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.WITHDRAWALS_ACTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context14.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context14.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context14.next = 6;
                break;
              }

              return _context14.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context14.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userOnchainWithdrawalHistory: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function getUserOnchainWithdrawalHistory(_x32, _x33) {
      return _getUserOnchainWithdrawalHistory.apply(this, arguments);
    }

    return getUserOnchainWithdrawalHistory;
  }()
  /*
   * Get user transfer list.
   */
  ;

  _proto.getUserTransferList =
  /*#__PURE__*/
  function () {
    var _getUserTransferList = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_TRANSFERS_LIST,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context15.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context15.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context15.next = 6;
                break;
              }

              return _context15.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context15.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userTransfers: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function getUserTransferList(_x34, _x35) {
      return _getUserTransferList.apply(this, arguments);
    }

    return getUserTransferList;
  }()
  /*
   * Get user txs
   */
  ;

  _proto.getUserTxs =
  /*#__PURE__*/
  function () {
    var _getUserTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request, apiKey) {
      var reqParams, raw_data, userTxs;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_TXS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context16.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context16.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context16.next = 6;
                break;
              }

              return _context16.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userTxs = [];

              if ((raw_data == null ? void 0 : raw_data.transactions) instanceof Array) {
                raw_data.transactions.forEach(function (item) {
                  userTxs.push(item);
                });
              }

              return _context16.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userTxs: userTxs,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function getUserTxs(_x36, _x37) {
      return _getUserTxs.apply(this, arguments);
    }

    return getUserTxs;
  }()
  /*
   * Get user trade history
   */
  ;

  _proto.getUserTrades =
  /*#__PURE__*/
  function () {
    var _getUserTrades = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(request, apiKey) {
      var reqParams, raw_data, userTrades;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_TRADE_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context17.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context17.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context17.next = 6;
                break;
              }

              return _context17.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userTrades = [];

              if ((raw_data == null ? void 0 : raw_data.trades) instanceof Array) {
                raw_data.trades.forEach(function (item) {
                  userTrades.push({
                    tradeTime: item[0],
                    tradeId: item[1],
                    side: item[2],
                    volume: item[3],
                    price: item[4],
                    market: item[5],
                    fee: item[6],
                    type: item[13]
                  });
                });
              }

              return _context17.abrupt("return", {
                totalNum: raw_data.totalNum,
                userTrades: userTrades,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function getUserTrades(_x38, _x39) {
      return _getUserTrades.apply(this, arguments);
    }

    return getUserTrades;
  }()
  /*
   * deprecated
   * Returns the fee rate of users placing orders in specific markets
   */
  ;

  _proto.getUserFeeRate =
  /*#__PURE__*/
  function () {
    var _getUserFeeRate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(request, apiKey) {
      var reqParams, raw_data, userFreeRateMap;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_FEE_RATE,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context18.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context18.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context18.next = 6;
                break;
              }

              return _context18.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userFreeRateMap = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  userFreeRateMap[item.symbol] = item;
                });
              }

              return _context18.abrupt("return", {
                userFreeRateMap: userFreeRateMap,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function getUserFeeRate(_x40, _x41) {
      return _getUserFeeRate.apply(this, arguments);
    }

    return getUserFeeRate;
  }()
  /*
   * Returns the user order fee rate of users placing orders in specific markets
   */
  ;

  _proto.getUserOrderFeeRate =
  /*#__PURE__*/
  function () {
    var _getUserOrderFeeRate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(request, apiKey) {
      var reqParams, raw_data, gasPrice;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_ORDER_FEE_RATE,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context19.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context19.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context19.next = 6;
                break;
              }

              return _context19.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              gasPrice = parseInt(raw_data.gasPrice);
              return _context19.abrupt("return", {
                feeRate: raw_data.feeRate,
                gasPrice: gasPrice,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function getUserOrderFeeRate(_x42, _x43) {
      return _getUserOrderFeeRate.apply(this, arguments);
    }

    return getUserOrderFeeRate;
  }()
  /*
   * Query current token minimum amount to place order based on users VIP level and max fee bips
   */
  ;

  _proto.getMinimumTokenAmt =
  /*#__PURE__*/
  function () {
    var _getMinimumTokenAmt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(request, apiKey) {
      var reqParams, raw_data, gasPrice, amounts, amountMap;
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_MINIMUM_TOKEN_AMT,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context20.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context20.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context20.next = 6;
                break;
              }

              return _context20.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              gasPrice = parseInt(raw_data.gasPrice);
              amounts = raw_data == null ? void 0 : raw_data.amounts;
              amountMap = {};

              if (amounts instanceof Array) {
                amounts.forEach(function (item) {
                  amountMap[item.tokenSymbol] = item;
                });
              }

              return _context20.abrupt("return", {
                amounts: amounts,
                amountMap: amountMap,
                gasPrice: gasPrice,
                cacheOverdueAt: raw_data.cacheOverdueAt,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getMinimumTokenAmt(_x44, _x45) {
      return _getMinimumTokenAmt.apply(this, arguments);
    }

    return getMinimumTokenAmt;
  }()
  /*
   * Query current fee amount
   */
  ;

  _proto.getOffchainFeeAmt =
  /*#__PURE__*/
  function () {
    var _getOffchainFeeAmt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(request, apiKey) {
      var reqParams, raw_data, gasPrice, fees;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_OFFCHAIN_FEE_AMT,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context21.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context21.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context21.next = 6;
                break;
              }

              return _context21.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              gasPrice = parseInt(raw_data.gasPrice);
              fees = {};

              if ((raw_data == null ? void 0 : raw_data.fees) instanceof Array) {
                raw_data.fees.forEach(function (item) {
                  fees[item.token] = item;
                });
              }

              return _context21.abrupt("return", {
                fees: fees,
                gasPrice: gasPrice,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function getOffchainFeeAmt(_x46, _x47) {
      return _getOffchainFeeAmt.apply(this, arguments);
    }

    return getOffchainFeeAmt;
  }()
  /*
   * Query current NFTAction fee amount
   */
  ;

  _proto.getNFTOffchainFeeAmt =
  /*#__PURE__*/
  function () {
    var _getNFTOffchainFeeAmt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(request, apiKey) {
      var reqParams, raw_data, fees;
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_OFFCHAIN_FEE_AMT,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context22.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context22.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context22.next = 6;
                break;
              }

              return _context22.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              fees = {};

              if ((raw_data == null ? void 0 : raw_data.fees) instanceof Array) {
                raw_data.fees.forEach(function (item) {
                  fees[item.token] = item;
                });
              }

              return _context22.abrupt("return", {
                fees: fees,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function getNFTOffchainFeeAmt(_x48, _x49) {
      return _getNFTOffchainFeeAmt.apply(this, arguments);
    }

    return getNFTOffchainFeeAmt;
  }()
  /*
   * Submit NFTAction Validate Order request
   */
  ;

  _proto.submitNFTValidateOrder =
  /*#__PURE__*/
  function () {
    var _submitNFTValidateOrder = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(req) {
      var request, eddsaKey, apiKey, reqParams, raw_data;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              request = req.request, eddsaKey = req.eddsaKey, apiKey = req.apiKey;
              request.eddsaSignature = get_EddsaSig_NFT_Order(request, eddsaKey).result;
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_VALIDATE_ORDER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              }; // myLog("NFTAction Validate Order request", request);

              _context23.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context23.sent.data;
              return _context23.abrupt("return", this.returnTxHash(raw_data));

            case 7:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function submitNFTValidateOrder(_x50) {
      return _submitNFTValidateOrder.apply(this, arguments);
    }

    return submitNFTValidateOrder;
  }()
  /*
   * Submit NFTAction Trade request
   */
  ;

  _proto.submitNFTTrade =
  /*#__PURE__*/
  function () {
    var _submitNFTTrade = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(req) {
      var request, apiKey, eddsaKey, dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              request = req.request, apiKey = req.apiKey, eddsaKey = req.eddsaKey;
              dataToSig = new Map();
              dataToSig.set("maker", request.maker);
              dataToSig.set("makerFeeBips", request.makerFeeBips);
              dataToSig.set("taker", request.taker);
              dataToSig.set("takerFeeBips", request.takerFeeBips); // request.eddsaSignature = sign_tools.get_EddsaSig_Transfer(
              //   request,
              //   eddsaKey
              // );

              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_TRADE,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  // sigPatch: SigPatchField.EddsaSignature,
                  PrivateKey: eddsaKey
                }
              }; // myLog("NFTAction Trade request", request);

              _context24.next = 9;
              return this.makeReq().request(reqParams);

            case 9:
              raw_data = _context24.sent.data;
              return _context24.abrupt("return", this.returnTxHash(raw_data));

            case 11:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function submitNFTTrade(_x51) {
      return _submitNFTTrade.apply(this, arguments);
    }

    return submitNFTTrade;
  }();

  _proto.getUserOwenCollection = /*#__PURE__*/function () {
    var _getUserOwenCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_COLLECTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context25.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context25.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context25.next = 6;
                break;
              }

              return _context25.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              return _context25.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                collections: raw_data.collections.map(function (_ref) {
                  var collection = _ref.collection,
                      rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);

                  return _extends({}, collection, {
                    extends: _extends({}, rest)
                  });
                }),
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function getUserOwenCollection(_x52, _x53) {
      return _getUserOwenCollection.apply(this, arguments);
    }

    return getUserOwenCollection;
  }();

  _proto.getUserLegacyCollection = /*#__PURE__*/function () {
    var _getUserLegacyCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_LEGACY_COLLECTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context26.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context26.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context26.next = 6;
                break;
              }

              return _context26.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              return _context26.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                collections: raw_data.collections.map(function (_ref2) {
                  var collection = _ref2.collection,
                      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);

                  return _extends({}, collection, {
                    extends: _extends({}, rest)
                  });
                }),
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function getUserLegacyCollection(_x54, _x55) {
      return _getUserLegacyCollection.apply(this, arguments);
    }

    return getUserLegacyCollection;
  }();

  _proto.getUserNFTCollection = /*#__PURE__*/function () {
    var _getUserNFTCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_COLLECTION_HASNFT,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context27.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context27.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context27.next = 6;
                break;
              }

              return _context27.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              return _context27.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                collections: raw_data.collections.map(function (_ref3) {
                  var collection = _ref3.collection,
                      rest = _objectWithoutPropertiesLoose(_ref3, _excluded3);

                  return _extends({}, collection, {
                    extends: _extends({}, rest)
                  });
                }),
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function getUserNFTCollection(_x56, _x57) {
      return _getUserNFTCollection.apply(this, arguments);
    }

    return getUserNFTCollection;
  }();

  _proto.getUserNFTLegacyTokenAddress = /*#__PURE__*/function () {
    var _getUserNFTLegacyTokenAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_LEGACY_TOKENADDRESS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context28.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context28.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context28.next = 6;
                break;
              }

              return _context28.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              return _context28.abrupt("return", {
                result: raw_data.addresses,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function getUserNFTLegacyTokenAddress(_x58, _x59) {
      return _getUserNFTLegacyTokenAddress.apply(this, arguments);
    }

    return getUserNFTLegacyTokenAddress;
  }()
  /*
   * Returns User NFTAction deposit records.
   */
  ;

  _proto.getUserNFTDepositHistory =
  /*#__PURE__*/
  function () {
    var _getUserNFTDepositHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_DEPOSIT_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context29.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context29.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context29.next = 6;
                break;
              }

              return _context29.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context29.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTDepositHistory: raw_data.deposits,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function getUserNFTDepositHistory(_x60, _x61) {
      return _getUserNFTDepositHistory.apply(this, arguments);
    }

    return getUserNFTDepositHistory;
  }()
  /*
   * Get User NFTAction Withdrawal History.
   */
  ;

  _proto.getUserNFTWithdrawalHistory =
  /*#__PURE__*/
  function () {
    var _getUserNFTWithdrawalHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee30(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_WITHDRAW_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context30.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context30.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context30.next = 6;
                break;
              }

              return _context30.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context30.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTWithdrawalHistory: raw_data.withdrawals,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context30.stop();
          }
        }
      }, _callee30, this);
    }));

    function getUserNFTWithdrawalHistory(_x62, _x63) {
      return _getUserNFTWithdrawalHistory.apply(this, arguments);
    }

    return getUserNFTWithdrawalHistory;
  }()
  /*
   * Get user NFTAction transfer list.
   */
  ;

  _proto.getUserNFTTransferHistory =
  /*#__PURE__*/
  function () {
    var _getUserNFTTransferHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee31(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_TRANSFER_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context31.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context31.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context31.next = 6;
                break;
              }

              return _context31.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context31.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTTransfers: raw_data.transfers,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31, this);
    }));

    function getUserNFTTransferHistory(_x64, _x65) {
      return _getUserNFTTransferHistory.apply(this, arguments);
    }

    return getUserNFTTransferHistory;
  }()
  /**
   * Get user NFTAction Mint list.
   * @param request
   * @param apiKey
   */
  ;

  _proto.getUserNFTMintHistory =
  /*#__PURE__*/
  function () {
    var _getUserNFTMintHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee32(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_MINT_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context32.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context32.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context32.next = 6;
                break;
              }

              return _context32.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context32.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTMints: raw_data.transfers,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context32.stop();
          }
        }
      }, _callee32, this);
    }));

    function getUserNFTMintHistory(_x66, _x67) {
      return _getUserNFTMintHistory.apply(this, arguments);
    }

    return getUserNFTMintHistory;
  }()
  /*
   * Get user All NFTAction Transaction list.
   *
   */
  ;

  _proto.getUserNFTTransactionHistory =
  /*#__PURE__*/
  function () {
    var _getUserNFTTransactionHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee33(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_TRANSACTION_HISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context33.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context33.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context33.next = 6;
                break;
              }

              return _context33.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              if (request.metadata === true && raw_data.transactions.length // raw_data.transactions.metadata &&
              // raw_data.transactions.metadata.nftId &&
              // raw_data.transactions.metadata.nftId.startsWith("0x")
              ) {
                raw_data.transactions = raw_data.transactions.reduce(function (prev, item) {
                  if (item.metadata && item.metadata.nftId && item.metadata.nftId.startsWith("0x")) {
                    var hashBN = new BN(item.metadata.nftId.replace("0x", ""), 16);
                    item.metadata.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                  }

                  return [].concat(prev, [item]);
                }, []); // const hashBN = new BN(raw_data.transactions.metadata.nftId.replace("0x", ""), 16);
                // raw_data.transactions.metadata.nftId= "0x" + hashBN.toString("hex").padStart(64, "0");
              }

              return _context33.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTTxs: raw_data.transactions,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context33.stop();
          }
        }
      }, _callee33, this);
    }));

    function getUserNFTTransactionHistory(_x68, _x69) {
      return _getUserNFTTransactionHistory.apply(this, arguments);
    }

    return getUserNFTTransactionHistory;
  }();

  _proto.getUserNFTTradeHistory = /*#__PURE__*/function () {
    var _getUserNFTTradeHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee34(request, apiKey) {
      var reqParams, raw_data, trades;
      return runtime_1.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_TRADE_HISTORY,
                queryParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context34.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context34.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context34.next = 6;
                break;
              }

              return _context34.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              trades = raw_data.trades;
              return _context34.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                trades: trades,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context34.stop();
          }
        }
      }, _callee34, this);
    }));

    function getUserNFTTradeHistory(_x70, _x71) {
      return _getUserNFTTradeHistory.apply(this, arguments);
    }

    return getUserNFTTradeHistory;
  }();

  _proto.SetReferrer = /*#__PURE__*/function () {
    var _SetReferrer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee35(request, eddsaKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("address", request.address);
              dataToSig.set("promotionCode", request.promotionCode);
              dataToSig.set("publicKeyX", request.publicKeyX);
              dataToSig.set("publicKeyY", request.publicKeyY);
              dataToSig.set("referrer", request.referrer);
              reqParams = {
                url: exports.LOOPRING_URLs.SET_REFERRER,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context35.next = 9;
              return this.makeReq().request(reqParams);

            case 9:
              raw_data = _context35.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context35.next = 12;
                break;
              }

              return _context35.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 12:
              return _context35.abrupt("return", {
                result: raw_data == null ? void 0 : raw_data.result,
                raw_data: raw_data
              });

            case 13:
            case "end":
              return _context35.stop();
          }
        }
      }, _callee35, this);
    }));

    function SetReferrer(_x72, _x73) {
      return _SetReferrer.apply(this, arguments);
    }

    return SetReferrer;
  }() // Get users NFTAction balance, besides amount, it also includes tokenId and nftData
  ;

  _proto.getUserNFTBalances =
  /*#__PURE__*/
  function () {
    var _getUserNFTBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee36(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_BALANCES,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context36.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context36.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context36.next = 6;
                break;
              }

              return _context36.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              if (raw_data.data.length) {
                raw_data.data = raw_data.data.reduce(function (prev, item) {
                  if (item.nftId && item.nftId.startsWith("0x")) {
                    var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                    item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");

                    if (request.metadata === true && item.metadata && item.metadata.nftId && item.metadata.nftId.startsWith("0x")) {
                      // const hashBN = new BN(item.metadata.nftId.replace("0x", ""), 16);
                      item.metadata.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                    }
                  }

                  return [].concat(prev, [item]);
                }, []); // const hashBN = new BN(raw_data.transactions.metadata.nftId.replace("0x", ""), 16);
                // raw_data.transactions.metadata.nftId= "0x" + hashBN.toString("hex").padStart(64, "0");
              } // if (raw_data.data.nftId && raw_data.data.nftId.startsWith("0x")) {
              //   const hashBN = new BN(raw_data.data.nftId.replace("0x", ""), 16);
              //   raw_data.data.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
              // }


              return _context36.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTBalances: raw_data.data,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context36.stop();
          }
        }
      }, _callee36, this);
    }));

    function getUserNFTBalances(_x74, _x75) {
      return _getUserNFTBalances.apply(this, arguments);
    }

    return getUserNFTBalances;
  }();

  _proto.getUserNFTBalancesByCollection = /*#__PURE__*/function () {
    var _getUserNFTBalancesByCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee37(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_NFT_BALANCES_BY_COLLECTION,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context37.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context37.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context37.next = 6;
                break;
              }

              return _context37.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              if (raw_data.data.length) {
                raw_data.data = raw_data.data.reduce(function (prev, item) {
                  if (item.nftId && item.nftId.startsWith("0x")) {
                    var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                    item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");

                    if (request.metadata === true && item.metadata && item.metadata.nftId && item.metadata.nftId.startsWith("0x")) {
                      // const hashBN = new BN(item.metadata.nftId.replace("0x", ""), 16);
                      item.metadata.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                    }
                  }

                  return [].concat(prev, [item]);
                }, []); // const hashBN = new BN(raw_data.transactions.metadata.nftId.replace("0x", ""), 16);
                // raw_data.transactions.metadata.nftId= "0x" + hashBN.toString("hex").padStart(64, "0");
              } // if (raw_data.data.nftId && raw_data.data.nftId.startsWith("0x")) {
              //   const hashBN = new BN(raw_data.data.nftId.replace("0x", ""), 16);
              //   raw_data.data.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
              // }


              return _context37.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTBalances: raw_data.data,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context37.stop();
          }
        }
      }, _callee37, this);
    }));

    function getUserNFTBalancesByCollection(_x76, _x77) {
      return _getUserNFTBalancesByCollection.apply(this, arguments);
    }

    return getUserNFTBalancesByCollection;
  }();

  _proto.getUserNFTLegacyBalance = /*#__PURE__*/function () {
    var _getUserNFTLegacyBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee38(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_NFT_LEGACY_BALANCE,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context38.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context38.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context38.next = 6;
                break;
              }

              return _context38.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              if (raw_data.data.length) {
                raw_data.data = raw_data.data.reduce(function (prev, item) {
                  if (item.nftId && item.nftId.startsWith("0x")) {
                    var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                    item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");

                    if (request.metadata === true && item.metadata && item.metadata.nftId && item.metadata.nftId.startsWith("0x")) {
                      // const hashBN = new BN(item.metadata.nftId.replace("0x", ""), 16);
                      item.metadata.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                    }
                  }

                  return [].concat(prev, [item]);
                }, []); // const hashBN = new BN(raw_data.transactions.metadata.nftId.replace("0x", ""), 16);
                // raw_data.transactions.metadata.nftId= "0x" + hashBN.toString("hex").padStart(64, "0");
              } // if (raw_data.data.nftId && raw_data.data.nftId.startsWith("0x")) {
              //   const hashBN = new BN(raw_data.data.nftId.replace("0x", ""), 16);
              //   raw_data.data.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
              // }


              return _context38.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTBalances: raw_data.data,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context38.stop();
          }
        }
      }, _callee38, this);
    }));

    function getUserNFTLegacyBalance(_x78, _x79) {
      return _getUserNFTLegacyBalance.apply(this, arguments);
    }

    return getUserNFTLegacyBalance;
  }();

  _proto.getUserVIPAssets = /*#__PURE__*/function () {
    var _getUserVIPAssets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee39(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee39$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_VIP_ASSETS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context39.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context39.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context39.next = 6;
                break;
              }

              return _context39.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context39.abrupt("return", {
                vipAsset: raw_data.data ? raw_data.data : raw_data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context39.stop();
          }
        }
      }, _callee39, this);
    }));

    function getUserVIPAssets(_x80) {
      return _getUserVIPAssets.apply(this, arguments);
    }

    return getUserVIPAssets;
  }();

  _proto.getUserVIPInfo = /*#__PURE__*/function () {
    var _getUserVIPInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee40(request, apiKey) {
      var reqParams, raw_data, vipInfo;
      return runtime_1.wrap(function _callee40$(_context40) {
        while (1) {
          switch (_context40.prev = _context40.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_VIP_INFO,
                queryParams: request,
                method: exports.ReqMethod.GET,
                apiKey: apiKey,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context40.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context40.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context40.next = 6;
                break;
              }

              return _context40.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              vipInfo = {
                createdAt: raw_data.created_at,
                validTo: raw_data.valid_to,
                org: raw_data.org,
                vipTag: raw_data.vip_tag
              };
              return _context40.abrupt("return", {
                vipInfo: vipInfo,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context40.stop();
          }
        }
      }, _callee40, this);
    }));

    function getUserVIPInfo(_x81, _x82) {
      return _getUserVIPInfo.apply(this, arguments);
    }

    return getUserVIPInfo;
  }();

  _proto.unLockAccount = /*#__PURE__*/function () {
    var _unLockAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee41(_ref4, publicKey) {
      var keyPair, request, eddsaKey, _raw_data, dataToSig, reqParams, raw_data, _raw_data2;

      return runtime_1.wrap(function _callee41$(_context41) {
        while (1) {
          switch (_context41.prev = _context41.next) {
            case 0:
              keyPair = _ref4.keyPair, request = _ref4.request;

              if (publicKey === void 0) {
                publicKey = undefined;
              }

              _context41.prev = 2;
              _context41.next = 5;
              return generateKeyPair(keyPair, publicKey);

            case 5:
              eddsaKey = _context41.sent;
              _context41.next = 11;
              break;

            case 8:
              _context41.prev = 8;
              _context41.t0 = _context41["catch"](2);
              throw _context41.t0;

            case 11:
              if (!eddsaKey) {
                _context41.next = 30;
                break;
              }

              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.API_KEY_ACTION,
                queryParams: request,
                bodyParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey.sk
                }
              };
              _context41.prev = 14;
              _context41.next = 17;
              return this.makeReq().request(reqParams);

            case 17:
              raw_data = _context41.sent.data;
              _context41.next = 23;
              break;

            case 20:
              _context41.prev = 20;
              _context41.t1 = _context41["catch"](14);
              throw _context41.t1;

            case 23:
              if (!((_raw_data = raw_data) != null && _raw_data.resultInfo)) {
                _context41.next = 27;
                break;
              }

              throw _extends({}, (_raw_data2 = raw_data) == null ? void 0 : _raw_data2.resultInfo);

            case 27:
              return _context41.abrupt("return", {
                apiKey: raw_data.apiKey,
                raw_data: raw_data,
                eddsaKey: eddsaKey
              });

            case 28:
              _context41.next = 31;
              break;

            case 30:
              throw {
                code: exports.LoopringErrorCode.NO_EDDSA_KEY,
                message: exports.ConnectorError.NO_EDDSA_KEY
              };

            case 31:
            case "end":
              return _context41.stop();
          }
        }
      }, _callee41, this, [[2, 8], [14, 20]]);
    }));

    function unLockAccount(_x83, _x84) {
      return _unLockAccount.apply(this, arguments);
    }

    return unLockAccount;
  }()
  /*
   * Submit offchain withdraw request
   */
  ;

  _proto.submitOffchainWithdraw =
  /*#__PURE__*/
  function () {
    var _submitOffchainWithdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee43(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref5, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result, _result2, reqParams, raw_data;

      return runtime_1.wrap(function _callee43$(_context43) {
        while (1) {
          switch (_context43.prev = _context43.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref5 = options ? options : {
                accountId: 0
              }, accountId = _ref5.accountId, counterFactualInfo = _ref5.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref6 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee42() {
                  var result;
                  return runtime_1.wrap(function _callee42$(_context42) {
                    while (1) {
                      switch (_context42.prev = _context42.next) {
                        case 0:
                          _context42.next = 2;
                          return signOffchainWithdrawWithoutDataStructure(web3, request.owner, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context42.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context42.stop();
                      }
                    }
                  }, _callee42);
                }));

                return function sigHW() {
                  return _ref6.apply(this, arguments);
                };
              }(); // metamask not import hw appWallet.


              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context43.next = 23;
                break;
              }

              _context43.prev = 6;

              if (!isHWAddr) {
                _context43.next = 12;
                break;
              }

              _context43.next = 10;
              return sigHW();

            case 10:
              _context43.next = 16;
              break;

            case 12:
              _context43.next = 14;
              return signOffchainWithdrawWithDataStructure(web3, request.owner, request, chainId, accountId, counterFactualInfo);

            case 14:
              result = _context43.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 16:
              _context43.next = 21;
              break;

            case 18:
              _context43.prev = 18;
              _context43.t0 = _context43["catch"](6);
              throw _extends({}, this.genErr(_context43.t0));

            case 21:
              _context43.next = 48;
              break;

            case 23:
              _context43.next = 25;
              return isContract(web3, request.owner);

            case 25:
              isContractCheck = _context43.sent;
              _context43.prev = 26;

              if (!isContractCheck) {
                _context43.next = 34;
                break;
              }

              _context43.next = 30;
              return signOffchainWithdrawWithDataStructureForContract(web3, request.owner, request, chainId, accountId);

            case 30:
              _result = _context43.sent;
              ecdsaSignature = _result.ecdsaSig;
              _context43.next = 43;
              break;

            case 34:
              if (!counterFactualInfo) {
                _context43.next = 41;
                break;
              }

              _context43.next = 37;
              return signOffchainWithdrawWithDataStructureForContract(web3, request.owner, request, chainId, accountId, counterFactualInfo);

            case 37:
              _result2 = _context43.sent;
              ecdsaSignature = _result2.ecdsaSig; // myLog("OffchainWithdraw ecdsaSignature:", ecdsaSignature);

              _context43.next = 43;
              break;

            case 41:
              _context43.next = 43;
              return sigHW();

            case 43:
              _context43.next = 48;
              break;

            case 45:
              _context43.prev = 45;
              _context43.t1 = _context43["catch"](26);
              throw _extends({}, this.genErr(_context43.t1));

            case 48:
              request.eddsaSignature = get_EddsaSig_OffChainWithdraw(request, eddsaKey).result;

              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.WITHDRAWALS_ACTION,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context43.prev = 51;
              _context43.next = 54;
              return this.makeReq().request(reqParams);

            case 54:
              raw_data = _context43.sent.data;
              _context43.next = 60;
              break;

            case 57:
              _context43.prev = 57;
              _context43.t2 = _context43["catch"](51);
              throw _context43.t2;

            case 60:
              return _context43.abrupt("return", this.returnTxHash(raw_data));

            case 61:
            case "end":
              return _context43.stop();
          }
        }
      }, _callee43, this, [[6, 18], [26, 45], [51, 57]]);
    }));

    function submitOffchainWithdraw(_x85, _x86) {
      return _submitOffchainWithdraw.apply(this, arguments);
    }

    return submitOffchainWithdraw;
  }()
  /*
   * Submit Internal Transfer request
   */
  ;

  _proto.submitInternalTransfer =
  /*#__PURE__*/
  function () {
    var _submitInternalTransfer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee45(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref7, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result3, _result4, reqParams, raw_data;

      return runtime_1.wrap(function _callee45$(_context45) {
        while (1) {
          switch (_context45.prev = _context45.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref7 = options ? options : {
                accountId: 0
              }, accountId = _ref7.accountId, counterFactualInfo = _ref7.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref8 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee44() {
                  var result;
                  return runtime_1.wrap(function _callee44$(_context44) {
                    while (1) {
                      switch (_context44.prev = _context44.next) {
                        case 0:
                          _context44.next = 2;
                          return signTransferWithoutDataStructure(web3, request.payerAddr, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context44.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context44.stop();
                      }
                    }
                  }, _callee44);
                }));

                return function sigHW() {
                  return _ref8.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context45.next = 23;
                break;
              }

              _context45.prev = 6;

              if (!isHWAddr) {
                _context45.next = 12;
                break;
              }

              _context45.next = 10;
              return sigHW();

            case 10:
              _context45.next = 16;
              break;

            case 12:
              _context45.next = 14;
              return signTransferWithDataStructure(web3, request.payerAddr, request, chainId, walletType, accountId, counterFactualInfo);

            case 14:
              result = _context45.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 16:
              _context45.next = 21;
              break;

            case 18:
              _context45.prev = 18;
              _context45.t0 = _context45["catch"](6);
              throw _extends({}, this.genErr(_context45.t0));

            case 21:
              _context45.next = 48;
              break;

            case 23:
              _context45.next = 25;
              return isContract(web3, request.payerAddr);

            case 25:
              isContractCheck = _context45.sent;
              _context45.prev = 26;

              if (!isContractCheck) {
                _context45.next = 34;
                break;
              }

              _context45.next = 30;
              return signTransferWithDataStructureForContract(web3, request.payerAddr, request, chainId, accountId);

            case 30:
              _result3 = _context45.sent;
              ecdsaSignature = _result3.ecdsaSig;
              _context45.next = 43;
              break;

            case 34:
              if (!counterFactualInfo) {
                _context45.next = 41;
                break;
              }

              _context45.next = 37;
              return signTransferWithDataStructureForContract(web3, request.payerAddr, request, chainId, accountId, counterFactualInfo);

            case 37:
              _result4 = _context45.sent;
              ecdsaSignature = _result4.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context45.next = 43;
              break;

            case 41:
              _context45.next = 43;
              return sigHW();

            case 43:
              _context45.next = 48;
              break;

            case 45:
              _context45.prev = 45;
              _context45.t1 = _context45["catch"](26);
              throw _extends({}, this.genErr(_context45.t1));

            case 48:
              request.eddsaSignature = get_EddsaSig_Transfer(request, eddsaKey).result;

              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.POST_INTERNAL_TRANSFER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context45.prev = 51;
              _context45.next = 54;
              return this.makeReq().request(reqParams);

            case 54:
              raw_data = _context45.sent.data;
              _context45.next = 60;
              break;

            case 57:
              _context45.prev = 57;
              _context45.t2 = _context45["catch"](51);
              throw _context45.t2;

            case 60:
              return _context45.abrupt("return", this.returnTxHash(raw_data));

            case 61:
            case "end":
              return _context45.stop();
          }
        }
      }, _callee45, this, [[6, 18], [26, 45], [51, 57]]);
    }));

    function submitInternalTransfer(_x87, _x88) {
      return _submitInternalTransfer.apply(this, arguments);
    }

    return submitInternalTransfer;
  }()
  /*
   * Submit NFTAction Deploy request
   */
  ;

  _proto.submitForceWithdrawals =
  /*#__PURE__*/
  function () {
    var _submitForceWithdrawals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee47(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref9, accountId, counterFactualInfo, transfer, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result5, _result6, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee47$(_context47) {
        while (1) {
          switch (_context47.prev = _context47.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref9 = options ? options : {
                accountId: 0
              }, accountId = _ref9.accountId, counterFactualInfo = _ref9.counterFactualInfo;
              transfer = request.transfer;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              transfer.payeeId = 0;
              transfer.memo = "ForceWithdrawalBy" + request.requesterAddress;
              transfer.maxFee = {
                volume: "0",
                tokenId: transfer.token.tokenId
              };

              sigHW = /*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee46() {
                  var result;
                  return runtime_1.wrap(function _callee46$(_context46) {
                    while (1) {
                      switch (_context46.prev = _context46.next) {
                        case 0:
                          _context46.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context46.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context46.stop();
                      }
                    }
                  }, _callee46);
                }));

                return function sigHW() {
                  return _ref10.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context47.next = 27;
                break;
              }

              _context47.prev = 10;

              if (!isHWAddr) {
                _context47.next = 16;
                break;
              }

              _context47.next = 14;
              return sigHW();

            case 14:
              _context47.next = 20;
              break;

            case 16:
              _context47.next = 18;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 18:
              result = _context47.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 20:
              _context47.next = 25;
              break;

            case 22:
              _context47.prev = 22;
              _context47.t0 = _context47["catch"](10);
              throw _extends({}, this.genErr(_context47.t0));

            case 25:
              _context47.next = 52;
              break;

            case 27:
              _context47.next = 29;
              return isContract(web3, transfer.payerAddr);

            case 29:
              isContractCheck = _context47.sent;
              _context47.prev = 30;

              if (!isContractCheck) {
                _context47.next = 38;
                break;
              }

              _context47.next = 34;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 34:
              _result5 = _context47.sent;
              ecdsaSignature = _result5.ecdsaSig;
              _context47.next = 47;
              break;

            case 38:
              if (!counterFactualInfo) {
                _context47.next = 45;
                break;
              }

              _context47.next = 41;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 41:
              _result6 = _context47.sent;
              ecdsaSignature = _result6.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context47.next = 47;
              break;

            case 45:
              _context47.next = 47;
              return sigHW();

            case 47:
              _context47.next = 52;
              break;

            case 49:
              _context47.prev = 49;
              _context47.t1 = _context47["catch"](30);
              throw _extends({}, this.genErr(_context47.t1));

            case 52:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              transfer.eddsaSignature = get_EddsaSig_Transfer(transfer, eddsaKey).result;
              transfer.ecdsaSignature = ecdsaSignature;
              dataToSig = new Map();
              dataToSig.set("requesterAddress", request.requesterAddress);
              dataToSig.set("tokenId", request.tokenId);
              dataToSig.set("transfer", request.transfer);
              dataToSig.set("withdrawAddress", request.withdrawAddress);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_FORCE_WITHDRAWALS,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context47.prev = 61;
              _context47.next = 64;
              return this.makeReq().request(reqParams);

            case 64:
              raw_data = _context47.sent.data;
              _context47.next = 70;
              break;

            case 67:
              _context47.prev = 67;
              _context47.t2 = _context47["catch"](61);
              throw _context47.t2;

            case 70:
              return _context47.abrupt("return", this.returnTxHash(raw_data));

            case 71:
            case "end":
              return _context47.stop();
          }
        }
      }, _callee47, this, [[10, 22], [30, 49], [61, 67]]);
    }));

    function submitForceWithdrawals(_x89, _x90) {
      return _submitForceWithdrawals.apply(this, arguments);
    }

    return submitForceWithdrawals;
  }()
  /*
   * Submit NFTAction Deploy request
   */
  ;

  _proto.submitDeployNFT =
  /*#__PURE__*/
  function () {
    var _submitDeployNFT = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee49(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref11, accountId, counterFactualInfo, transfer, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result7, _result8, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee49$(_context49) {
        while (1) {
          switch (_context49.prev = _context49.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref11 = options ? options : {
                accountId: 0
              }, accountId = _ref11.accountId, counterFactualInfo = _ref11.counterFactualInfo;
              transfer = request.transfer;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              transfer.payeeId = 0;
              transfer.memo = "NFT-DEPLOY-CONTRACT->" + request.tokenAddress;
              transfer.maxFee = {
                volume: "0",
                tokenId: transfer.token.tokenId
              };

              sigHW = /*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee48() {
                  var result;
                  return runtime_1.wrap(function _callee48$(_context48) {
                    while (1) {
                      switch (_context48.prev = _context48.next) {
                        case 0:
                          _context48.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context48.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context48.stop();
                      }
                    }
                  }, _callee48);
                }));

                return function sigHW() {
                  return _ref12.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context49.next = 27;
                break;
              }

              _context49.prev = 10;

              if (!isHWAddr) {
                _context49.next = 16;
                break;
              }

              _context49.next = 14;
              return sigHW();

            case 14:
              _context49.next = 20;
              break;

            case 16:
              _context49.next = 18;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 18:
              result = _context49.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 20:
              _context49.next = 25;
              break;

            case 22:
              _context49.prev = 22;
              _context49.t0 = _context49["catch"](10);
              throw _extends({}, this.genErr(_context49.t0));

            case 25:
              _context49.next = 52;
              break;

            case 27:
              _context49.next = 29;
              return isContract(web3, transfer.payerAddr);

            case 29:
              isContractCheck = _context49.sent;
              _context49.prev = 30;

              if (!isContractCheck) {
                _context49.next = 38;
                break;
              }

              _context49.next = 34;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 34:
              _result7 = _context49.sent;
              ecdsaSignature = _result7.ecdsaSig;
              _context49.next = 47;
              break;

            case 38:
              if (!counterFactualInfo) {
                _context49.next = 45;
                break;
              }

              _context49.next = 41;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 41:
              _result8 = _context49.sent;
              ecdsaSignature = _result8.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context49.next = 47;
              break;

            case 45:
              _context49.next = 47;
              return sigHW();

            case 47:
              _context49.next = 52;
              break;

            case 49:
              _context49.prev = 49;
              _context49.t1 = _context49["catch"](30);
              throw _extends({}, this.genErr(_context49.t1));

            case 52:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              transfer.eddsaSignature = get_EddsaSig_Transfer(transfer, eddsaKey).result;
              transfer.ecdsaSignature = ecdsaSignature;
              dataToSig = new Map();
              dataToSig.set("nftData", request.nftData);
              dataToSig.set("tokenAddress", request.tokenAddress);
              dataToSig.set("transfer", request.transfer);
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DEPLOY_TOKEN_ADDRESS,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context49.prev = 60;
              _context49.next = 63;
              return this.makeReq().request(reqParams);

            case 63:
              raw_data = _context49.sent.data;
              _context49.next = 69;
              break;

            case 66:
              _context49.prev = 66;
              _context49.t2 = _context49["catch"](60);
              throw _context49.t2;

            case 69:
              return _context49.abrupt("return", this.returnTxHash(raw_data));

            case 70:
            case "end":
              return _context49.stop();
          }
        }
      }, _callee49, this, [[10, 22], [30, 49], [60, 66]]);
    }));

    function submitDeployNFT(_x91, _x92) {
      return _submitDeployNFT.apply(this, arguments);
    }

    return submitDeployNFT;
  }()
  /*
   * Submit NFTAction Transfer request
   */
  ;

  _proto.submitNFTInTransfer =
  /*#__PURE__*/
  function () {
    var _submitNFTInTransfer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee51(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref13, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result9, _result10, reqParams, raw_data;

      return runtime_1.wrap(function _callee51$(_context51) {
        while (1) {
          switch (_context51.prev = _context51.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref13 = options ? options : {
                accountId: 0
              }, accountId = _ref13.accountId, counterFactualInfo = _ref13.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee50() {
                  var result;
                  return runtime_1.wrap(function _callee50$(_context50) {
                    while (1) {
                      switch (_context50.prev = _context50.next) {
                        case 0:
                          _context50.next = 2;
                          return signNFTTransferWithoutDataStructure(web3, request.fromAddress, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context50.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context50.stop();
                      }
                    }
                  }, _callee50);
                }));

                return function sigHW() {
                  return _ref14.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context51.next = 23;
                break;
              }

              _context51.prev = 6;

              if (!isHWAddr) {
                _context51.next = 12;
                break;
              }

              _context51.next = 10;
              return sigHW();

            case 10:
              _context51.next = 16;
              break;

            case 12:
              _context51.next = 14;
              return signTNFTransferWithDataStructure(web3, request.fromAddress, request, chainId, walletType, accountId, counterFactualInfo);

            case 14:
              result = _context51.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 16:
              _context51.next = 21;
              break;

            case 18:
              _context51.prev = 18;
              _context51.t0 = _context51["catch"](6);
              throw _extends({}, this.genErr(_context51.t0));

            case 21:
              _context51.next = 48;
              break;

            case 23:
              _context51.next = 25;
              return isContract(web3, request.fromAddress);

            case 25:
              isContractCheck = _context51.sent;
              _context51.prev = 26;

              if (!isContractCheck) {
                _context51.next = 34;
                break;
              }

              _context51.next = 30;
              return signNFTTransferWithDataStructureForContract(web3, request.fromAddress, request, chainId, accountId);

            case 30:
              _result9 = _context51.sent;
              ecdsaSignature = _result9.ecdsaSig;
              _context51.next = 43;
              break;

            case 34:
              if (!counterFactualInfo) {
                _context51.next = 41;
                break;
              }

              _context51.next = 37;
              return signNFTTransferWithDataStructureForContract(web3, request.fromAddress, request, chainId, accountId, counterFactualInfo);

            case 37:
              _result10 = _context51.sent;
              ecdsaSignature = _result10.ecdsaSig; // myLog("NFTransfer ecdsaSignature:", ecdsaSignature);

              _context51.next = 43;
              break;

            case 41:
              _context51.next = 43;
              return sigHW();

            case 43:
              _context51.next = 48;
              break;

            case 45:
              _context51.prev = 45;
              _context51.t1 = _context51["catch"](26);
              throw _extends({}, this.genErr(_context51.t1));

            case 48:
              request.eddsaSignature = get_EddsaSig_NFT_Transfer(request, eddsaKey).result;

              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_INTERNAL_TRANSFER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context51.prev = 51;
              _context51.next = 54;
              return this.makeReq().request(reqParams);

            case 54:
              raw_data = _context51.sent.data;
              _context51.next = 60;
              break;

            case 57:
              _context51.prev = 57;
              _context51.t2 = _context51["catch"](51);
              throw _context51.t2;

            case 60:
              return _context51.abrupt("return", this.returnTxHash(raw_data));

            case 61:
            case "end":
              return _context51.stop();
          }
        }
      }, _callee51, this, [[6, 18], [26, 45], [51, 57]]);
    }));

    function submitNFTInTransfer(_x93, _x94) {
      return _submitNFTInTransfer.apply(this, arguments);
    }

    return submitNFTInTransfer;
  }()
  /*
   * Submit NFTAction Withdraw request
   */
  ;

  _proto.submitNFTWithdraw =
  /*#__PURE__*/
  function () {
    var _submitNFTWithdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee53(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref15, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result11, _result12, reqParams, raw_data;

      return runtime_1.wrap(function _callee53$(_context53) {
        while (1) {
          switch (_context53.prev = _context53.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref15 = options ? options : {
                accountId: 0
              }, accountId = _ref15.accountId, counterFactualInfo = _ref15.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref16 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee52() {
                  var result;
                  return runtime_1.wrap(function _callee52$(_context52) {
                    while (1) {
                      switch (_context52.prev = _context52.next) {
                        case 0:
                          _context52.next = 2;
                          return signNFTWithdrawWithoutDataStructure(web3, request.owner, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context52.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context52.stop();
                      }
                    }
                  }, _callee52);
                }));

                return function sigHW() {
                  return _ref16.apply(this, arguments);
                };
              }(); // metamask not import hw appWallet.


              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context53.next = 23;
                break;
              }

              _context53.prev = 6;

              if (!isHWAddr) {
                _context53.next = 12;
                break;
              }

              _context53.next = 10;
              return sigHW();

            case 10:
              _context53.next = 16;
              break;

            case 12:
              _context53.next = 14;
              return signNFTWithdrawWithDataStructure(web3, request.owner, request, chainId, walletType, accountId, counterFactualInfo);

            case 14:
              result = _context53.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 16:
              _context53.next = 21;
              break;

            case 18:
              _context53.prev = 18;
              _context53.t0 = _context53["catch"](6);
              throw _extends({}, this.genErr(_context53.t0));

            case 21:
              _context53.next = 48;
              break;

            case 23:
              _context53.next = 25;
              return isContract(web3, request.owner);

            case 25:
              isContractCheck = _context53.sent;
              _context53.prev = 26;

              if (!isContractCheck) {
                _context53.next = 34;
                break;
              }

              _context53.next = 30;
              return signNFTWithdrawWithDataStructureForContract(web3, request.owner, request, chainId, accountId);

            case 30:
              _result11 = _context53.sent;
              ecdsaSignature = _result11.ecdsaSig;
              _context53.next = 43;
              break;

            case 34:
              if (!counterFactualInfo) {
                _context53.next = 41;
                break;
              }

              _context53.next = 37;
              return signNFTWithdrawWithDataStructureForContract(web3, request.owner, request, chainId, accountId, counterFactualInfo);

            case 37:
              _result12 = _context53.sent;
              ecdsaSignature = _result12.ecdsaSig; // myLog("NFTWithdraw ecdsaSignature:", ecdsaSignature);

              _context53.next = 43;
              break;

            case 41:
              _context53.next = 43;
              return sigHW();

            case 43:
              _context53.next = 48;
              break;

            case 45:
              _context53.prev = 45;
              _context53.t1 = _context53["catch"](26);
              throw _extends({}, this.genErr(_context53.t1));

            case 48:
              request.eddsaSignature = get_EddsaSig_NFT_Withdraw(request, eddsaKey).result;

              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_WITHDRAWALS,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context53.prev = 51;
              _context53.next = 54;
              return this.makeReq().request(reqParams);

            case 54:
              raw_data = _context53.sent.data;
              _context53.next = 60;
              break;

            case 57:
              _context53.prev = 57;
              _context53.t2 = _context53["catch"](51);
              throw _context53.t2;

            case 60:
              return _context53.abrupt("return", this.returnTxHash(raw_data));

            case 61:
            case "end":
              return _context53.stop();
          }
        }
      }, _callee53, this, [[6, 18], [26, 45], [51, 57]]);
    }));

    function submitNFTWithdraw(_x95, _x96) {
      return _submitNFTWithdraw.apply(this, arguments);
    }

    return submitNFTWithdraw;
  }()
  /*
   * Submit NFTAction
   */
  ;

  _proto.submitNFTMint =
  /*#__PURE__*/
  function () {
    var _submitNFTMint = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee55(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref17, accountId, counterFactualInfo, _noEcdsa, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result13, _result14, reqParams, raw_data;

      return runtime_1.wrap(function _callee55$(_context55) {
        while (1) {
          switch (_context55.prev = _context55.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref17 = options ? options : {
                accountId: 0
              }, accountId = _ref17.accountId, counterFactualInfo = _ref17.counterFactualInfo, _noEcdsa = _ref17._noEcdsa;

              if (request.counterFactualNftInfo === undefined) {
                request.counterFactualNftInfo = {
                  nftFactory: NFTFactory[chainId],
                  nftOwner: request.minterAddress,
                  nftBaseUri: ""
                };
              }

              request.royaltyPercentage = request.royaltyPercentage ? request.royaltyPercentage : 0;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref18 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee54() {
                  var result;
                  return runtime_1.wrap(function _callee54$(_context54) {
                    while (1) {
                      switch (_context54.prev = _context54.next) {
                        case 0:
                          _context54.next = 2;
                          return signNFTMintWithoutDataStructure(web3, request.minterAddress, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context54.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context54.stop();
                      }
                    }
                  }, _callee54);
                }));

                return function sigHW() {
                  return _ref18.apply(this, arguments);
                };
              }(); // metamask not import hw appWallet.


              if (_noEcdsa) {
                _context55.next = 51;
                break;
              }

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context55.next = 26;
                break;
              }

              _context55.prev = 9;

              if (!isHWAddr) {
                _context55.next = 15;
                break;
              }

              _context55.next = 13;
              return sigHW();

            case 13:
              _context55.next = 19;
              break;

            case 15:
              _context55.next = 17;
              return signNFTMintWithDataStructure(web3, request.minterAddress, request, chainId, walletType, accountId, counterFactualInfo);

            case 17:
              result = _context55.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 19:
              _context55.next = 24;
              break;

            case 21:
              _context55.prev = 21;
              _context55.t0 = _context55["catch"](9);
              throw _extends({}, this.genErr(_context55.t0));

            case 24:
              _context55.next = 51;
              break;

            case 26:
              _context55.prev = 26;
              _context55.next = 29;
              return isContract(web3, request.minterAddress);

            case 29:
              isContractCheck = _context55.sent;

              if (!isContractCheck) {
                _context55.next = 37;
                break;
              }

              _context55.next = 33;
              return signNFTMintWithDataStructureForContract(web3, request.minterAddress, request, chainId, accountId);

            case 33:
              _result13 = _context55.sent;
              ecdsaSignature = _result13.ecdsaSig;
              _context55.next = 46;
              break;

            case 37:
              if (!counterFactualInfo) {
                _context55.next = 44;
                break;
              }

              _context55.next = 40;
              return signNFTMintWithDataStructureForContract(web3, request.minterAddress, request, chainId, accountId, counterFactualInfo);

            case 40:
              _result14 = _context55.sent;
              ecdsaSignature = _result14.ecdsaSig; // myLog("NFTMintWithData ecdsaSignature:", ecdsaSignature);

              _context55.next = 46;
              break;

            case 44:
              _context55.next = 46;
              return sigHW();

            case 46:
              _context55.next = 51;
              break;

            case 48:
              _context55.prev = 48;
              _context55.t1 = _context55["catch"](26);
              throw _extends({}, this.genErr(_context55.t1));

            case 51:
              request.eddsaSignature = get_EddsaSig_NFT_Mint(request, eddsaKey).result;

              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_MINT,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context55.prev = 54;
              _context55.next = 57;
              return this.makeReq().request(reqParams);

            case 57:
              raw_data = _context55.sent.data;
              _context55.next = 63;
              break;

            case 60:
              _context55.prev = 60;
              _context55.t2 = _context55["catch"](54);
              throw _context55.t2;

            case 63:
              return _context55.abrupt("return", this.returnTxHash(raw_data));

            case 64:
            case "end":
              return _context55.stop();
          }
        }
      }, _callee55, this, [[9, 21], [26, 48], [54, 60]]);
    }));

    function submitNFTMint(_x97, _x98) {
      return _submitNFTMint.apply(this, arguments);
    }

    return submitNFTMint;
  }();

  _proto.submitNFTCollection = /*#__PURE__*/function () {
    var _submitNFTCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee56(req, chainId, apiKey, eddsaKey) {
      var _req, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee56$(_context56) {
        while (1) {
          switch (_context56.prev = _context56.next) {
            case 0:
              _req = req.nftFactory ? req : _extends({}, req, {
                nftFactory: NFTFactory_Collection[chainId]
              });
              dataToSig = sortObjDictionary(_req);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_CREATE_COLLECTION,
                bodyParams: Object.fromEntries(dataToSig),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context56.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context56.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context56.next = 8;
                break;
              }

              return _context56.abrupt("return", _extends({}, raw_data.resultInfo));

            case 8:
              return _context56.abrupt("return", {
                raw_data: raw_data,
                contractAddress: raw_data == null ? void 0 : raw_data.contractAddress
              });

            case 9:
            case "end":
              return _context56.stop();
          }
        }
      }, _callee56, this);
    }));

    function submitNFTCollection(_x99, _x100, _x101, _x102) {
      return _submitNFTCollection.apply(this, arguments);
    }

    return submitNFTCollection;
  }();

  _proto.deleteNFTCollection = /*#__PURE__*/function () {
    var _deleteNFTCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee57(req, chainId, apiKey, eddsaKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee57$(_context57) {
        while (1) {
          switch (_context57.prev = _context57.next) {
            case 0:
              dataToSig = sortObjDictionary(req);
              reqParams = {
                url: exports.LOOPRING_URLs.DELETE_NFT_CREATE_COLLECTION,
                queryParams: req,
                apiKey: apiKey,
                method: exports.ReqMethod.DELETE,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context57.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context57.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context57.next = 7;
                break;
              }

              return _context57.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context57.abrupt("return", {
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context57.stop();
          }
        }
      }, _callee57, this);
    }));

    function deleteNFTCollection(_x103, _x104, _x105, _x106) {
      return _deleteNFTCollection.apply(this, arguments);
    }

    return deleteNFTCollection;
  }();

  _proto.submitNFTLegacyCollection = /*#__PURE__*/function () {
    var _submitNFTLegacyCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee58(req, chainId, apiKey, eddsaKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee58$(_context58) {
        while (1) {
          switch (_context58.prev = _context58.next) {
            case 0:
              // const _req = req.nftFactory
              //   ? req
              //   : { ...req, nftFactory: NFTFactory_Collection[chainId] };
              dataToSig = sortObjDictionary(req);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_CREATE_LEGACY_COLLECTION,
                bodyParams: Object.fromEntries(dataToSig),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context58.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context58.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context58.next = 7;
                break;
              }

              return _context58.abrupt("return", _extends({}, raw_data.resultInfo));

            case 7:
              return _context58.abrupt("return", {
                raw_data: raw_data,
                result: raw_data.result
              });

            case 8:
            case "end":
              return _context58.stop();
          }
        }
      }, _callee58, this);
    }));

    function submitNFTLegacyCollection(_x107, _x108, _x109, _x110) {
      return _submitNFTLegacyCollection.apply(this, arguments);
    }

    return submitNFTLegacyCollection;
  }();

  _proto.submitEditNFTCollection = /*#__PURE__*/function () {
    var _submitEditNFTCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee59(req, chainId, apiKey, eddsaKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee59$(_context59) {
        while (1) {
          switch (_context59.prev = _context59.next) {
            case 0:
              // const _req = req.nftFactory ? req : {...req, nftFactory: NFTFactory_Collection[ chainId ]}
              dataToSig = sortObjDictionary(req);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_EDIT_COLLECTION,
                bodyParams: Object.fromEntries(dataToSig),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context59.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context59.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context59.next = 7;
                break;
              }

              return _context59.abrupt("return", _extends({}, raw_data.resultInfo));

            case 7:
              return _context59.abrupt("return", {
                raw_data: raw_data,
                contractAddress: raw_data == null ? void 0 : raw_data.contractAddress
              });

            case 8:
            case "end":
              return _context59.stop();
          }
        }
      }, _callee59, this);
    }));

    function submitEditNFTCollection(_x111, _x112, _x113, _x114) {
      return _submitEditNFTCollection.apply(this, arguments);
    }

    return submitEditNFTCollection;
  }();

  _proto.submitUpdateNFTLegacyCollection = /*#__PURE__*/function () {
    var _submitUpdateNFTLegacyCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee60(req, chainId, apiKey, eddsaKey) {
      var _req, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee60$(_context60) {
        while (1) {
          switch (_context60.prev = _context60.next) {
            case 0:
              _req = _extends({}, req, {
                nftHashes: req.nftHashes.join(",")
              });
              dataToSig = sortObjDictionary(_req);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_LEGACY_UPDATE_COLLECTION,
                bodyParams: Object.fromEntries(dataToSig),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context60.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context60.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context60.next = 8;
                break;
              }

              return _context60.abrupt("return", _extends({}, raw_data.resultInfo));

            case 8:
              return _context60.abrupt("return", {
                raw_data: raw_data,
                result: raw_data.result
              });

            case 9:
            case "end":
              return _context60.stop();
          }
        }
      }, _callee60, this);
    }));

    function submitUpdateNFTLegacyCollection(_x115, _x116, _x117, _x118) {
      return _submitUpdateNFTLegacyCollection.apply(this, arguments);
    }

    return submitUpdateNFTLegacyCollection;
  }();

  _proto.submitUpdateNFTGroup = /*#__PURE__*/function () {
    var _submitUpdateNFTGroup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee61(req, chainId, apiKey, eddsaKey) {
      var _req, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee61$(_context61) {
        while (1) {
          switch (_context61.prev = _context61.next) {
            case 0:
              _req = _extends({}, req, {
                nftHashes: req.nftHashes.join(",")
              });
              dataToSig = sortObjDictionary(_req);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_NFT_UPDATE_NFT_GROUP,
                bodyParams: Object.fromEntries(dataToSig),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context61.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context61.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context61.next = 8;
                break;
              }

              return _context61.abrupt("return", _extends({}, raw_data.resultInfo));

            case 8:
              return _context61.abrupt("return", {
                raw_data: raw_data,
                result: raw_data.result
              });

            case 9:
            case "end":
              return _context61.stop();
          }
        }
      }, _callee61, this);
    }));

    function submitUpdateNFTGroup(_x119, _x120, _x121, _x122) {
      return _submitUpdateNFTGroup.apply(this, arguments);
    }

    return submitUpdateNFTGroup;
  }()
  /*
   * Submit NFTAction Deploy request
   */
  ;

  _proto.submitDeployCollection =
  /*#__PURE__*/
  function () {
    var _submitDeployCollection = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee63(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref19, accountId, counterFactualInfo, transfer, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result15, _result16, dataToSig, reqParams, raw_data;

      return runtime_1.wrap(function _callee63$(_context63) {
        while (1) {
          switch (_context63.prev = _context63.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref19 = options ? options : {
                accountId: 0
              }, accountId = _ref19.accountId, counterFactualInfo = _ref19.counterFactualInfo;
              transfer = request.transfer;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              transfer.payeeId = 0;
              transfer.memo = "NFT-DEPLOY-CONTRACT->" + request.tokenAddress;
              transfer.maxFee = {
                volume: "0",
                tokenId: transfer.token.tokenId
              };

              sigHW = /*#__PURE__*/function () {
                var _ref20 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee62() {
                  var result;
                  return runtime_1.wrap(function _callee62$(_context62) {
                    while (1) {
                      switch (_context62.prev = _context62.next) {
                        case 0:
                          _context62.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context62.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context62.stop();
                      }
                    }
                  }, _callee62);
                }));

                return function sigHW() {
                  return _ref20.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context63.next = 27;
                break;
              }

              _context63.prev = 10;

              if (!isHWAddr) {
                _context63.next = 16;
                break;
              }

              _context63.next = 14;
              return sigHW();

            case 14:
              _context63.next = 20;
              break;

            case 16:
              _context63.next = 18;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 18:
              result = _context63.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 20:
              _context63.next = 25;
              break;

            case 22:
              _context63.prev = 22;
              _context63.t0 = _context63["catch"](10);
              throw _extends({}, this.genErr(_context63.t0));

            case 25:
              _context63.next = 52;
              break;

            case 27:
              _context63.next = 29;
              return isContract(web3, transfer.payerAddr);

            case 29:
              isContractCheck = _context63.sent;
              _context63.prev = 30;

              if (!isContractCheck) {
                _context63.next = 38;
                break;
              }

              _context63.next = 34;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 34:
              _result15 = _context63.sent;
              ecdsaSignature = _result15.ecdsaSig;
              _context63.next = 47;
              break;

            case 38:
              if (!counterFactualInfo) {
                _context63.next = 45;
                break;
              }

              _context63.next = 41;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 41:
              _result16 = _context63.sent;
              ecdsaSignature = _result16.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context63.next = 47;
              break;

            case 45:
              _context63.next = 47;
              return sigHW();

            case 47:
              _context63.next = 52;
              break;

            case 49:
              _context63.prev = 49;
              _context63.t1 = _context63["catch"](30);
              throw _extends({}, this.genErr(_context63.t1));

            case 52:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              transfer.eddsaSignature = get_EddsaSig_Transfer(transfer, eddsaKey).result;
              transfer.ecdsaSignature = ecdsaSignature;
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_DEPLOY_COLLECTION,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context63.prev = 57;
              _context63.next = 60;
              return this.makeReq().request(reqParams);

            case 60:
              raw_data = _context63.sent.data;
              _context63.next = 66;
              break;

            case 63:
              _context63.prev = 63;
              _context63.t2 = _context63["catch"](57);
              throw _context63.t2;

            case 66:
              return _context63.abrupt("return", this.returnTxHash(raw_data));

            case 67:
            case "end":
              return _context63.stop();
          }
        }
      }, _callee63, this, [[10, 22], [30, 49], [57, 63]]);
    }));

    function submitDeployCollection(_x123, _x124) {
      return _submitDeployCollection.apply(this, arguments);
    }

    return submitDeployCollection;
  }()
  /*
   * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.
   */
  ;

  _proto.updateAccount =
  /*#__PURE__*/
  function () {
    var _updateAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee65(req, options) {
      var request, web3, chainId, walletType, isHWAddrOld, _ref21, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result17, _result18, reqParams, raw_data;

      return runtime_1.wrap(function _callee65$(_context65) {
        while (1) {
          switch (_context65.prev = _context65.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, isHWAddrOld = req.isHWAddr;
              _ref21 = options ? options : {
                accountId: 0
              }, accountId = _ref21.accountId, counterFactualInfo = _ref21.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref22 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee64() {
                  var result;
                  return runtime_1.wrap(function _callee64$(_context64) {
                    while (1) {
                      switch (_context64.prev = _context64.next) {
                        case 0:
                          _context64.next = 2;
                          return signUpdateAccountWithoutDataStructure(web3, request, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context64.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context64.stop();
                      }
                    }
                  }, _callee64);
                }));

                return function sigHW() {
                  return _ref22.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context65.next = 23;
                break;
              }

              _context65.prev = 6;

              if (!isHWAddr) {
                _context65.next = 12;
                break;
              }

              _context65.next = 10;
              return sigHW();

            case 10:
              _context65.next = 16;
              break;

            case 12:
              _context65.next = 14;
              return signUpdateAccountWithDataStructure(web3, request, chainId, walletType, accountId, counterFactualInfo);

            case 14:
              result = _context65.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 16:
              _context65.next = 21;
              break;

            case 18:
              _context65.prev = 18;
              _context65.t0 = _context65["catch"](6);
              throw _extends({}, this.genErr(_context65.t0));

            case 21:
              _context65.next = 48;
              break;

            case 23:
              _context65.next = 25;
              return isContract(web3, request.owner);

            case 25:
              isContractCheck = _context65.sent;
              _context65.prev = 26;

              if (!isContractCheck) {
                _context65.next = 34;
                break;
              }

              _context65.next = 30;
              return signUpdateAccountWithDataStructureForContract(web3, request, chainId, accountId);

            case 30:
              _result17 = _context65.sent;
              ecdsaSignature = _result17.ecdsaSig; // myLog('ecdsaSignature:', ecdsaSignature)

              _context65.next = 43;
              break;

            case 34:
              if (!counterFactualInfo) {
                _context65.next = 41;
                break;
              }

              _context65.next = 37;
              return signUpdateAccountWithDataStructureForContract(web3, request, chainId, accountId, counterFactualInfo);

            case 37:
              _result18 = _context65.sent;
              ecdsaSignature = _result18.ecdsaSig; // myLog("UpdateAccount ecdsaSignature:", ecdsaSignature);

              _context65.next = 43;
              break;

            case 41:
              _context65.next = 43;
              return sigHW();

            case 43:
              _context65.next = 48;
              break;

            case 45:
              _context65.prev = 45;
              _context65.t1 = _context65["catch"](26);
              throw _extends({}, this.genErr(_context65.t1));

            case 48:
              if (counterFactualInfo) {
                request.counterFactualInfo = counterFactualInfo;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.ACCOUNT_ACTION,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context65.prev = 50;
              _context65.next = 53;
              return this.makeReq().request(reqParams);

            case 53:
              raw_data = _context65.sent.data;
              _context65.next = 59;
              break;

            case 56:
              _context65.prev = 56;
              _context65.t2 = _context65["catch"](50);
              throw _context65.t2;

            case 59:
              return _context65.abrupt("return", this.returnTxHash(raw_data));

            case 60:
            case "end":
              return _context65.stop();
          }
        }
      }, _callee65, this, [[6, 18], [26, 45], [50, 56]]);
    }));

    function updateAccount(_x125, _x126) {
      return _updateAccount.apply(this, arguments);
    }

    return updateAccount;
  }()
  /*
   * Get the ApiKey associated with the user's account.
   */
  ;

  _proto.getUserApiKey =
  /*#__PURE__*/
  function () {
    var _getUserApiKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee66(request, eddsaKey) {
      var _raw_data3;

      var dataToSig, reqParams, raw_data, _raw_data4;

      return runtime_1.wrap(function _callee66$(_context66) {
        while (1) {
          switch (_context66.prev = _context66.next) {
            case 0:
              dataToSig = new Map();
              dataToSig.set("accountId", request.accountId);
              reqParams = {
                url: exports.LOOPRING_URLs.API_KEY_ACTION,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context66.prev = 3;
              _context66.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context66.sent.data;
              _context66.next = 12;
              break;

            case 9:
              _context66.prev = 9;
              _context66.t0 = _context66["catch"](3);
              throw _context66.t0;

            case 12:
              if (!((_raw_data3 = raw_data) != null && _raw_data3.resultInfo)) {
                _context66.next = 16;
                break;
              }

              throw _extends({}, (_raw_data4 = raw_data) == null ? void 0 : _raw_data4.resultInfo);

            case 16:
              return _context66.abrupt("return", {
                apiKey: raw_data.apiKey,
                raw_data: raw_data
              });

            case 17:
            case "end":
              return _context66.stop();
          }
        }
      }, _callee66, this, [[3, 9]]);
    }));

    function getUserApiKey(_x127, _x128) {
      return _getUserApiKey.apply(this, arguments);
    }

    return getUserApiKey;
  }()
  /*
   * Get user txs
   */
  ;

  _proto.getUserBills =
  /*#__PURE__*/
  function () {
    var _getUserBills = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee67(request, apiKey) {
      var reqParams, raw_data, userTxs;
      return runtime_1.wrap(function _callee67$(_context67) {
        while (1) {
          switch (_context67.prev = _context67.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_BILLS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context67.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context67.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context67.next = 6;
                break;
              }

              return _context67.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userTxs = [];

              if ((raw_data == null ? void 0 : raw_data.transactions) instanceof Array) {
                raw_data.transactions.forEach(function (item) {
                  userTxs.push(item);
                });
              }

              return _context67.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userTxs: userTxs,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context67.stop();
          }
        }
      }, _callee67, this);
    }));

    function getUserBills(_x129, _x130) {
      return _getUserBills.apply(this, arguments);
    }

    return getUserBills;
  }();

  return UserAPI;
}(BaseAPI);

var WalletAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(WalletAPI, _BaseAPI);

  function WalletAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = WalletAPI.prototype;

  /*
   * Get user assets
   */
  _proto.getUserAssets =
  /*#__PURE__*/
  function () {
    var _getUserAssets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request) {
      var reqParams, raw_data, assetSeries, timestampSeries, dateSeries;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_ASSETS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              assetSeries = [];
              timestampSeries = [];
              dateSeries = [];

              if ((raw_data == null ? void 0 : raw_data.data) instanceof Array) {
                raw_data.data.forEach(function (item) {
                  assetSeries.push(item.amount);
                  timestampSeries.push(item.createdAt);
                  dateSeries.push(item.createdAtStr);
                });
              }

              return _context.abrupt("return", {
                assetSeries: assetSeries,
                timestampSeries: timestampSeries,
                dateSeries: dateSeries,
                userAssets: raw_data.data,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getUserAssets(_x) {
      return _getUserAssets.apply(this, arguments);
    }

    return getUserAssets;
  }() // 1.x
  // 2.0
  // const TYPE_STR =
  //   "recover(address wallet,uint256 validUntil,address newOwner,address[] newGuardians)";
  // const RECOVER_TYPEHASH = ethUtil.keccak(Buffer.from(TYPE_STR));
  //
  // const guardiansBs = encodeAddressesPacked(guardians);
  // const guardiansHash = ethUtil.keccak(guardiansBs);
  //
  // const encodedRequest = ethAbi.encodeParameters(
  //   ["bytes32", "address", "uint256", "address", "bytes32"],
  //   [RECOVER_TYPEHASH, walletAddress, validUntil, newOwner, guardiansHash]
  // );
  //
  //   const encodedRequest = web3.eth.abi.encodeParameters(
  //     ["bytes32", "address", "uint256", "address"],
  //     [RECOVER_TYPEHASH, request.wallet, request.validUntil, newOwner]
  //   );
  ;

  _proto.getApproveRecoverTypedData = function getApproveRecoverTypedData(chainId, guardiaContractAddress, wallet, validUntil, newOwner) {
    var typedData = {
      types: {
        EIP712Domain: [{
          name: "name",
          type: "string"
        }, {
          name: "version",
          type: "string"
        }, {
          name: "chainId",
          type: "uint256"
        }, {
          name: "verifyingContract",
          type: "address"
        }],
        recover: [{
          name: "wallet",
          type: "address"
        }, {
          name: "validUntil",
          type: "uint256"
        }, {
          name: "newOwner",
          type: "address"
        }]
      },
      domain: {
        name: "GuardianModule",
        version: "1.2.0",
        chainId: chainId,
        verifyingContract: guardiaContractAddress
      },
      primaryType: "recover",
      message: {
        wallet: wallet,
        validUntil: validUntil,
        newOwner: newOwner
      }
    };
    return typedData;
  };

  _proto.getApproveRecoverV2TypedData = function getApproveRecoverV2TypedData(chainId, guardiaContractAddress, wallet, validUntil, newOwner, newGuardians) {
    var typedData = {
      types: {
        EIP712Domain: [{
          name: "name",
          type: "string"
        }, {
          name: "version",
          type: "string"
        }, {
          name: "chainId",
          type: "uint256"
        }, {
          name: "verifyingContract",
          type: "address"
        }],
        recover: [{
          name: "wallet",
          type: "address"
        }, {
          name: "validUntil",
          type: "uint256"
        }, {
          name: "newOwner",
          type: "address"
        }, {
          name: "newGuardians",
          type: "string"
        }]
      },
      domain: {
        name: "GuardianModule",
        version: "1.2.0",
        chainId: chainId,
        verifyingContract: guardiaContractAddress
      },
      primaryType: "recover",
      message: {
        wallet: wallet,
        validUntil: validUntil,
        newOwner: newOwner,
        newGuardians: newGuardians
      }
    };
    return typedData;
  };

  _proto.rejectApproveHash = function rejectApproveHash(request) {
    var uri = encodeURIComponent("" + (this.baseUrl + exports.LOOPRING_URLs.REJECT_APPROVE_SIGNATURE));
    var params = encodeURIComponent(JSON.stringify({
      approveRecordId: request.approveRecordId,
      signer: request.signer
    }));
    var message = exports.ReqMethod.POST + "&" + uri + "&" + params;
    myLog("rejectApproveHash", message);
    myLog("rejectApproveHash hash", toHex(ethUtil.sha256(Buffer.from(message))));
    return toHex(ethUtil.sha256(Buffer.from(message)));
  }
  /**
   *
   * @param approveRecordId  request.id
   */
  ;

  _proto.rejectHebao =
  /*#__PURE__*/
  function () {
    var _rejectHebao = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(req) {
      var web3, address, request, chainId, signHash, result, dataToSig, reqParams, hash, raw_data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              web3 = req.web3, address = req.address, request = req.request, chainId = req.chainId;
              signHash = this.rejectApproveHash({
                approveRecordId: request.approveRecordId,
                signer: request.signer
              });
              _context2.next = 4;
              return personalSign(web3, address, "", signHash, exports.ConnectorNames.Unknown, chainId);

            case 4:
              result = _context2.sent;
              dataToSig = new Map();
              dataToSig.set("approveRecordId", request.approveRecordId);
              dataToSig.set("signer", address);
              reqParams = {
                url: exports.LOOPRING_URLs.REJECT_APPROVE_SIGNATURE,
                queryParams: {},
                method: exports.ReqMethod.POST,
                bodyParams: request,
                apiKey: "",
                sigFlag: exports.SIG_FLAG.NO_SIG,
                sigObj: {
                  sig: result == null ? void 0 : result.sig.slice(0, 132)
                }
              };
              hash = undefined;
              _context2.next = 12;
              return this.makeReq().request(reqParams);

            case 12:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context2.next = 17;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 17:
              hash = raw_data.data;

            case 18:
              return _context2.abrupt("return", {
                hash: hash,
                raw_data: raw_data
              });

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function rejectHebao(_x2) {
      return _rejectHebao.apply(this, arguments);
    }

    return rejectHebao;
  }();

  _proto.signHebaoApproveWithoutDataStructure = /*#__PURE__*/function () {
    var _signHebaoApproveWithoutDataStructure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(web3, owner, guardian, chainId, walletType) {
      var result;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return personalSign(web3, owner, "", guardian.messageHash, walletType, chainId);

            case 2:
              result = _context3.sent;
              return _context3.abrupt("return", result);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function signHebaoApproveWithoutDataStructure(_x3, _x4, _x5, _x6, _x7) {
      return _signHebaoApproveWithoutDataStructure.apply(this, arguments);
    }

    return signHebaoApproveWithoutDataStructure;
  }();

  _proto.signHebaoApproveWithDataStructureForContract = /*#__PURE__*/function () {
    var _signHebaoApproveWithDataStructureForContract = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(web3, owner, guardian, chainId, newOwner, newGuardians, masterCopy, forwarderModuleAddress) {
      var typedData, result;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (newOwner === void 0) {
                newOwner = "";
              }

              if (newGuardians === void 0) {
                newGuardians = undefined;
              }

              if (masterCopy === void 0) {
                masterCopy = undefined;
              }

              if (forwarderModuleAddress === void 0) {
                forwarderModuleAddress = undefined;
              }

              myLog("forwarderModuleAddress", forwarderModuleAddress);

              if (forwarderModuleAddress) {
                typedData = this.getApproveRecoverTypedData(chainId, forwarderModuleAddress, guardian.signedRequest.wallet, guardian.signedRequest.validUntil, newOwner);
                myLog("typedData", typedData);
              } else {
                typedData = this.getApproveRecoverV2TypedData(chainId, masterCopy, guardian.signedRequest.wallet, guardian.signedRequest.validUntil, newOwner, newGuardians);
                myLog("typedData", typedData);
              }

              _context4.next = 8;
              return getEcDSASig(web3, typedData, owner, exports.GetEcDSASigType.Contract, chainId, undefined, "", exports.ConnectorNames.Unknown // counterFactualInfo
              );

            case 8:
              result = _context4.sent;
              return _context4.abrupt("return", {
                sig: result.ecdsaSig
              });

            case 10:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function signHebaoApproveWithDataStructureForContract(_x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15) {
      return _signHebaoApproveWithDataStructureForContract.apply(this, arguments);
    }

    return signHebaoApproveWithDataStructureForContract;
  }();

  _proto.encodeAddressesPacked = function encodeAddressesPacked(addrs) {
    var addrsBs = Buffer.concat(addrs.map(function (a) {
      return Buffer.from("00".repeat(12) + a.slice(2), "hex");
    }));
    myLog("addrsBs", addrsBs.toString());
    return addrsBs;
  };

  _proto.submitApproveSignature = /*#__PURE__*/function () {
    var _submitApproveSignature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(req, guardians, isContract1XAddress, masterCopy, forwarderModuleAddress) {
      var _this = this;

      var request, web3, chainId, walletType, guardian, apiKey, isHWAddrOld, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, newOwner, newGuardians, guardiansBs, guardiansHash, _result, reqParams, raw_data;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:

              if (forwarderModuleAddress === void 0) {
                forwarderModuleAddress = "";
              }

              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, guardian = req.guardian, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;

              sigHW = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
                  var result;
                  return runtime_1.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this.signHebaoApproveWithoutDataStructure(web3, request.signer, guardian, chainId, walletType);

                        case 2:
                          result = _context5.sent;
                          ecdsaSignature = (result == null ? void 0 : result.sig) + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }));

                return function sigHW() {
                  return _ref.apply(this, arguments);
                };
              }(); // metamask not import hw appWallet.


              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.Coinbase || walletType === exports.ConnectorNames.OtherExtension)) {
                _context6.next = 24;
                break;
              }

              _context6.prev = 7;

              if (!isHWAddr) {
                _context6.next = 13;
                break;
              }

              _context6.next = 11;
              return sigHW();

            case 11:
              _context6.next = 17;
              break;

            case 13:
              _context6.next = 15;
              return this.signHebaoApproveWithoutDataStructure(web3, request.signer, guardian, chainId, walletType);

            case 15:
              result = _context6.sent;
              ecdsaSignature = (result == null ? void 0 : result.sig) + exports.SigSuffix.Suffix03;

            case 17:
              _context6.next = 22;
              break;

            case 19:
              _context6.prev = 19;
              _context6.t0 = _context6["catch"](7);
              throw _extends({}, this.genErr(_context6.t0));

            case 22:
              _context6.next = 47;
              break;

            case 24:
              _context6.next = 26;
              return isContract(web3, request.signer);

            case 26:
              isContractCheck = _context6.sent;
              _context6.prev = 27;

              if (!isContractCheck) {
                _context6.next = 40;
                break;
              }

              newOwner = undefined, newGuardians = [];

              if (guardian.businessDataJson && guardian.businessDataJson.value && guardian.businessDataJson.value.value) {
                newOwner = guardian.businessDataJson.value.value.newOwner;
                newGuardians = guardian.businessDataJson.value.value.newGuardians;
              }

              guardiansBs = this.encodeAddressesPacked(newGuardians);
              guardiansHash = ethUtil.keccak(guardiansBs); // const guardiansBs =
              //   LoopringAPI.walletAPI.encodeAddressesPacked(guardian.businessDataJson.value.value.newGuardians);

              _context6.next = 36;
              return this.signHebaoApproveWithDataStructureForContract(web3, request.signer, guardian, chainId, newOwner, isContract1XAddress ? undefined : guardiansHash, isContract1XAddress ? undefined : masterCopy, forwarderModuleAddress ? undefined : forwarderModuleAddress);

            case 36:
              _result = _context6.sent;
              ecdsaSignature = _result.sig;
              _context6.next = 42;
              break;

            case 40:
              _context6.next = 42;
              return sigHW();

            case 42:
              _context6.next = 47;
              break;

            case 44:
              _context6.prev = 44;
              _context6.t1 = _context6["catch"](27);
              throw _extends({}, this.genErr(_context6.t1));

            case 47:
              request.signature = ecdsaSignature;
              reqParams = {
                url: exports.LOOPRING_URLs.SUBMIT_APPROVE_SIGNATURE,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context6.prev = 49;
              _context6.next = 52;
              return this.makeReq().request(reqParams);

            case 52:
              raw_data = _context6.sent.data;
              _context6.next = 58;
              break;

            case 55:
              _context6.prev = 55;
              _context6.t2 = _context6["catch"](49);
              throw _context6.t2;

            case 58:
              return _context6.abrupt("return", this.returnTxHash(raw_data));

            case 59:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this, [[7, 19], [27, 44], [49, 55]]);
    }));

    function submitApproveSignature(_x16, _x17, _x18, _x19, _x20) {
      return _submitApproveSignature.apply(this, arguments);
    }

    return submitApproveSignature;
  }();

  _proto.getAddressByENS = /*#__PURE__*/function () {
    var _getAddressByENS = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(request) {
      var reqParams, address, raw_data;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.RESOLVE_ENS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context7.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context7.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context7.next = 8;
                break;
              }

              return _context7.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              address = raw_data.data;

            case 9:
              return _context7.abrupt("return", {
                address: address,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getAddressByENS(_x21) {
      return _getAddressByENS.apply(this, arguments);
    }

    return getAddressByENS;
  }();

  _proto.getWalletType = /*#__PURE__*/function () {
    var _getWalletType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(request) {
      var reqParams, walletType, raw_data;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_WALLET_TYPE,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context8.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context8.next = 8;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              walletType = raw_data.data;

            case 9:
              return _context8.abrupt("return", {
                walletType: walletType,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getWalletType(_x22) {
      return _getWalletType.apply(this, arguments);
    }

    return getWalletType;
  }();

  _proto.getContractType = /*#__PURE__*/function () {
    var _getContractType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request) {
      var reqParams, raw_data, contractType;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_WALLET_CONTRACTVERSION,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context9.next = 8;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              contractType = raw_data.data[0];

            case 9:
              return _context9.abrupt("return", {
                contractType: contractType,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getContractType(_x23) {
      return _getContractType.apply(this, arguments);
    }

    return getContractType;
  }();

  _proto.getWalletModules = /*#__PURE__*/function () {
    var _getWalletModules = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request) {
      var reqParams, raw_data, walletModule;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_WALLET_MODULES,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context10.next = 8;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              walletModule = raw_data.data[0];

            case 9:
              return _context10.abrupt("return", {
                walletModule: walletModule,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getWalletModules(_x24) {
      return _getWalletModules.apply(this, arguments);
    }

    return getWalletModules;
  }();

  _proto.getEnsByAddress = /*#__PURE__*/function () {
    var _getEnsByAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(request) {
      var reqParams, ensName, raw_data;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.RESOLVE_NAME,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context11.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context11.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context11.next = 8;
                break;
              }

              return _context11.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              ensName = raw_data.data;

            case 9:
              return _context11.abrupt("return", {
                ensName: ensName,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function getEnsByAddress(_x25) {
      return _getEnsByAddress.apply(this, arguments);
    }

    return getEnsByAddress;
  }();

  _proto.lockHebaoWallet = /*#__PURE__*/function () {
    var _lockHebaoWallet = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(_ref2) {
      var web3, from, contractAddress, gasPrice, _ref2$gasLimit, gasLimit, _ref2$chainId, chainId, wallet, nonce, isVersion1, data;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              web3 = _ref2.web3, from = _ref2.from, contractAddress = _ref2.contractAddress, gasPrice = _ref2.gasPrice, _ref2$gasLimit = _ref2.gasLimit, gasLimit = _ref2$gasLimit === void 0 ? 150000 : _ref2$gasLimit, _ref2$chainId = _ref2.chainId, chainId = _ref2$chainId === void 0 ? 1 : _ref2$chainId, wallet = _ref2.wallet, nonce = _ref2.nonce, isVersion1 = _ref2.isVersion1;

              if (!isVersion1) {
                _context12.next = 8;
                break;
              }

              data = contracts.Contracts.HeBao.encodeInputs("lock", {
                wallet: wallet
              });
              _context12.next = 5;
              return sendRawTx(web3, from, contractAddress, 0, data, chainId, nonce, gasPrice, Number(gasLimit), true);

            case 5:
              return _context12.abrupt("return", _context12.sent);

            case 8:
              _context12.next = 10;
              return sendRawTx(web3, from, contractAddress, 0, "0xf83d08ba", chainId, nonce, gasPrice, Number(gasLimit), true);

            case 10:
              return _context12.abrupt("return", _context12.sent);

            case 11:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    function lockHebaoWallet(_x26) {
      return _lockHebaoWallet.apply(this, arguments);
    }

    return lockHebaoWallet;
  }();

  _proto.getHebaoConfig = /*#__PURE__*/function () {
    var _getHebaoConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_HEBAO_CONFIG,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context13.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context13.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context13.next = 6;
                break;
              }

              return _context13.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context13.abrupt("return", {
                raw_data: raw_data.data
              });

            case 7:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function getHebaoConfig(_x27) {
      return _getHebaoConfig.apply(this, arguments);
    }

    return getHebaoConfig;
  }();

  _proto.sendMetaTx = /*#__PURE__*/function () {
    var _sendMetaTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.SEND_META_TX,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                bodyParams: request
              };
              _context14.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context14.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context14.next = 6;
                break;
              }

              return _context14.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context14.abrupt("return", {
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function sendMetaTx(_x28, _x29) {
      return _sendMetaTx.apply(this, arguments);
    }

    return sendMetaTx;
  }();

  _proto.getGuardianApproveList = /*#__PURE__*/function () {
    var _getGuardianApproveList = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(request) {
      var reqParams, guardiansArray, raw_data, _raw_data$data;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_GUARDIAN_APPROVE_LIST,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              guardiansArray = [];
              _context15.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context15.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context15.next = 9;
                break;
              }

              return _context15.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              guardiansArray = raw_data == null ? void 0 : (_raw_data$data = raw_data.data) == null ? void 0 : _raw_data$data.guardians.map(function (r) {
                return _extends({
                  ens: r.ens ? r.ens : "",
                  address: r.wallet,
                  type: exports.HEBAO_META_TYPE[r.metaTxType],
                  id: r.approveId,
                  messageHash: r.txAwareHash,
                  businessDataJson: r.businessDataJson,
                  signedRequest: r.signedRequest
                }, r);
              });

            case 10:
              return _context15.abrupt("return", {
                guardiansArray: guardiansArray,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function getGuardianApproveList(_x30) {
      return _getGuardianApproveList.apply(this, arguments);
    }

    return getGuardianApproveList;
  }() // /api/appWallet/v3/operationLogs?from=0x189a3c44a39c5ab22712543c0f62a9833bbe8df9&fromTime=0&to=&offset=0&network=ETHEREUM&statues=&hebaoTxType=&limit=20

  /**
   * getProtectors
   * @param {GetUserTradesRequest} request
   * @param apiKey
   */
  ;

  _proto.getProtectors =
  /*#__PURE__*/
  function () {
    var _getProtectors = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request, apiKey) {
      var reqParams, protectorArray, raw_data;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_PROTECTORS,
                apiKey: apiKey,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              protectorArray = [];
              _context16.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context16.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context16.next = 9;
                break;
              }

              return _context16.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 9:
              protectorArray = raw_data == null ? void 0 : raw_data.data.map(function (p) {
                var _p$walletStatus;

                return {
                  ens: p.protectEns,
                  address: p.protectAddress,
                  lockStatus: (_p$walletStatus = p.walletStatus) == null ? void 0 : _p$walletStatus.toUpperCase()
                };
              });

            case 10:
              return _context16.abrupt("return", {
                protectorArray: protectorArray,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function getProtectors(_x31, _x32) {
      return _getProtectors.apply(this, arguments);
    }

    return getProtectors;
  }()
  /*
   * Get user trade amount
   */
  ;

  _proto.getHebaoOperationLogs =
  /*#__PURE__*/
  function () {
    var _getHebaoOperationLogs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_OPERATION_LOGS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context17.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context17.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context17.next = 6;
                break;
              }

              return _context17.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context17.abrupt("return", {
                operationArray: raw_data.data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function getHebaoOperationLogs(_x33) {
      return _getHebaoOperationLogs.apply(this, arguments);
    }

    return getHebaoOperationLogs;
  }()
  /*
   * Get user trade amount
   */
  ;

  _proto.getUserTradeAmount =
  /*#__PURE__*/
  function () {
    var _getUserTradeAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_TRADE_AMOUNT,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context18.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context18.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context18.next = 6;
                break;
              }

              return _context18.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context18.abrupt("return", {
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function getUserTradeAmount(_x34) {
      return _getUserTradeAmount.apply(this, arguments);
    }

    return getUserTradeAmount;
  }()
  /*
   * Get token prices
   * e.g. http://api3.loopring.io/api/wallet/v3/tokenPrices?token=0xdac17f958d2ee523a2206206994597c13d831ec7&intervalType=1&limit=30&currency=CNY
   */
  ;

  _proto.getTokenPrices =
  /*#__PURE__*/
  function () {
    var _getTokenPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(request) {
      var reqParams, raw_data, priceSeries, timestampSeries;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_TOKEN_PRICES,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context19.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context19.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context19.next = 6;
                break;
              }

              return _context19.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              priceSeries = [];
              timestampSeries = [];

              if ((raw_data == null ? void 0 : raw_data.data) instanceof Array) {
                raw_data.data.forEach(function (item) {
                  priceSeries.push(item.price);
                  timestampSeries.push(item.createdAt);
                });
              }

              return _context19.abrupt("return", {
                tokenPrices: raw_data.data,
                priceSeries: priceSeries,
                timestampSeries: timestampSeries,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function getTokenPrices(_x35) {
      return _getTokenPrices.apply(this, arguments);
    }

    return getTokenPrices;
  }()
  /*
   * Fetches, for all the tokens supported by Loopring, their fiat price.
   * response: { [key: string]: <price> }  key is token address
   */
  ;

  _proto.getLatestTokenPrices =
  /*#__PURE__*/
  function () {
    var _getLatestTokenPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(request) {
      var reqParams, raw_data, tokenPrices;
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              reqParams = {
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_LATEST_TOKEN_PRICES,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context20.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context20.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context20.next = 6;
                break;
              }

              return _context20.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              tokenPrices = {};

              if ((raw_data == null ? void 0 : raw_data.data) instanceof Array) {
                raw_data.data.forEach(function (item) {
                  tokenPrices[item.token.toLowerCase()] = parseFloat(item.price);
                });
              }

              return _context20.abrupt("return", {
                tokenPrices: tokenPrices,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getLatestTokenPrices(_x36) {
      return _getLatestTokenPrices.apply(this, arguments);
    }

    return getLatestTokenPrices;
  }();

  return WalletAPI;
}(BaseAPI);

var WhitelistedUserAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(WhitelistedUserAPI, _BaseAPI);

  function WhitelistedUserAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = WhitelistedUserAPI.prototype;

  /*
   * Submit offchain withdraw request
   * not supported for now.
   */
  _proto.submitOffchainWithdraw =
  /*#__PURE__*/
  function () {
    var _submitOffchainWithdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request, eddsaKey, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              request.eddsaSignature = get_EddsaSig_OffChainWithdraw(request, eddsaKey).result;
              reqParams = {
                url: exports.LOOPRING_URLs.WITHDRAWALS_ACTION,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context.abrupt("return", {
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function submitOffchainWithdraw(_x, _x2, _x3) {
      return _submitOffchainWithdraw.apply(this, arguments);
    }

    return submitOffchainWithdraw;
  }()
  /*
   * Submit offchain withdraw request
   */
  ;

  _proto.submitInternalTransfer =
  /*#__PURE__*/
  function () {
    var _submitInternalTransfer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request, eddsaKey, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              request.eddsaSignature = get_EddsaSig_Transfer(request, eddsaKey).result;
              reqParams = {
                url: exports.LOOPRING_URLs.POST_INTERNAL_TRANSFER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context2.abrupt("return", {
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function submitInternalTransfer(_x4, _x5, _x6) {
      return _submitInternalTransfer.apply(this, arguments);
    }

    return submitInternalTransfer;
  }();

  return WhitelistedUserAPI;
}(BaseAPI);

var _CREATION_CODE;
var CREATION_CODE = (_CREATION_CODE = {}, _CREATION_CODE[exports.ChainId.GOERLI] = "3d602d80600a3d3981f3363d3d373d3d3d363d735854e62554ce1c146a375c370bc0d323368b372d5af43d82803e903d91602b57fd5bf3", _CREATION_CODE[exports.ChainId.MAINNET] = "3d602d80600a3d3981f3363d3d373d3d3d363d73b25f6d711aebf954fb0265a3b29f7b9beba7e55d5af43d82803e903d91602b57fd5bf3", _CREATION_CODE);

(function (NFTType) {
  NFTType[NFTType["ERC1155"] = 0] = "ERC1155";
  NFTType[NFTType["ERC721"] = 1] = "ERC721";
})(exports.NFTType || (exports.NFTType = {}));

(function (NFT_TYPE_STRING) {
  NFT_TYPE_STRING["ERC1155"] = "ERC1155";
  NFT_TYPE_STRING["ERC721"] = "ERC721";
})(exports.NFT_TYPE_STRING || (exports.NFT_TYPE_STRING = {}));

(function (NFTMethod) {
  NFTMethod["setApprovalForAll"] = "setApprovalForAll";
  NFTMethod["isApprovedForAll"] = "isApprovedForAll";
  NFTMethod["uri"] = "uri";
  NFTMethod["tokenURI"] = "tokenURI";
  NFTMethod["depositNFT"] = "depositNFT";
  NFTMethod["balanceOf"] = "balanceOf";
  NFTMethod["ownerOf"] = "ownerOf"; // Deposit = 'deposit',
  // ForceWithdraw = 'forceWithdraw'
})(exports.NFTMethod || (exports.NFTMethod = {}));

var NFTAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(NFTAPI, _BaseAPI);

  function NFTAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = NFTAPI.prototype;

  _proto.callContractMethod = /*#__PURE__*/function () {
    var _callContractMethod = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(web3, method, data, contractAddress, type) {
      var _contract$methods;

      var contract;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (type === void 0) {
                type = exports.NFTType.ERC1155;
              }

              // return _genContractData(Contracts.ERC20Token, method, data)
              contract = this._genContract(web3, contractAddress, type);
              return _context.abrupt("return", (_contract$methods = contract.methods)[method].apply(_contract$methods, data).call());

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function callContractMethod(_x, _x2, _x3, _x4, _x5) {
      return _callContractMethod.apply(this, arguments);
    }

    return callContractMethod;
  }();

  _proto._genContractData = function _genContractData(Contract, method, data) {
    return Contract.encodeInputs(method, data);
  };

  _proto._genERC1155Data = function _genERC1155Data(method, data) {
    return this._genContractData(contracts.Contracts.ERC1155, method, data);
  };

  _proto._genERC721Data = function _genERC721Data(method, data) {
    return this._genContractData(contracts.Contracts.ERC721, method, data);
  };

  _proto._genContract = function _genContract(web3, contractAddress, type) {
    if (type === void 0) {
      type = exports.NFTType.ERC1155;
    }

    return new web3.eth.Contract(type === exports.NFTType.ERC1155 ? contracts.Contracts.erc1155Abi : contracts.Contracts.erc721Abi, contractAddress);
  }
  /**
   * getNFTBalance
   * @param web3
   * @param tokenAddress
   * @param account
   * @param nftId
   * @param nftType
   */
  ;

  _proto.getNFTBalance =
  /*#__PURE__*/
  function () {
    var _getNFTBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var web3, tokenAddress, account, nftId, _ref$nftType, nftType, result, _result;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              web3 = _ref.web3, tokenAddress = _ref.tokenAddress, account = _ref.account, nftId = _ref.nftId, _ref$nftType = _ref.nftType, nftType = _ref$nftType === void 0 ? exports.NFTType.ERC1155 : _ref$nftType;
              _context2.prev = 1;

              if (!(nftType === exports.NFTType.ERC721)) {
                _context2.next = 13;
                break;
              }

              _context2.next = 5;
              return this.callContractMethod(web3, exports.NFTMethod.ownerOf, [nftId], tokenAddress, nftType);

            case 5:
              result = _context2.sent;

              if (!(result.toLowerCase() === account.toLowerCase())) {
                _context2.next = 10;
                break;
              }

              return _context2.abrupt("return", {
                count: "1"
              });

            case 10:
              return _context2.abrupt("return", {
                count: "0"
              });

            case 11:
              _context2.next = 17;
              break;

            case 13:
              _context2.next = 15;
              return this.callContractMethod(web3, exports.NFTMethod.balanceOf, [account, web3.utils.hexToNumberString(nftId)], tokenAddress, nftType);

            case 15:
              _result = _context2.sent;
              return _context2.abrupt("return", {
                count: _result.toString()
              });

            case 17:
              _context2.next = 22;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](1);
              return _context2.abrupt("return", _extends({}, _context2.t0, {
                code: exports.LoopringErrorCode.CONTRACTNFT_BALANCE,
                message: exports.ConnectorError.CONTRACTNFT_BALANCE
              }));

            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[1, 19]]);
    }));

    function getNFTBalance(_x6) {
      return _getNFTBalance.apply(this, arguments);
    }

    return getNFTBalance;
  }()
  /**
   * getInfoForNFTTokens
   * @param nftDatas NftData[]
   */
  ;

  _proto.getInfoForNFTTokens =
  /*#__PURE__*/
  function () {
    var _getInfoForNFTTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(_ref2) {
      var nftDatas, reqParams, raw_data, result;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              nftDatas = _ref2.nftDatas;
              _context3.prev = 1;
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                url: exports.LOOPRING_URLs.GET_NFTs_INFO,
                method: exports.ReqMethod.GET,
                queryParams: {
                  nftDatas: nftDatas.join(",")
                }
              };
              _context3.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              result = raw_data.reduce(function (prev, item) {
                if (item.nftId && item.nftId.startsWith("0x")) {
                  var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                  item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                }

                prev[item.nftData] = item;
                return prev;
              }, {});
              return _context3.abrupt("return", _extends({}, result, {
                raw_data: raw_data
              }));

            case 12:
              _context3.prev = 12;
              _context3.t0 = _context3["catch"](1);
              return _context3.abrupt("return", undefined);

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[1, 12]]);
    }));

    function getInfoForNFTTokens(_x7) {
      return _getInfoForNFTTokens.apply(this, arguments);
    }

    return getInfoForNFTTokens;
  }();

  _proto.callRefreshNFT = /*#__PURE__*/function () {
    var _callRefreshNFT = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request) {
      var reqParams, raw_data, result;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                bodyParams: request,
                url: exports.LOOPRING_URLs.POST_NFT_VALIDATE_REFRESH_NFT,
                method: exports.ReqMethod.POST
              };
              _context4.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              result = raw_data.reduce(function (prev, item) {
                if (item.nftId && item.nftId.startsWith("0x")) {
                  var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                  item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                }

                prev[item.nftData] = item;
                return prev;
              }, {});
              return _context4.abrupt("return", _extends({}, result, {
                raw_data: raw_data
              }));

            case 11:
              _context4.prev = 11;
              _context4.t0 = _context4["catch"](0);
              return _context4.abrupt("return", undefined);

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[0, 11]]);
    }));

    function callRefreshNFT(_x8) {
      return _callRefreshNFT.apply(this, arguments);
    }

    return callRefreshNFT;
  }()
  /**
   * getContractNFTMeta
   * @param web3
   * @param tokenAddress
   * @param _id
   * @param nftType
   */
  ;

  _proto.getContractNFTMeta =
  /*#__PURE__*/
  function () {
    var _getContractNFTMeta = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(_ref3, _IPFS_META_URL) {
      var web3, tokenAddress, nftId, _ref3$nftType, nftType, result;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              web3 = _ref3.web3, tokenAddress = _ref3.tokenAddress, nftId = _ref3.nftId, _ref3$nftType = _ref3.nftType, nftType = _ref3$nftType === void 0 ? exports.NFTType.ERC1155 : _ref3$nftType;

              _context5.prev = 2;
              myLog(tokenAddress, "nftid", nftId, web3.utils.hexToNumberString(nftId));
              _context5.next = 6;
              return this.callContractMethod(web3, nftType === exports.NFTType.ERC1155 ? exports.NFTMethod.uri : exports.NFTMethod.tokenURI, [web3.utils.hexToNumberString(nftId)], tokenAddress, nftType);

            case 6:
              result = _context5.sent;
              result = result.replace(/^ipfs:\/\/(ipfs\/)?/, exports.LOOPRING_URLs.IPFS_META_URL);
              result = result.replace("{id}", web3.utils.hexToNumberString(nftId));
              _context5.next = 11;
              return fetch(result).then(function (response) {
                return response.json();
              });

            case 11:
              return _context5.abrupt("return", _context5.sent);

            case 14:
              _context5.prev = 14;
              _context5.t0 = _context5["catch"](2);
              return _context5.abrupt("return", _extends({
                code: exports.LoopringErrorCode.CONTRACTNFT_URI,
                message: exports.ConnectorError.CONTRACTNFT_URI
              }, _context5.t0));

            case 17:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[2, 14]]);
    }));

    function getContractNFTMeta(_x9, _x10) {
      return _getContractNFTMeta.apply(this, arguments);
    }

    return getContractNFTMeta;
  }()
  /**
   * approveNFT
   * @param web3
   * @param from  The address that deposits the funds to the exchange
   * @param to  The address deposits to
   * @param nftId the nftId
   * @param chainId
   * @param nftType The type of NFTAction contract address (ERC721/ERC1155/...)
   * @param nonce
   * @param gasPrice
   * @param gasLimit
   * @param sendByMetaMask
   */
  ;

  _proto.approveNFT =
  /*#__PURE__*/
  function () {
    var _approveNFT = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(_ref4) {
      var web3, from, depositAddress, tokenAddress, _ref4$nftType, nftType, gasPrice, gasLimit, chainId, nonce, _ref4$approved, approved, _ref4$sendByMetaMask, sendByMetaMask, data;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              web3 = _ref4.web3, from = _ref4.from, depositAddress = _ref4.depositAddress, tokenAddress = _ref4.tokenAddress, _ref4$nftType = _ref4.nftType, nftType = _ref4$nftType === void 0 ? exports.NFTType.ERC1155 : _ref4$nftType, gasPrice = _ref4.gasPrice, gasLimit = _ref4.gasLimit, chainId = _ref4.chainId, nonce = _ref4.nonce, _ref4$approved = _ref4.approved, approved = _ref4$approved === void 0 ? true : _ref4$approved, _ref4$sendByMetaMask = _ref4.sendByMetaMask, sendByMetaMask = _ref4$sendByMetaMask === void 0 ? true : _ref4$sendByMetaMask;

              if (nftType === exports.NFTType.ERC1155) {
                data = this._genERC1155Data(exports.NFTMethod.setApprovalForAll, {
                  operator: depositAddress,
                  approved: approved
                });
              } else if (nftType === exports.NFTType.ERC721) {
                data = this._genERC721Data(exports.NFTMethod.setApprovalForAll, {
                  operator: depositAddress,
                  approved: approved
                });
              }

              _context6.prev = 2;
              _context6.next = 5;
              return sendRawTx(web3, from, tokenAddress, "0", data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

            case 5:
              return _context6.abrupt("return", _context6.sent);

            case 8:
              _context6.prev = 8;
              _context6.t0 = _context6["catch"](2);
              return _context6.abrupt("return", _extends({}, _context6.t0, {
                code: exports.LoopringErrorCode.CONTRACTNFT_SET_APPROVE,
                message: exports.ConnectorError.CONTRACTNFT_SET_APPROVE
              }));

            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this, [[2, 8]]);
    }));

    function approveNFT(_x11) {
      return _approveNFT.apply(this, arguments);
    }

    return approveNFT;
  }();

  _proto.ipfsCid0ToNftID = function ipfsCid0ToNftID(cidV0Str) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    var CID = require("cids");

    var cid = new CID(cidV0Str);
    var hashHex = Buffer.from(cid.multihash.slice(2)).toString("hex");
    var hashBN = new BN(hashHex, 16);
    return "0x" + hashBN.toString("hex").padStart(64, "0");
  }
  /**
   *
   * @param nftId  16
   */
  ;

  _proto.ipfsNftIDToCid = function ipfsNftIDToCid(nftId) {
    var CID = require("cids");

    var hashBN = new BN(nftId.replace("0x", ""), 16);
    var hex = hashBN.toString(16, 64);
    var buf = Buffer.from("1220" + hex, "hex");
    var cid = new CID(buf);
    return cid.toString();
  }
  /**
   * isApprovedForAll
   * @param web3
   * @param from The address that deposits the funds to the exchange
   * @param exchangeAddress loopring exchange address
   * @param nftType  NFTType
   * @param tokenAddress  The address of NFT token
   */
  ;

  _proto.isApprovedForAll =
  /*#__PURE__*/
  function () {
    var _isApprovedForAll = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(_ref5) {
      var web3, from, exchangeAddress, _ref5$nftType, nftType, tokenAddress, result;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              web3 = _ref5.web3, from = _ref5.from, exchangeAddress = _ref5.exchangeAddress, _ref5$nftType = _ref5.nftType, nftType = _ref5$nftType === void 0 ? exports.NFTType.ERC1155 : _ref5$nftType, tokenAddress = _ref5.tokenAddress;
              _context7.prev = 1;
              _context7.next = 4;
              return this.callContractMethod(web3, exports.NFTMethod.isApprovedForAll, [from, exchangeAddress], tokenAddress, nftType);

            case 4:
              result = _context7.sent;
              return _context7.abrupt("return", result);

            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](1);
              return _context7.abrupt("return", _extends({}, _context7.t0, {
                code: exports.LoopringErrorCode.CONTRACTNFT_IS_APPROVE,
                message: exports.ConnectorError.CONTRACTNFT_IS_APPROVE
              }));

            case 11:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this, [[1, 8]]);
    }));

    function isApprovedForAll(_x12) {
      return _isApprovedForAll.apply(this, arguments);
    }

    return isApprovedForAll;
  }()
  /**
   * @DepositParam  an NFTAction to the specified account.
   * @param web3
   * @param from The address that deposits the funds to the exchange
   * @param to The account owner's address receiving the funds
   * @param nftType The type of NFTAction contract address (ERC721/ERC1155/...)
   * @param tokenAddress The address of NFTAction token
   * @param nftId The token type 'id`.
   * @param amount The amount of tokens to deposit.
   * @param nonce: number,
   * @param gasPrice: number,
   * @param gasLimit: number,
   * @param extraData Optional extra data used by the deposit contract.
   * @param chainId  0|5
   * @param sendByMetaMask boolean
   */
  ;

  _proto.depositNFT =
  /*#__PURE__*/
  function () {
    var _depositNFT = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(_ref6) {
      var web3, from, exchangeAddress, _ref6$nftType, nftType, tokenAddress, nftId, amount, gasPrice, gasLimit, _ref6$chainId, chainId, nonce, extraData, _ref6$sendByMetaMask, sendByMetaMask, data;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              web3 = _ref6.web3, from = _ref6.from, exchangeAddress = _ref6.exchangeAddress, _ref6$nftType = _ref6.nftType, nftType = _ref6$nftType === void 0 ? exports.NFTType.ERC1155 : _ref6$nftType, tokenAddress = _ref6.tokenAddress, nftId = _ref6.nftId, amount = _ref6.amount, gasPrice = _ref6.gasPrice, gasLimit = _ref6.gasLimit, _ref6$chainId = _ref6.chainId, chainId = _ref6$chainId === void 0 ? exports.ChainId.MAINNET : _ref6$chainId, nonce = _ref6.nonce, extraData = _ref6.extraData, _ref6$sendByMetaMask = _ref6.sendByMetaMask, sendByMetaMask = _ref6$sendByMetaMask === void 0 ? true : _ref6$sendByMetaMask;
              data = genExchangeData(exports.NFTMethod.depositNFT, {
                from: from,
                to: from,
                nftType: nftType,
                tokenAddress: tokenAddress,
                nftId: nftId,
                amount: amount,
                extraData: extraData ? extraData : ""
              }); // myLog('depositNFT data',data)

              _context8.next = 4;
              return sendRawTx(web3, from, exchangeAddress, "0", data, chainId, nonce, gasPrice, gasLimit, sendByMetaMask);

            case 4:
              return _context8.abrupt("return", _context8.sent);

            case 5:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    function depositNFT(_x13) {
      return _depositNFT.apply(this, arguments);
    }

    return depositNFT;
  }()
  /**
   *
   * @function computeNFTAddress
   * @param owner {string} nftOwner address
   * @param nftFactory {string} Hash address
   * @return tokenAddress
   * @throws Error
   */
  ;

  _proto.computeNFTAddress = function computeNFTAddress(_ref7) {
    var nftOwner = _ref7.nftOwner,
        _ref7$nftFactory = _ref7.nftFactory,
        nftFactory = _ref7$nftFactory === void 0 ? "0xDB42E6F6cB2A2eFcF4c638cb7A61AdE5beD82609" : _ref7$nftFactory,
        _ref7$nftBaseUri = _ref7.nftBaseUri,
        nftBaseUri = _ref7$nftBaseUri === void 0 ? "" : _ref7$nftBaseUri;

    try {
      if (!nftFactory) {
        nftFactory = NFTFactory[this.chainId];
      }

      if (nftOwner.startsWith("0x")) {
        nftOwner = nftOwner.slice(2);
      }

      var saltBuf = Buffer.concat([Buffer.from("NFT_CONTRACT_CREATION", "utf8"), Buffer.from(nftOwner, "hex"), Buffer.from(nftBaseUri, "utf8")]);
      var codeHash = ethUtil.keccak(Buffer.from(CREATION_CODE[this.chainId], "hex"));
      var saltHash = ethUtil.keccak(saltBuf);
      var rawBuf = Buffer.concat([Buffer.from("ff", "hex"), Buffer.from(nftFactory.slice(2), "hex"), saltHash, codeHash]);
      var addr = ethUtil.keccak(rawBuf).slice(12).toString("hex");
      return {
        tokenAddress: ethUtil.toChecksumAddress("0x" + addr)
      };
    } catch (err) {
      return err;
    }
  };

  _proto.getPublicCollectionById = /*#__PURE__*/function () {
    var _getPublicCollectionById = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request) {
      var reqParams, raw_data, result;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                queryParams: request,
                url: exports.LOOPRING_URLs.GET_NFT_COLLECTION_PUBLISH,
                method: exports.ReqMethod.GET
              };
              _context9.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 7;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              result = raw_data;
              return _context9.abrupt("return", _extends({}, result, {
                raw_data: raw_data
              }));

            case 11:
              _context9.prev = 11;
              _context9.t0 = _context9["catch"](0);
              return _context9.abrupt("return", _extends({}, _context9.t0, {
                code: exports.LoopringErrorCode.SKD_UNKNOW
              }));

            case 14:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this, [[0, 11]]);
    }));

    function getPublicCollectionById(_x14) {
      return _getPublicCollectionById.apply(this, arguments);
    }

    return getPublicCollectionById;
  }();

  _proto.getCollectionWholeNFTs = /*#__PURE__*/function () {
    var _getCollectionWholeNFTs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_COLLECTION_WHOLE_NFTS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              if (raw_data.nftTokenInfos.length) {
                raw_data.nftTokenInfos = raw_data.nftTokenInfos.reduce(function (prev, item) {
                  if (item.nftId && item.nftId.startsWith("0x")) {
                    var hashBN = new BN(item.nftId.replace("0x", ""), 16);
                    item.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");

                    if (request.metadata === true && item.metadata && item.metadata.nftId && item.metadata.nftId.startsWith("0x")) {
                      // const hashBN = new BN(item.metadata.nftId.replace("0x", ""), 16);
                      item.metadata.nftId = "0x" + hashBN.toString("hex").padStart(64, "0");
                    }
                  }

                  return [].concat(prev, [item]);
                }, []); // const hashBN = new BN(raw_data.transactions.metadata.nftId.replace("0x", ""), 16);
                // raw_data.transactions.metadata.nftId= "0x" + hashBN.toString("hex").padStart(64, "0");
              }

              return _context10.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userNFTBalances: raw_data.nftTokenInfos,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getCollectionWholeNFTs(_x15) {
      return _getCollectionWholeNFTs.apply(this, arguments);
    }

    return getCollectionWholeNFTs;
  }();

  return NFTAPI;
}(BaseAPI);

var GLOBAL_KEY = {
  GOERLI: {
    key: "685xvATlBCsvzyiTxaS02vu0b1xN0DAFpNpslKUNCuSxDhx8gyyz8VmvUqqe5HSQ",
    id: 10013
  },
  MAIN: {
    key: "re356TcrQ6KhlpkvWxP4UN0C4EqxQVV7ZjvLjunwTjaQPZ20ue2ZgClFeT7okpDQ",
    id: 22638
  }
};
var GlobalAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(GlobalAPI, _BaseAPI);

  function GlobalAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = GlobalAPI.prototype;

  _proto.getActiveFeeInfo = /*#__PURE__*/function () {
    var _getActiveFeeInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request) {
      var _request, reqParams, raw_data, gasPrice, fees;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _request = {
                accountId: request.accountId ? request.accountId : this.chainId === exports.ChainId.MAINNET ? GLOBAL_KEY.MAIN.id : GLOBAL_KEY.GOERLI.id,
                requestType: exports.OffchainFeeReqType.UPDATE_ACCOUNT
              };
              reqParams = {
                url: exports.LOOPRING_URLs.GET_OFFCHAIN_FEE_AMT,
                queryParams: _request,
                apiKey: this.chainId === exports.ChainId.MAINNET ? GLOBAL_KEY.MAIN.key : GLOBAL_KEY.GOERLI.key,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              gasPrice = parseInt(raw_data.gasPrice);
              fees = {};

              if ((raw_data == null ? void 0 : raw_data.fees) instanceof Array) {
                raw_data.fees.forEach(function (item) {
                  fees[item.token] = item;
                });
              }

              return _context.abrupt("return", {
                fees: fees,
                gasPrice: gasPrice,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getActiveFeeInfo(_x) {
      return _getActiveFeeInfo.apply(this, arguments);
    }

    return getActiveFeeInfo;
  }();

  _proto.getUserBalanceForFee = /*#__PURE__*/function () {
    var _getUserBalanceForFee = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request) {
      var reqParams, raw_data, userBalances;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_USER_EXCHANGE_BALANCES,
                queryParams: request,
                apiKey: this.chainId === exports.ChainId.MAINNET ? GLOBAL_KEY.MAIN.key : GLOBAL_KEY.GOERLI.key,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              userBalances = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  userBalances[item.tokenId] = item;
                });
              }

              return _context2.abrupt("return", {
                userBalances: userBalances,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getUserBalanceForFee(_x2) {
      return _getUserBalanceForFee.apply(this, arguments);
    }

    return getUserBalanceForFee;
  }();

  _proto.getAmmPoolGameUserRank = /*#__PURE__*/function () {
    var _getAmmPoolGameUserRank = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request) {
      var reqParams, raw_data, userRank;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_AMMPOOL_GAME_USER_RANK,
                queryParams: request,
                apiKey: this.chainId === exports.ChainId.MAINNET ? GLOBAL_KEY.MAIN.key : GLOBAL_KEY.GOERLI.key,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data.resultInfo));

            case 6:
              userRank = raw_data.data;
              return _context3.abrupt("return", {
                userRank: userRank,
                raw_data: raw_data.data
              });

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getAmmPoolGameUserRank(_x3) {
      return _getAmmPoolGameUserRank.apply(this, arguments);
    }

    return getAmmPoolGameUserRank;
  }();

  _proto.getBanxaAPI = /*#__PURE__*/function () {
    var _getBanxaAPI = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(_ref, eddsaKey, apiKey) {
      var method, query, payload, url, accountId, queryParams, dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              method = _ref.method, query = _ref.query, payload = _ref.payload, url = _ref.url, accountId = _ref.accountId;
              queryParams = {
                accountId: accountId,
                url: url,
                method: method.toString(),
                query: query,
                payload: payload ? payload : ""
              };
              dataToSig = sortObjDictionary(_extends({}, queryParams, {
                url: encodeURIComponent(queryParams.url),
                query: encodeURIComponent(queryParams.query),
                payload: encodeURIComponent(queryParams.payload)
              }));
              reqParams = {
                url: exports.LOOPRING_URLs.GET_BANXA_API_KEY,
                method: exports.ReqMethod.GET,
                queryParams: queryParams,
                apiKey: apiKey,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  PrivateKey: eddsaKey,
                  dataToSig: dataToSig
                }
              };
              _context4.next = 6;
              return this.makeReq().request(reqParams);

            case 6:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context4.next = 9;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data.resultInfo));

            case 9:
              return _context4.abrupt("return", {
                result: raw_data.result,
                raw_data: raw_data
              });

            case 10:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getBanxaAPI(_x4, _x5, _x6) {
      return _getBanxaAPI.apply(this, arguments);
    }

    return getBanxaAPI;
  }();

  return GlobalAPI;
}(BaseAPI);

var DelegateAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(DelegateAPI, _BaseAPI);

  function DelegateAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = DelegateAPI.prototype;

  _proto.getCode = /*#__PURE__*/function () {
    var _getCode = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(address) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                url: exports.LOOPRING_URLs.GET_DELEGATE_GET_CODE,
                method: exports.ReqMethod.POST,
                bodyParams: {
                  address: address
                }
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context.abrupt("return", raw_data);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getCode(_x) {
      return _getCode.apply(this, arguments);
    }

    return getCode;
  }();

  _proto.getIPFS = /*#__PURE__*/function () {
    var _getIPFS = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(path) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                sigFlag: exports.SIG_FLAG.NO_SIG,
                url: exports.LOOPRING_URLs.GET_DELEGATE_GET_IPFS,
                method: exports.ReqMethod.GET,
                queryParams: {
                  path: path
                }
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo && raw_data != null && raw_data.resultInfo.code)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context2.abrupt("return", raw_data);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getIPFS(_x2) {
      return _getIPFS.apply(this, arguments);
    }

    return getIPFS;
  }();

  _proto.getCollectionDomain = function getCollectionDomain() {
    return this.chainId === exports.ChainId.GOERLI ? "https://uatnftinfos.loopring.io" : "https://nftinfos.loopring.io";
  };

  return DelegateAPI;
}(BaseAPI);

var _excluded$2 = ["lockTag"];
var DefiAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(DefiAPI, _BaseAPI);

  function DefiAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = DefiAPI.prototype;

  /*
   * Returns the fee rate of users placing orders in specific markets
   */
  _proto.getDefiToken =
  /*#__PURE__*/
  function () {
    var _getDefiToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var reqParams, raw_data, tokensMap, addressIndex, idIndex;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DEFI_TOKENS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              tokensMap = {};
              addressIndex = {};
              idIndex = {};

              if (raw_data instanceof Array) {
                raw_data.forEach(function (item) {
                  if (item.symbol.startsWith("LP-")) {
                    item.isLpToken = true;
                  } else {
                    item.isLpToken = false;
                  }

                  tokensMap[item.symbol] = item;

                  addressIndex[item.address.toLowerCase()] = item.symbol;
                  idIndex[item.tokenId] = item.symbol;
                });
              }

              return _context.abrupt("return", {
                tokensMap: tokensMap,
                idIndex: idIndex,
                addressIndex: addressIndex,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getDefiToken() {
      return _getDefiToken.apply(this, arguments);
    }

    return getDefiToken;
  }();

  _proto.getDefiMarkets = /*#__PURE__*/function () {
    var _getDefiMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request, url) {
      var reqParams, raw_data, markets, pairs, _request$defiType, types, _markets, marketArr, tokenArr;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (url === void 0) {
                url = exports.LOOPRING_URLs.GET_DEFI_MARKETS;
              }

              reqParams = {
                url: url,
                queryParams: {},
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              markets = {};
              pairs = {}; // const isMix = url === LOOPRING_URLs.GET_MIX_MARKETS;

              if ((raw_data == null ? void 0 : raw_data.markets) instanceof Array) {
                types = request == null ? void 0 : (_request$defiType = request.defiType) == null ? void 0 : _request$defiType.split(",");
                _markets = [];

                if (types) {
                  _markets = raw_data.markets.filter(function (item) {
                    var _item$type;

                    return types.includes((_item$type = item.type) == null ? void 0 : _item$type.toUpperCase());
                  });
                } else {
                  _markets = raw_data.markets;
                }

                _markets.forEach(function (item) {
                  var marketInfo = _extends({}, item);

                  markets[item.market] = marketInfo;

                  if (item.enabled) {
                    var _item$market$match = item.market.match(/^(\w+-)?(\w+)-(\w+)$/i),
                        type = _item$market$match[1],
                        base = _item$market$match[2],
                        quote = _item$market$match[3];

                    if (type === "DUAL-" && base && quote) {
                      if (!pairs[base]) {
                        pairs[base] = {
                          tokenId: item.baseTokenId,
                          tokenList: [quote]
                        };
                      } else {
                        pairs[base].tokenList = [].concat(pairs[base].tokenList, [quote]);
                      }

                      if (!pairs[quote]) {
                        pairs[quote] = {
                          tokenId: item.baseTokenId,
                          tokenList: [base]
                        };
                      } else {
                        pairs[quote].tokenList = [].concat(pairs[quote].tokenList, [base]);
                      }
                    } else if (base && quote) {
                      // const base = market.substring(0, ind);
                      // const quote = market.substring(ind + 1, market.length);

                      if (!pairs[base]) {
                        pairs[base] = {
                          tokenId: item.baseTokenId,
                          tokenList: [quote]
                        };
                      } else {
                        pairs[base].tokenList = [].concat(pairs[base].tokenList, [quote]);
                      }
                    }
                  }
                });
              }

              marketArr = Reflect.ownKeys(markets);
              tokenArr = Reflect.ownKeys(pairs);
              return _context2.abrupt("return", {
                markets: markets,
                pairs: pairs,
                tokenArr: tokenArr,
                tokenArrStr: tokenArr.join(SEP),
                marketArr: marketArr,
                marketArrStr: marketArr.join(SEP),
                raw_data: raw_data
              });

            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getDefiMarkets(_x, _x2) {
      return _getDefiMarkets.apply(this, arguments);
    }

    return getDefiMarkets;
  }();

  _proto.orderDefi = /*#__PURE__*/function () {
    var _orderDefi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request, privateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              dataToSig = [request.exchange, request.storageId, request.accountId, request.sellToken.tokenId, request.buyToken.tokenId, request.sellToken.volume, request.buyToken.volume, request.validUntil, request.maxFeeBips, request.fillAmountBOrS ? 1 : 0, 0];
              reqParams = {
                url: exports.LOOPRING_URLs.POST_DEFI_ORDER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG_POSEIDON,
                sigObj: {
                  dataToSig: dataToSig,
                  sigPatch: exports.SigPatchField.EddsaSignature,
                  PrivateKey: privateKey
                }
              };
              _context3.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context3.sent.data;
              return _context3.abrupt("return", this.returnTxHash(raw_data));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function orderDefi(_x3, _x4, _x5) {
      return _orderDefi.apply(this, arguments);
    }

    return orderDefi;
  }();

  _proto.getDefiReward = /*#__PURE__*/function () {
    var _getDefiReward = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DEFI_REWARDS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context4.abrupt("return", _extends({}, raw_data, {
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getDefiReward(_x6, _x7) {
      return _getDefiReward.apply(this, arguments);
    }

    return getDefiReward;
  }();

  _proto.getDefiTransaction = /*#__PURE__*/function () {
    var _getDefiTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DEFI_TRANSACTIONS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context5.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context5.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context5.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userDefiTxs: raw_data.transactions,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getDefiTransaction(_x8, _x9) {
      return _getDefiTransaction.apply(this, arguments);
    }

    return getDefiTransaction;
  }();

  _proto.getDualInfos = /*#__PURE__*/function () {
    var _getDualInfos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_INFOS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context6.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context6.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context6.next = 6;
                break;
              }

              return _context6.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context6.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                dualInfo: {
                  infos: raw_data.infos,
                  index: raw_data.index,
                  balance: raw_data.balance,
                  rules: raw_data.rules
                },
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getDualInfos(_x10) {
      return _getDualInfos.apply(this, arguments);
    }

    return getDualInfos;
  }();

  _proto.getDualBalance = /*#__PURE__*/function () {
    var _getDualBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (request === void 0) {
                request = undefined;
              }

              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_BALANCE,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context7.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context7.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context7.next = 7;
                break;
              }

              return _context7.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context7.abrupt("return", {
                raw_data: raw_data,
                dualBalanceMap: [].concat(raw_data).reduce(function (prev, item) {
                  var _extends2;

                  return _extends({}, prev, (_extends2 = {}, _extends2[item.coin] = item, _extends2));
                }, {})
              });

            case 8:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getDualBalance(_x11) {
      return _getDualBalance.apply(this, arguments);
    }

    return getDualBalance;
  }() // public async getDualRule<R>(request :loopring_defs.GetDualRuleRequest): Promise<RESULT_INFO | {
  //
  // 	raw_data: R,
  // }> {
  // 	const reqParams: loopring_defs.ReqParams = {
  // 		url: LOOPRING_URLs.GET_DUAL_RULE,
  // 		queryParams: request,
  // 		method: ReqMethod.GET,
  // 		sigFlag: SIG_FLAG.NO_SIG,
  // 	};
  // 	const raw_data = (await this.makeReq().request(reqParams)).data;
  // 	if (raw_data?.resultInfo) {
  // 		return {
  // 			...raw_data?.resultInfo,
  // 		};
  // 	}
  //
  //
  // 	return {
  // 		raw_data,
  // 		dualBalanceMap: [...raw_data].reduce((item, prev) => {
  // 			return {...prev, [ item.coin ]: item};
  // 		}, {} as loopring_defs.loopring_defs.LoopringMap<loopring_defs.DualBalance>)
  // 	}
  // }
  ;

  _proto.getDualPrices =
  /*#__PURE__*/
  function () {
    var _getDualPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_PRICES,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context8.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context8.next = 6;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context8.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                infos: raw_data.infos
              });

            case 7:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getDualPrices(_x12) {
      return _getDualPrices.apply(this, arguments);
    }

    return getDualPrices;
  }();

  _proto.getDualIndex = /*#__PURE__*/function () {
    var _getDualIndex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_INDEX,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context9.abrupt("return", {
                raw_data: raw_data,
                dualPrice: raw_data
              });

            case 7:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getDualIndex(_x13) {
      return _getDualIndex.apply(this, arguments);
    }

    return getDualIndex;
  }();

  _proto.getDualTransactions = /*#__PURE__*/function () {
    var _getDualTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_TRANSACTIONS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context10.abrupt("return", {
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                userDualTxs: raw_data.transactions,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getDualTransactions(_x14, _x15) {
      return _getDualTransactions.apply(this, arguments);
    }

    return getDualTransactions;
  }();

  _proto.orderDual = /*#__PURE__*/function () {
    var _orderDual = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(request, privateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              dataToSig = [request.exchange, request.storageId, request.accountId, request.sellToken.tokenId, request.buyToken.tokenId, request.sellToken.volume, request.buyToken.volume, request.validUntil, request.maxFeeBips, request.fillAmountBOrS ? 1 : 0, 0];
              reqParams = {
                url: exports.LOOPRING_URLs.POST_DUAL_ORDER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG_POSEIDON,
                sigObj: {
                  dataToSig: dataToSig,
                  sigPatch: exports.SigPatchField.EddsaSignature,
                  PrivateKey: privateKey
                }
              };
              _context11.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context11.sent.data;
              return _context11.abrupt("return", this.returnTxHash(raw_data));

            case 6:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function orderDual(_x16, _x17, _x18) {
      return _orderDual.apply(this, arguments);
    }

    return orderDual;
  }();

  _proto.getDualUserLocked = /*#__PURE__*/function () {
    var _getDualUserLocked = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(_ref, apiKey) {
      var _ref$lockTag, lockTag, request, reqParams, raw_data;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _ref$lockTag = _ref.lockTag, lockTag = _ref$lockTag === void 0 ? [exports.DUAL_TYPE.DUAL_BASE, exports.DUAL_TYPE.DUAL_CURRENCY] : _ref$lockTag, request = /*#__PURE__*/_objectWithoutPropertiesLoose(_ref, _excluded$2);
              reqParams = {
                url: exports.LOOPRING_URLs.GET_DUAL_USER_LOCKED,
                queryParams: _extends({}, request, {
                  lockTag: lockTag.join(",")
                }),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context12.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context12.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context12.next = 7;
                break;
              }

              return _context12.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context12.abrupt("return", {
                lockRecord: raw_data.lockRecord,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function getDualUserLocked(_x19, _x20) {
      return _getDualUserLocked.apply(this, arguments);
    }

    return getDualUserLocked;
  }();

  _proto.sendStakeClaim = /*#__PURE__*/function () {
    var _sendStakeClaim = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, _ref2, accountId, counterFactualInfo, transfer, isHWAddr, ecdsaSignature, sigHW, result, isContractCheck, _result, _result2, dataToSig, reqParams, raw_data, _raw_data, _raw_data2;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              _ref2 = options ? options : {
                accountId: 0
              }, accountId = _ref2.accountId, counterFactualInfo = _ref2.counterFactualInfo;
              transfer = request.transfer;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              transfer.payeeId = 0;
              transfer.memo = "STAKE-CLAIM->" + request.accountId;

              sigHW = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
                  var result;
                  return runtime_1.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context13.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));

                return function sigHW() {
                  return _ref3.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context14.next = 26;
                break;
              }

              _context14.prev = 9;

              if (!isHWAddr) {
                _context14.next = 15;
                break;
              }

              _context14.next = 13;
              return sigHW();

            case 13:
              _context14.next = 19;
              break;

            case 15:
              _context14.next = 17;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 17:
              result = _context14.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 19:
              _context14.next = 24;
              break;

            case 21:
              _context14.prev = 21;
              _context14.t0 = _context14["catch"](9);
              throw _extends({}, this.genErr(_context14.t0));

            case 24:
              _context14.next = 51;
              break;

            case 26:
              _context14.next = 28;
              return isContract(web3, transfer.payerAddr);

            case 28:
              isContractCheck = _context14.sent;
              _context14.prev = 29;

              if (!isContractCheck) {
                _context14.next = 37;
                break;
              }

              _context14.next = 33;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 33:
              _result = _context14.sent;
              ecdsaSignature = _result.ecdsaSig;
              _context14.next = 46;
              break;

            case 37:
              if (!counterFactualInfo) {
                _context14.next = 44;
                break;
              }

              _context14.next = 40;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 40:
              _result2 = _context14.sent;
              ecdsaSignature = _result2.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context14.next = 46;
              break;

            case 44:
              _context14.next = 46;
              return sigHW();

            case 46:
              _context14.next = 51;
              break;

            case 48:
              _context14.prev = 48;
              _context14.t1 = _context14["catch"](29);
              throw _extends({}, this.genErr(_context14.t1));

            case 51:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              transfer.eddsaSignature = get_EddsaSig_Transfer(transfer, eddsaKey).result;
              transfer.ecdsaSignature = ecdsaSignature;
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_STAKE_CLAIM,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                }
              };
              _context14.prev = 56;
              _context14.next = 59;
              return this.makeReq().request(reqParams);

            case 59:
              raw_data = _context14.sent.data;

              if (!((_raw_data = raw_data) != null && _raw_data.resultInfo)) {
                _context14.next = 62;
                break;
              }

              return _context14.abrupt("return", _extends({}, (_raw_data2 = raw_data) == null ? void 0 : _raw_data2.resultInfo));

            case 62:
              return _context14.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 65:
              _context14.prev = 65;
              _context14.t2 = _context14["catch"](56);
              throw _context14.t2;

            case 68:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this, [[9, 21], [29, 48], [56, 65]]);
    }));

    function sendStakeClaim(_x21, _x22) {
      return _sendStakeClaim.apply(this, arguments);
    }

    return sendStakeClaim;
  }();

  _proto.sendStakeRedeem = /*#__PURE__*/function () {
    var _sendStakeRedeem = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(request, privateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_STAKE_REDEEM,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: privateKey
                }
              };
              _context15.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context15.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context15.next = 7;
                break;
              }

              return _context15.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context15.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 8:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function sendStakeRedeem(_x23, _x24, _x25) {
      return _sendStakeRedeem.apply(this, arguments);
    }

    return sendStakeRedeem;
  }();

  _proto.sendStake = /*#__PURE__*/function () {
    var _sendStake = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request, privateKey, apiKey) {
      var dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_STAKE,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: privateKey
                }
              };
              _context16.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context16.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context16.next = 7;
                break;
              }

              return _context16.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context16.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 8:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function sendStake(_x26, _x27, _x28) {
      return _sendStake.apply(this, arguments);
    }

    return sendStake;
  }();

  _proto.getStakeProducts = /*#__PURE__*/function () {
    var _getStakeProducts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17() {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_STAKE_PRODUCTS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context17.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context17.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context17.next = 6;
                break;
              }

              return _context17.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context17.abrupt("return", {
                products: raw_data,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function getStakeProducts() {
      return _getStakeProducts.apply(this, arguments);
    }

    return getStakeProducts;
  }();

  _proto.getStakeSummary = /*#__PURE__*/function () {
    var _getStakeSummary = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_STAKE_SUMMARY,
                queryParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context18.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context18.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context18.next = 6;
                break;
              }

              return _context18.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context18.abrupt("return", _extends({}, raw_data, {
                list: raw_data.staking,
                raw_data: raw_data
              }));

            case 7:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function getStakeSummary(_x29, _x30) {
      return _getStakeSummary.apply(this, arguments);
    }

    return getStakeSummary;
  }();

  _proto.getStakeTransactions = /*#__PURE__*/function () {
    var _getStakeTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_STAKE_TRANSACTIONS,
                queryParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context19.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context19.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context19.next = 6;
                break;
              }

              return _context19.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context19.abrupt("return", {
                list: raw_data,
                totalNum: raw_data.totalNum,
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function getStakeTransactions(_x31, _x32) {
      return _getStakeTransactions.apply(this, arguments);
    }

    return getStakeTransactions;
  }();

  _proto.getCefiMarkets = /*#__PURE__*/function () {
    var _getCefiMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20() {
      var reqParams, raw_data, markets, pairs, marketArr, tokenArr;
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_CEFI_MARKETS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context20.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context20.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context20.next = 6;
                break;
              }

              return _context20.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              markets = {};
              pairs = {}; // const isMix = url === LOOPRING_URLs.GET_MIX_MARKETS;

              if (raw_data instanceof Array) {
                // let _markets = [];
                // if (types) {
                //   _markets = raw_data.markets.filter(
                //     (item: loopring_defs.DefiMarketInfo) =>
                //       types.includes(item.type?.toUpperCase())
                //   );
                // } else {
                //   _markets = raw_data.markets;
                // }
                raw_data.forEach(function (item) {
                  var _marketInfo$cefiQuota;

                  var marketInfo = _extends({}, item);

                  markets[marketInfo.market] = _extends({}, marketInfo, {
                    type: "CEX"
                  });

                  var _ref4 = (_marketInfo$cefiQuota = marketInfo == null ? void 0 : marketInfo.cefiQuota) != null ? _marketInfo$cefiQuota : {
                    base: "",
                    quote: ""
                  },
                      base = _ref4.base,
                      quote = _ref4.quote;

                  if (marketInfo.enabled && marketInfo.cefiQuota && base && quote) {
                    if (!pairs[base]) {
                      pairs[base] = {
                        tokenId: item.baseTokenId,
                        tokenList: [quote]
                      };
                    } else {
                      pairs[base].tokenList = [].concat(pairs[base].tokenList, [quote]);
                    }

                    if (!pairs[quote]) {
                      pairs[quote] = {
                        tokenId: item.baseTokenId,
                        tokenList: [base]
                      };
                    } else {
                      pairs[quote].tokenList = [].concat(pairs[quote].tokenList, [base]);
                    }
                  }
                });
              }

              marketArr = Reflect.ownKeys(markets);
              tokenArr = Reflect.ownKeys(pairs);
              return _context20.abrupt("return", {
                markets: markets,
                pairs: pairs,
                tokenArr: tokenArr,
                tokenArrStr: tokenArr.join(SEP),
                marketArr: marketArr,
                marketArrStr: marketArr.join(SEP),
                raw_data: raw_data
              });

            case 12:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getCefiMarkets() {
      return _getCefiMarkets.apply(this, arguments);
    }

    return getCefiMarkets;
  }();

  _proto.getCefiDepth = /*#__PURE__*/function () {
    var _getCefiDepth = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(_ref5) {
      var request, reqParams, raw_data, timestamp, _getMidPrice, asks, bids, mid_price, depth;

      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              request = _ref5.request;
              reqParams = {
                url: exports.LOOPRING_URLs.GET_CEFI_DEPTH,
                queryParams: _extends({}, request),
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context21.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context21.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context21.next = 7;
                break;
              }

              return _context21.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              timestamp = raw_data["timestamp"];
              _getMidPrice = getMidPrice({
                _asks: raw_data["asks"],
                _bids: raw_data["bids"]
              }), asks = _getMidPrice.asks, bids = _getMidPrice.bids, mid_price = _getMidPrice.mid_price;
              depth = {
                symbol: raw_data.market,
                version: parseInt(raw_data.version),
                timestamp: timestamp,
                mid_price: mid_price,
                bids: bids.ab_arr,
                bids_prices: bids.ab_prices,
                bids_amtTotals: bids.ab_amtTotals,
                bids_volTotals: bids.ab_volTotals,
                bids_amtTotal: bids.amtTotal.toString(),
                bids_volTotal: bids.volTotal.toString(),
                asks: asks.ab_arr,
                asks_prices: asks.ab_prices,
                asks_amtTotals: asks.ab_amtTotals,
                asks_volTotals: asks.ab_volTotals,
                asks_amtTotal: asks.amtTotal.toString(),
                asks_volTotal: asks.volTotal.toString()
              };
              return _context21.abrupt("return", {
                depth: depth,
                raw_data: raw_data
              });

            case 11:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function getCefiDepth(_x33) {
      return _getCefiDepth.apply(this, arguments);
    }

    return getCefiDepth;
  }();

  _proto.getCefiOrders = /*#__PURE__*/function () {
    var _getCefiOrders = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(_ref6) {
      var request, apiKey, reqParams, raw_data;
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              request = _ref6.request, apiKey = _ref6.apiKey;
              reqParams = {
                url: exports.LOOPRING_URLs.GET_CEFI_ORDERS,
                queryParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context22.next = 4;
              return this.makeReq().request(reqParams);

            case 4:
              raw_data = _context22.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context22.next = 7;
                break;
              }

              return _context22.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 7:
              return _context22.abrupt("return", {
                list: raw_data.transactions,
                totalNum: raw_data.totalNum,
                raw_data: raw_data
              });

            case 8:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function getCefiOrders(_x34) {
      return _getCefiOrders.apply(this, arguments);
    }

    return getCefiOrders;
  }();

  _proto.sendCefiOrder = /*#__PURE__*/function () {
    var _sendCefiOrder = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(_ref7) {
      var request, privateKey, apiKey, dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              request = _ref7.request, privateKey = _ref7.privateKey, apiKey = _ref7.apiKey;
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_CEFI_ORDER,
                bodyParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: privateKey
                }
              };
              _context23.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context23.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context23.next = 8;
                break;
              }

              return _context23.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              return _context23.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 9:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function sendCefiOrder(_x35) {
      return _sendCefiOrder.apply(this, arguments);
    }

    return sendCefiOrder;
  }();

  return DefiAPI;
}(BaseAPI);

var _excluded$3 = ["maxFee", "token"],
    _excluded2$2 = ["maxFeeAmount", "token", "amount", "feeToken"];
var LuckTokenAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(LuckTokenAPI, _BaseAPI);

  function LuckTokenAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = LuckTokenAPI.prototype;

  _proto.getLuckTokenAgents = /*#__PURE__*/function () {
    var _getLuckTokenAgents = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var reqParams, raw_data, luckTokenAgents;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_AGENTS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              luckTokenAgents = raw_data.reduce(function (prev, item) {
                prev[item.owner] = {
                  signer: item.infos[0],
                  signerUrl: item.infos[1],
                  logoUrl: item.infos[2],
                  memo: item.infos[3]
                };
                return prev;
              }, {});
              return _context.abrupt("return", {
                raw_data: raw_data,
                luckTokenAgents: luckTokenAgents
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getLuckTokenAgents() {
      return _getLuckTokenAgents.apply(this, arguments);
    }

    return getLuckTokenAgents;
  }();

  _proto.getLuckTokenAuthorizedSigners = /*#__PURE__*/function () {
    var _getLuckTokenAuthorizedSigners = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var reqParams, raw_data, luckTokenAgents;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_AUTHORIZEDSIGNERS,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              luckTokenAgents = raw_data.reduce(function (prev, item) {
                prev[item.owner] = {
                  signer: item.infos[0],
                  signerUrl: item.infos[1],
                  logoUrl: item.infos[2],
                  memo: item.infos[3]
                };
                return prev;
              }, {});
              return _context2.abrupt("return", {
                raw_data: raw_data,
                luckTokenAgents: luckTokenAgents
              });

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getLuckTokenAuthorizedSigners() {
      return _getLuckTokenAuthorizedSigners.apply(this, arguments);
    }

    return getLuckTokenAuthorizedSigners;
  }();

  _proto.getLuckTokenClaimHistory = /*#__PURE__*/function () {
    var _getLuckTokenClaimHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request, apiKey) {
      var reqParams, raw_data, totalNum, list;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_CLAIMHISTORY,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              totalNum = raw_data.totalNum;
              list = raw_data.list;
              return _context3.abrupt("return", {
                totalNum: totalNum,
                list: list,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getLuckTokenClaimHistory(_x, _x2) {
      return _getLuckTokenClaimHistory.apply(this, arguments);
    }

    return getLuckTokenClaimHistory;
  }();

  _proto.getLuckTokenLuckyTokens = /*#__PURE__*/function () {
    var _getLuckTokenLuckyTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request, apiKey) {
      var reqParams, raw_data, totalNum, list;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_LUCKYTOKENS,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              totalNum = raw_data.totalNum;
              list = raw_data.list;
              return _context4.abrupt("return", {
                totalNum: totalNum,
                list: list,
                raw_data: raw_data
              });

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getLuckTokenLuckyTokens(_x3, _x4) {
      return _getLuckTokenLuckyTokens.apply(this, arguments);
    }

    return getLuckTokenLuckyTokens;
  }();

  _proto.getLuckTokenDetail = /*#__PURE__*/function () {
    var _getLuckTokenDetail = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_LUCKYTOKENDETAIL,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context5.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context5.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context5.abrupt("return", {
                raw_data: raw_data,
                detail: raw_data
              });

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getLuckTokenDetail(_x5, _x6) {
      return _getLuckTokenDetail.apply(this, arguments);
    }

    return getLuckTokenDetail;
  }();

  _proto.getBlindBoxDetail = /*#__PURE__*/function () {
    var _getBlindBoxDetail = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_BLINDBOXDETAIL,
                queryParams: request,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context6.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context6.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context6.next = 6;
                break;
              }

              return _context6.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context6.abrupt("return", {
                raw_data: raw_data
              });

            case 7:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getBlindBoxDetail(_x7, _x8) {
      return _getBlindBoxDetail.apply(this, arguments);
    }

    return getBlindBoxDetail;
  }();

  _proto.getLuckTokenWithdrawals = /*#__PURE__*/function () {
    var _getLuckTokenWithdrawals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_WITHDRAWALS,
                queryParams: _extends({}, request, {
                  statuses: request.statuses.join(",")
                }),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context7.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context7.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context7.next = 6;
                break;
              }

              return _context7.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context7.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                luckTokenWithdraw: raw_data.list
              });

            case 7:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getLuckTokenWithdrawals(_x9, _x10) {
      return _getLuckTokenWithdrawals.apply(this, arguments);
    }

    return getLuckTokenWithdrawals;
  }();

  _proto.getLuckTokenBalances = /*#__PURE__*/function () {
    var _getLuckTokenBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_BALANCES,
                queryParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context8.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context8.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context8.next = 6;
                break;
              }

              return _context8.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context8.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data == null ? void 0 : raw_data.length,
                tokenBalance: raw_data
              });

            case 7:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getLuckTokenBalances(_x11, _x12) {
      return _getLuckTokenBalances.apply(this, arguments);
    }

    return getLuckTokenBalances;
  }();

  _proto.getLuckTokenClaimedLuckyTokens = /*#__PURE__*/function () {
    var _getLuckTokenClaimedLuckyTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(request, apiKey) {
      var _request$hashes;

      var reqParams, raw_data;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_CLAIMEDLUCKYTOKENS,
                queryParams: _extends({}, request, {
                  hashes: request == null ? void 0 : (_request$hashes = request.hashes) == null ? void 0 : _request$hashes.join(",")
                }),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context9.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context9.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context9.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                claimedHistory: raw_data.list
              });

            case 7:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getLuckTokenClaimedLuckyTokens(_x13, _x14) {
      return _getLuckTokenClaimedLuckyTokens.apply(this, arguments);
    }

    return getLuckTokenClaimedLuckyTokens;
  }();

  _proto.getLuckTokenSummary = /*#__PURE__*/function () {
    var _getLuckTokenSummary = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_SUMMARY,
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context10.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context10.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context10.next = 6;
                break;
              }

              return _context10.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context10.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data.count,
                tokenSummaryList: raw_data.tokenSummaryList
              });

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function getLuckTokenSummary(_x15) {
      return _getLuckTokenSummary.apply(this, arguments);
    }

    return getLuckTokenSummary;
  }();

  _proto.sendLuckTokenClaimLuckyToken = /*#__PURE__*/function () {
    var _sendLuckTokenClaimLuckyToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(_ref) {
      var request, apiKey, eddsaKey, dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              request = _ref.request, apiKey = _ref.apiKey, eddsaKey = _ref.eddsaKey;
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_LUCK_TOKEN_CLAIMLUCKYTOKEN,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                },
                apiKey: apiKey
              };
              _context11.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context11.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context11.next = 8;
                break;
              }

              return _context11.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              return _context11.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function sendLuckTokenClaimLuckyToken(_x16) {
      return _sendLuckTokenClaimLuckyToken.apply(this, arguments);
    }

    return sendLuckTokenClaimLuckyToken;
  }();

  _proto.sendLuckTokenClaimBlindBox = /*#__PURE__*/function () {
    var _sendLuckTokenClaimBlindBox = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(_ref2) {
      var request, apiKey, eddsaKey, dataToSig, reqParams, raw_data;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              request = _ref2.request, apiKey = _ref2.apiKey, eddsaKey = _ref2.eddsaKey;
              dataToSig = sortObjDictionary(request);
              reqParams = {
                url: exports.LOOPRING_URLs.POST_LUCK_TOKEN_CLAIMBLINDBOX,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.EDDSA_SIG,
                sigObj: {
                  dataToSig: dataToSig,
                  PrivateKey: eddsaKey
                },
                apiKey: apiKey
              };
              _context12.next = 5;
              return this.makeReq().request(reqParams);

            case 5:
              raw_data = _context12.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context12.next = 8;
                break;
              }

              return _context12.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 8:
              return _context12.abrupt("return", _extends({
                raw_data: raw_data
              }, raw_data));

            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function sendLuckTokenClaimBlindBox(_x17) {
      return _sendLuckTokenClaimBlindBox.apply(this, arguments);
    }

    return sendLuckTokenClaimBlindBox;
  }();

  _proto.sendLuckTokenWithdraws = /*#__PURE__*/function () {
    var _sendLuckTokenWithdraws = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, _request, transfer, sigHW, result, isContractCheck, _result, _result2, maxFee, token, _transfer, reqParams, raw_data;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              accountId = options.accountId, counterFactualInfo = options.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              _request = request, transfer = _request.transfer;
              transfer.payeeId = 0;
              transfer.memo = "LuckTokenWithdrawalBy" + request.claimer;
              transfer.maxFee = {
                volume: "0",
                tokenId: 0
              };

              sigHW = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
                  var result;
                  return runtime_1.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context13.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));

                return function sigHW() {
                  return _ref3.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context14.next = 27;
                break;
              }

              _context14.prev = 10;

              if (!isHWAddr) {
                _context14.next = 16;
                break;
              }

              _context14.next = 14;
              return sigHW();

            case 14:
              _context14.next = 20;
              break;

            case 16:
              _context14.next = 18;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 18:
              result = _context14.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 20:
              _context14.next = 25;
              break;

            case 22:
              _context14.prev = 22;
              _context14.t0 = _context14["catch"](10);
              throw _extends({}, this.genErr(_context14.t0));

            case 25:
              _context14.next = 52;
              break;

            case 27:
              _context14.next = 29;
              return isContract(web3, transfer.payerAddr);

            case 29:
              isContractCheck = _context14.sent;
              _context14.prev = 30;

              if (!isContractCheck) {
                _context14.next = 38;
                break;
              }

              _context14.next = 34;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 34:
              _result = _context14.sent;
              ecdsaSignature = _result.ecdsaSig;
              _context14.next = 47;
              break;

            case 38:
              if (!counterFactualInfo) {
                _context14.next = 45;
                break;
              }

              _context14.next = 41;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 41:
              _result2 = _context14.sent;
              ecdsaSignature = _result2.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context14.next = 47;
              break;

            case 45:
              _context14.next = 47;
              return sigHW();

            case 47:
              _context14.next = 52;
              break;

            case 49:
              _context14.prev = 49;
              _context14.t1 = _context14["catch"](30);
              throw _extends({}, this.genErr(_context14.t1));

            case 52:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              maxFee = transfer.maxFee, token = transfer.token, _transfer = _objectWithoutPropertiesLoose(transfer, _excluded$3); // @ts-ignore

              _transfer = _extends({}, _transfer, {
                maxFeeAmount: maxFee.volume,
                feeToken: maxFee.tokenId,
                amount: token.volume,
                token: token.tokenId,
                ecdsaAuth: ecdsaSignature,
                eddsaSig: get_EddsaSig_Transfer(transfer, eddsaKey).result
              });
              request = _extends({}, request, {
                transfer: JSON.stringify(_transfer)
              });
              reqParams = {
                url: exports.LOOPRING_URLs.POST_LUCK_TOKEN_WITHDRAWALS,
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                bodyParams: _extends({}, request),
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context14.prev = 57;
              _context14.next = 60;
              return this.makeReq().request(reqParams);

            case 60:
              raw_data = _context14.sent.data;
              _context14.next = 66;
              break;

            case 63:
              _context14.prev = 63;
              _context14.t2 = _context14["catch"](57);
              throw _context14.t2;

            case 66:
              return _context14.abrupt("return", this.returnTxHash(raw_data));

            case 67:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this, [[10, 22], [30, 49], [57, 63]]);
    }));

    function sendLuckTokenWithdraws(_x18, _x19) {
      return _sendLuckTokenWithdraws.apply(this, arguments);
    }

    return sendLuckTokenWithdraws;
  }();

  _proto.sendLuckTokenSend = /*#__PURE__*/function () {
    var _sendLuckTokenSend = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(req, options) {
      var request, web3, chainId, walletType, eddsaKey, apiKey, isHWAddrOld, accountId, counterFactualInfo, isHWAddr, ecdsaSignature, _request2, _request2$luckyToken, maxFeeAmount, token, amount, feeToken, rest, nftData, transfer, eddsaSig, sigHW, result, isContractCheck, _result3, _result4, _sigHW, _result5, _isContractCheck, _result6, _result7, reqParams, raw_data;

      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              request = req.request, web3 = req.web3, chainId = req.chainId, walletType = req.walletType, eddsaKey = req.eddsaKey, apiKey = req.apiKey, isHWAddrOld = req.isHWAddr;
              accountId = options.accountId, counterFactualInfo = options.counterFactualInfo;
              isHWAddr = !!isHWAddrOld;
              ecdsaSignature = undefined;
              _request2 = request, _request2$luckyToken = _request2.luckyToken, maxFeeAmount = _request2$luckyToken.maxFeeAmount, token = _request2$luckyToken.token, amount = _request2$luckyToken.amount, feeToken = _request2$luckyToken.feeToken, rest = _objectWithoutPropertiesLoose(_request2$luckyToken, _excluded2$2), nftData = _request2.nftData;
              _context17.prev = 5;

              if (!nftData) {
                _context17.next = 55;
                break;
              }

              transfer = _extends({}, rest, {
                fromAccountId: rest.payerId,
                fromAddress: rest.payerAddr,
                toAccountId: 0,
                toAddress: rest.payeeAddr,
                maxFee: {
                  tokenId: feeToken,
                  amount: maxFeeAmount
                },
                payeeId: 0,
                memo: "LuckTokenSendBy" + accountId,
                token: {
                  nftData: nftData,
                  tokenId: token,
                  amount: amount
                }
              });

              sigHW = /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15() {
                  var result;
                  return runtime_1.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          _context15.next = 2;
                          return signNFTTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context15.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15);
                }));

                return function sigHW() {
                  return _ref4.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context17.next = 27;
                break;
              }

              _context17.prev = 10;

              if (!isHWAddr) {
                _context17.next = 16;
                break;
              }

              _context17.next = 14;
              return sigHW();

            case 14:
              _context17.next = 20;
              break;

            case 16:
              _context17.next = 18;
              return signTNFTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 18:
              result = _context17.sent;
              ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix02;

            case 20:
              _context17.next = 25;
              break;

            case 22:
              _context17.prev = 22;
              _context17.t0 = _context17["catch"](10);
              throw _extends({}, this.genErr(_context17.t0));

            case 25:
              _context17.next = 52;
              break;

            case 27:
              _context17.next = 29;
              return isContract(web3, transfer.payerAddr);

            case 29:
              isContractCheck = _context17.sent;
              _context17.prev = 30;

              if (!isContractCheck) {
                _context17.next = 38;
                break;
              }

              _context17.next = 34;
              return signNFTTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 34:
              _result3 = _context17.sent;
              ecdsaSignature = _result3.ecdsaSig;
              _context17.next = 47;
              break;

            case 38:
              if (!counterFactualInfo) {
                _context17.next = 45;
                break;
              }

              _context17.next = 41;
              return signNFTTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 41:
              _result4 = _context17.sent;
              ecdsaSignature = _result4.ecdsaSig; // myLog("NFTransfer ecdsaSignature:", ecdsaSignature);

              _context17.next = 47;
              break;

            case 45:
              _context17.next = 47;
              return sigHW();

            case 47:
              _context17.next = 52;
              break;

            case 49:
              _context17.prev = 49;
              _context17.t1 = _context17["catch"](30);
              throw _extends({}, this.genErr(_context17.t1));

            case 52:
              eddsaSig = get_EddsaSig_NFT_Transfer(transfer, eddsaKey).result;
              _context17.next = 103;
              break;

            case 55:
              transfer = _extends({}, rest, {
                maxFee: {
                  tokenId: feeToken,
                  volume: maxFeeAmount
                },
                payeeId: 0,
                memo: "LuckTokenSendBy" + accountId,
                token: {
                  tokenId: token,
                  volume: amount
                }
              });

              _sigHW = /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16() {
                  var result;
                  return runtime_1.wrap(function _callee16$(_context16) {
                    while (1) {
                      switch (_context16.prev = _context16.next) {
                        case 0:
                          _context16.next = 2;
                          return signTransferWithoutDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

                        case 2:
                          result = _context16.sent;
                          ecdsaSignature = result.ecdsaSig + exports.SigSuffix.Suffix03;

                        case 4:
                        case "end":
                          return _context16.stop();
                      }
                    }
                  }, _callee16);
                }));

                return function _sigHW() {
                  return _ref5.apply(this, arguments);
                };
              }();

              if (!(walletType === exports.ConnectorNames.MetaMask || walletType === exports.ConnectorNames.Gamestop || walletType === exports.ConnectorNames.OtherExtension)) {
                _context17.next = 75;
                break;
              }

              _context17.prev = 58;

              if (!isHWAddr) {
                _context17.next = 64;
                break;
              }

              _context17.next = 62;
              return _sigHW();

            case 62:
              _context17.next = 68;
              break;

            case 64:
              _context17.next = 66;
              return signTransferWithDataStructure(web3, transfer.payerAddr, transfer, chainId, walletType, accountId, counterFactualInfo);

            case 66:
              _result5 = _context17.sent;
              ecdsaSignature = _result5.ecdsaSig + exports.SigSuffix.Suffix02;

            case 68:
              _context17.next = 73;
              break;

            case 70:
              _context17.prev = 70;
              _context17.t2 = _context17["catch"](58);
              throw _extends({}, this.genErr(_context17.t2));

            case 73:
              _context17.next = 100;
              break;

            case 75:
              _context17.next = 77;
              return isContract(web3, transfer.payerAddr);

            case 77:
              _isContractCheck = _context17.sent;
              _context17.prev = 78;

              if (!_isContractCheck) {
                _context17.next = 86;
                break;
              }

              _context17.next = 82;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId);

            case 82:
              _result6 = _context17.sent;
              ecdsaSignature = _result6.ecdsaSig;
              _context17.next = 95;
              break;

            case 86:
              if (!counterFactualInfo) {
                _context17.next = 93;
                break;
              }

              _context17.next = 89;
              return signTransferWithDataStructureForContract(web3, transfer.payerAddr, transfer, chainId, accountId, counterFactualInfo);

            case 89:
              _result7 = _context17.sent;
              ecdsaSignature = _result7.ecdsaSig; // myLog("Transfer ecdsaSignature:", ecdsaSignature);

              _context17.next = 95;
              break;

            case 93:
              _context17.next = 95;
              return _sigHW();

            case 95:
              _context17.next = 100;
              break;

            case 97:
              _context17.prev = 97;
              _context17.t3 = _context17["catch"](78);
              throw _extends({}, this.genErr(_context17.t3));

            case 100:
              if (counterFactualInfo) {
                transfer.counterFactualInfo = counterFactualInfo;
              }

              transfer.eddsaSignature = get_EddsaSig_Transfer(transfer, eddsaKey).result;
              eddsaSig = get_EddsaSig_Transfer(transfer, eddsaKey).result;

            case 103:
              request = _extends({}, request, {
                nftData: nftData,
                luckyToken: _extends({}, request.luckyToken, {
                  payeeId: 0,
                  memo: "LuckTokenSendBy" + accountId,
                  eddsaSig: eddsaSig
                })
              });
              reqParams = {
                url: exports.LOOPRING_URLs.POST_LUCK_TOKEN_SENDLUCKYTOKEN,
                bodyParams: _extends({}, request),
                apiKey: apiKey,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                ecdsaSignature: ecdsaSignature
              };
              _context17.prev = 105;
              _context17.next = 108;
              return this.makeReq().request(reqParams);

            case 108:
              raw_data = _context17.sent.data;
              _context17.next = 114;
              break;

            case 111:
              _context17.prev = 111;
              _context17.t4 = _context17["catch"](105);
              throw _context17.t4;

            case 114:
              return _context17.abrupt("return", this.returnTxHash(raw_data));

            case 117:
              _context17.prev = 117;
              _context17.t5 = _context17["catch"](5);
              throw _context17.t5;

            case 120:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this, [[5, 117], [10, 22], [30, 49], [58, 70], [78, 97], [105, 111]]);
    }));

    function sendLuckTokenSend(_x20, _x21) {
      return _sendLuckTokenSend.apply(this, arguments);
    }

    return sendLuckTokenSend;
  }();

  _proto.getLuckTokenClaimedBlindBox = /*#__PURE__*/function () {
    var _getLuckTokenClaimedBlindBox = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(request, apiKey) {
      var _request$statuses;

      var reqParams, raw_data;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_LUCK_TOKEN_CLAIMEDBLINDBOX,
                queryParams: _extends({}, request, {
                  statuses: request == null ? void 0 : (_request$statuses = request.statuses) == null ? void 0 : _request$statuses.join(",")
                }),
                apiKey: apiKey,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG
              };
              _context18.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context18.sent.data;

              if (!(raw_data != null && raw_data.resultInfo)) {
                _context18.next = 6;
                break;
              }

              return _context18.abrupt("return", _extends({}, raw_data == null ? void 0 : raw_data.resultInfo));

            case 6:
              return _context18.abrupt("return", {
                raw_data: raw_data,
                totalNum: raw_data == null ? void 0 : raw_data.totalNum,
                list: raw_data.list
              });

            case 7:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function getLuckTokenClaimedBlindBox(_x22, _x23) {
      return _getLuckTokenClaimedBlindBox.apply(this, arguments);
    }

    return getLuckTokenClaimedBlindBox;
  }();

  return LuckTokenAPI;
}(BaseAPI);

var ContactAPI = /*#__PURE__*/function (_BaseAPI) {
  _inheritsLoose(ContactAPI, _BaseAPI);

  function ContactAPI() {
    return _BaseAPI.apply(this, arguments) || this;
  }

  var _proto = ContactAPI.prototype;

  _proto.getContacts = /*#__PURE__*/function () {
    var _getContacts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.GET_CONTACTS,
                queryParams: request,
                method: exports.ReqMethod.GET,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                apiKey: apiKey
              };
              _context.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context.sent.data;
              console.log(raw_data);
              return _context.abrupt("return", raw_data);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getContacts(_x, _x2) {
      return _getContacts.apply(this, arguments);
    }

    return getContacts;
  }();

  _proto.createContact = /*#__PURE__*/function () {
    var _createContact = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.CREATE_CONTACT,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                apiKey: apiKey
              };
              _context2.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context2.sent.data;
              return _context2.abrupt("return", raw_data);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function createContact(_x3, _x4) {
      return _createContact.apply(this, arguments);
    }

    return createContact;
  }();

  _proto.updateContact = /*#__PURE__*/function () {
    var _updateContact = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.UPDATE_CONTACT,
                bodyParams: request,
                method: exports.ReqMethod.POST,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                apiKey: apiKey
              };
              _context3.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context3.sent.data;
              return _context3.abrupt("return", raw_data);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function updateContact(_x5, _x6) {
      return _updateContact.apply(this, arguments);
    }

    return updateContact;
  }();

  _proto.deleteContact = /*#__PURE__*/function () {
    var _deleteContact = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(request, apiKey) {
      var reqParams, raw_data;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              reqParams = {
                url: exports.LOOPRING_URLs.DELETE_CONTACT,
                bodyParams: request,
                method: exports.ReqMethod.DELETE,
                sigFlag: exports.SIG_FLAG.NO_SIG,
                apiKey: apiKey
              };
              _context4.next = 3;
              return this.makeReq().request(reqParams);

            case 3:
              raw_data = _context4.sent.data;
              return _context4.abrupt("return", raw_data);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function deleteContact(_x7, _x8) {
      return _deleteContact.apply(this, arguments);
    }

    return deleteContact;
  }();

  return ContactAPI;
}(BaseAPI); // ContactAPI.get

exports.AmmpoolAPI = AmmpoolAPI;
exports.ApproveVal = ApproveVal;
exports.BaseAPI = BaseAPI;
exports.ContactAPI = ContactAPI;
exports.DefiAPI = DefiAPI;
exports.DelegateAPI = DelegateAPI;
exports.ExchangeAPI = ExchangeAPI;
exports.GlobalAPI = GlobalAPI;
exports.IsMobile = IsMobile;
exports.KEY_MESSAGE = KEY_MESSAGE;
exports.LuckTokenAPI = LuckTokenAPI;
exports.NFTAPI = NFTAPI;
exports.NFTFactory = NFTFactory;
exports.NFTFactory_Collection = NFTFactory_Collection;
exports.NetworkContextName = NetworkContextName;
exports.SEP = SEP;
exports.SoursURL = SoursURL;
exports.UserAPI = UserAPI;
exports.WalletAPI = WalletAPI;
exports.WhitelistedUserAPI = WhitelistedUserAPI;
exports.WsAPI = WsAPI;
exports.addHexPrefix = addHexPrefix;
exports.ammPoolCalc = ammPoolCalc;
exports.approve = approve;
exports.approveMax = approveMax;
exports.approveZero = approveZero;
exports.calcDefi = calcDefi;
exports.calcDex = calcDex;
exports.calcDual = calcDual;
exports.checkErrorInfo = checkErrorInfo;
exports.clearHexPrefix = clearHexPrefix;
exports.contractWalletValidate32 = contractWalletValidate32;
exports.contractWallet_abi = contractWallet;
exports.convertPublicKey = convertPublicKey;
exports.convertPublicKey2 = convertPublicKey2;
exports.deposit = deposit;
exports.dumpError400 = dumpError400;
exports.ecRecover = ecRecover;
exports.ecRecover2 = ecRecover2;
exports.eddsaSign = eddsaSign;
exports.eddsaSignWithDomain = eddsaSignWithDomain;
exports.erc20_abi = erc20;
exports.exchange_abi = exchange_3_6;
exports.fcWalletValid = fcWalletValid;
exports.forceWithdrawal = forceWithdrawal;
exports.formatAddress = formatAddress;
exports.formatEddsaKey = formatEddsaKey;
exports.formatKey = formatKey;
exports.formatSig = formatSig;
exports.fromGWEI = fromGWEI;
exports.fromWEI = fromWEI;
exports.genExchangeData = genExchangeData;
exports.generateKeyPair = generateKeyPair;
exports.generatePrivateKey = generatePrivateKey;
exports.getAccountArg = getAccountArg;
exports.getAmmExitEcdsaTypedData = getAmmExitEcdsaTypedData;
exports.getAmmJoinEcdsaTypedData = getAmmJoinEcdsaTypedData;
exports.getAmmpoolArg = getAmmpoolArg;
exports.getBaseQuote = getBaseQuote;
exports.getCandlestickArg = getCandlestickArg;
exports.getCefiOrderBook = getCefiOrderBook;
exports.getCurPrice = getCurPrice;
exports.getDisplaySymbol = getDisplaySymbol;
exports.getEcDSASig = getEcDSASig;
exports.getEdDSASig = getEdDSASig;
exports.getEdDSASigWithPoseidon = getEdDSASigWithPoseidon;
exports.getExistedMarket = getExistedMarket;
exports.getMidPrice = getMidPrice;
exports.getMinReceived = getMinReceived;
exports.getMixOrderArg = getMixOrderArg;
exports.getMixTradeArg = getMixTradeArg;
exports.getNFTMintTypedData = getNFTMintTypedData;
exports.getNFTTransferTypedData = getNFTTransferTypedData;
exports.getNFTWithdrawTypedData = getNFTWithdrawTypedData;
exports.getNftData = getNftData;
exports.getNftTradeHash = getNftTradeHash;
exports.getNonce = getNonce;
exports.getOrderArg = getOrderArg;
exports.getOrderBookArg = getOrderBookArg;
exports.getOrderHash = getOrderHash;
exports.getOutputAmount = getOutputAmount;
exports.getPair = getPair;
exports.getPriceImpact = getPriceImpact;
exports.getReserveInfo = getReserveInfo;
exports.getTickerArg = getTickerArg;
exports.getToPrice = getToPrice;
exports.getToken = getToken;
exports.getTokenInfoById = getTokenInfoById;
exports.getTokenInfoBySymbol = getTokenInfoBySymbol;
exports.getTokenInfoByToken = getTokenInfoByToken;
exports.getTradeArg = getTradeArg;
exports.getTransferOldTypedData = getTransferOldTypedData;
exports.getTransferTypedData = getTransferTypedData;
exports.getUpdateAccountEcdsaTypedData = getUpdateAccountEcdsaTypedData;
exports.getWithdrawTypedData = getWithdrawTypedData;
exports.get_EddsaSig_Dual_Order = get_EddsaSig_Dual_Order;
exports.get_EddsaSig_ExitAmmPool = get_EddsaSig_ExitAmmPool;
exports.get_EddsaSig_JoinAmmPool = get_EddsaSig_JoinAmmPool;
exports.get_EddsaSig_NFT_Mint = get_EddsaSig_NFT_Mint;
exports.get_EddsaSig_NFT_Order = get_EddsaSig_NFT_Order;
exports.get_EddsaSig_NFT_Transfer = get_EddsaSig_NFT_Transfer;
exports.get_EddsaSig_NFT_Withdraw = get_EddsaSig_NFT_Withdraw;
exports.get_EddsaSig_OffChainWithdraw = get_EddsaSig_OffChainWithdraw;
exports.get_EddsaSig_Transfer = get_EddsaSig_Transfer;
exports.get_Is_Nft_Token = get_Is_Nft_Token;
exports.hasMarket = hasMarket;
exports.hebao_abi = hebao;
exports.isContract = isContract;
exports.isEmpty = isEmpty;
exports.makeAmmPool = makeAmmPool;
exports.makeExitAmmCoverFeeLP = makeExitAmmCoverFeeLP;
exports.makeExitAmmPoolMini = makeExitAmmPoolMini;
exports.makeExitAmmPoolRequest2 = makeExitAmmPoolRequest2;
exports.makeJoinAmmPoolRequest = makeJoinAmmPoolRequest;
exports.makeMarket = makeMarket;
exports.makeMarkets = makeMarkets;
exports.mykeyWalletValid = mykeyWalletValid;
exports.numberWithCommas = numberWithCommas;
exports.padLeftEven = padLeftEven;
exports.personalSign = personalSign;
exports.recoverSignType = recoverSignType;
exports.sendRawTx = sendRawTx;
exports.sendTransaction = sendTransaction;
exports.sign = sign;
exports.signEip712 = signEip712;
exports.signEip712WalletConnect = signEip712WalletConnect;
exports.signEthereumTx = signEthereumTx;
exports.signNFTMintWithDataStructure = signNFTMintWithDataStructure;
exports.signNFTMintWithDataStructureForContract = signNFTMintWithDataStructureForContract;
exports.signNFTMintWithoutDataStructure = signNFTMintWithoutDataStructure;
exports.signNFTTransferWithDataStructureForContract = signNFTTransferWithDataStructureForContract;
exports.signNFTTransferWithoutDataStructure = signNFTTransferWithoutDataStructure;
exports.signNFTWithdrawWithDataStructure = signNFTWithdrawWithDataStructure;
exports.signNFTWithdrawWithDataStructureForContract = signNFTWithdrawWithDataStructureForContract;
exports.signNFTWithdrawWithoutDataStructure = signNFTWithdrawWithoutDataStructure;
exports.signOffchainWithdrawWithDataStructure = signOffchainWithdrawWithDataStructure;
exports.signOffchainWithdrawWithDataStructureForContract = signOffchainWithdrawWithDataStructureForContract;
exports.signOffchainWithdrawWithoutDataStructure = signOffchainWithdrawWithoutDataStructure;
exports.signTNFTransferWithDataStructure = signTNFTransferWithDataStructure;
exports.signTransferWithDataStructure = signTransferWithDataStructure;
exports.signTransferWithDataStructureForContract = signTransferWithDataStructureForContract;
exports.signTransferWithoutDataStructure = signTransferWithoutDataStructure;
exports.signUpdateAccountWithDataStructure = signUpdateAccountWithDataStructure;
exports.signUpdateAccountWithDataStructureForContract = signUpdateAccountWithDataStructureForContract;
exports.signUpdateAccountWithoutDataStructure = signUpdateAccountWithoutDataStructure;
exports.sleep = sleep;
exports.sortObjDictionary = sortObjDictionary;
exports.toBN = toBN;
exports.toBig = toBig;
exports.toBuffer = toBuffer;
exports.toFixed = toFixed;
exports.toGWEI = toGWEI;
exports.toHex = toHex;
exports.toNumber = toNumber;
exports.toWEI = toWEI;
exports.updatePriceImpact_new = updatePriceImpact_new;
exports.verifyEdDSASig = verifyEdDSASig;
exports.zeroPad = zeroPad;
//# sourceMappingURL=loopring-sdk.cjs.development.js.map
